{
  "timestamp": "2025-11-28T02:16:17.475Z",
  "totalQuestions": 76,
  "successful": 52,
  "errors": 24,
  "retries": {
    "totalWithRetries": 42,
    "totalRetryAttempts": 69,
    "averageRetriesPerQuestion": 1.64,
    "maxRetries": 2,
    "successfulAfterRetry": 18,
    "failedAfterRetry": 24
  },
  "metrics": {
    "exactMatch": {
      "total": 52,
      "matches": 1,
      "accuracy": 0.019230769230769232
    },
    "componentMatch": {
      "total": 52,
      "averageCM": 0.75
    },
    "executionMatch": {
      "total": 52,
      "matches": 5,
      "accuracy": 0.09615384615384616
    },
    "cosineSimilarity": {
      "total": 52,
      "average": 0.8494
    },
    "tableSimilarity": {
      "total": 52,
      "average": 0.2658
    },
    "queryAffinityScore": {
      "total": 52,
      "average": 0.5576
    }
  },
  "results": [
    {
      "question": "Existe correlação entre a prioridade da iniciativa e o progresso médio de seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_history kh ON o.id = kh.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "error": "column kh.okr_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.priority, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.priority ORDER BY i.priority;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_history kh ON o.id = kh.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 3165,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9834177983706499,
      "finalSql": "SELECT i.priority, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7417088991853249
    },
    {
      "question": "Iniciativas com maior prioridade tendem a ter maior progresso médio nos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.priority ORDER BY avg_progress DESC;"
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.priority ORDER BY avg_progress DESC;",
      "executionTimeMs": 1873,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9773137603803715,
      "finalSql": "SELECT i.priority, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.priority ORDER BY avg_progress DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7386568801901858
    },
    {
      "question": "Qual é a relação entre prioridade da iniciativa e o desempenho médio dos seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(o.progress / NULLIF(o.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.priority ORDER BY i.priority;",
          "error": "column o.progress does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.priority, AVG(k.progress / NULLIF(k.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(o.progress / NULLIF(o.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 1456,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9772829254200399,
      "finalSql": "SELECT i.priority, AVG(k.progress / NULLIF(k.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.98864146271002
    },
    {
      "question": "Iniciativas de qual categoria têm maior taxa de conclusão de KRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, COUNT(k.id) AS num_krs, COUNT(CASE WHEN kh.progress / kh.target >= 1 THEN 1 ELSE NULL END) AS num_krs_concluded, ROUND(COUNT(CASE WHEN kh.progress / kh.target >= 1 THEN 1 ELSE NULL END) * 1.0 / COUNT(k.id), 2) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category ORDER BY completion_rate DESC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT i.category, COUNT(k.id) AS num_krs, COUNT(CASE WHEN kh.progress / kh.target >= 1 THEN 1 ELSE NULL END) AS num_krs_concluded, ROUND(COUNT(CASE WHEN kh.progress / kh.target >= 1 THEN 1 ELSE NULL END) * 1.0 / COUNT(k.id), 2) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category ORDER BY completion_rate DESC LIMIT 1;",
      "executionTimeMs": 3318,
      "goldSql": "SELECT i.category, CAST(SUM(CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) AS FLOAT) / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8910702338531552,
      "finalSql": "SELECT i.category, COUNT(k.id) AS num_krs, COUNT(CASE WHEN kh.progress / kh.target >= 1 THEN 1 ELSE NULL END) AS num_krs_concluded, ROUND(COUNT(CASE WHEN kh.progress / kh.target >= 1 THEN 1 ELSE NULL END) * 1.0 / COUNT(k.id), 2) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category ORDER BY completion_rate DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.0625,
      "queryAffinityScore": 0.4767851169265776
    },
    {
      "question": "Qual categoria de iniciativa apresenta menor frequência de updates?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, COUNT(*) as update_frequency FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id GROUP BY i.category ORDER BY COUNT(*) ASC LIMIT 1"
        }
      ],
      "predictedSql": "SELECT i.category, COUNT(*) as update_frequency FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id GROUP BY i.category ORDER BY COUNT(*) ASC LIMIT 1",
      "executionTimeMs": 1951,
      "goldSql": "SELECT i.category, CAST(COUNT(iu.id) AS FLOAT) / COUNT(DISTINCT i.id) AS avg_updates_per_initiative FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY avg_updates_per_initiative ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.83945684666449,
      "finalSql": "SELECT i.category, COUNT(*) as update_frequency FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id GROUP BY i.category ORDER BY COUNT(*) ASC LIMIT 1",
      "executionMatch": false,
      "tableSimilarity": 0.125,
      "queryAffinityScore": 0.482228423332245
    },
    {
      "question": "Colaboradores com mais KRs favoritos têm desempenho melhor nos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC LIMIT 10;"
        }
      ],
      "predictedSql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC LIMIT 10;",
      "executionTimeMs": 2837,
      "goldSql": "SELECT c.name, COUNT(k.id) AS total_bookmarked_krs, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress_of_bookmarked_krs FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ORDER BY total_bookmarked_krs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.9065987721937148,
      "finalSql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC LIMIT 10;",
      "executionMatch": false,
      "tableSimilarity": 0.07333333333333325,
      "queryAffinityScore": 0.489966052763524
    },
    {
      "question": "Há diferença de progresso médio entre KRs do tipo “YES_NO” e “NUMERIC”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress, COUNT(*) AS total_krs FROM kr WHERE metric IN ('YES_NO', 'NUMERIC') GROUP BY metric ORDER BY metric;"
        }
      ],
      "predictedSql": "SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress, COUNT(*) AS total_krs FROM kr WHERE metric IN ('YES_NO', 'NUMERIC') GROUP BY metric ORDER BY metric;",
      "executionTimeMs": 2047,
      "goldSql": "SELECT k.metric, AVG(k.progress / NULLIF(k.target, 0)) AS average_progress FROM kr k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.923693446749651,
      "finalSql": "SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress, COUNT(*) AS total_krs FROM kr WHERE metric IN ('YES_NO', 'NUMERIC') GROUP BY metric ORDER BY metric;",
      "executionMatch": false,
      "tableSimilarity": 0.6666666666666667,
      "queryAffinityScore": 0.7951800567081588
    },
    {
      "question": "Quais iniciativas concentram mais KRs com métrica percentual?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, COUNT(k.id) AS num_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY num_krs DESC LIMIT 10;"
        }
      ],
      "predictedSql": "SELECT i.title, COUNT(k.id) AS num_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY num_krs DESC LIMIT 10;",
      "executionTimeMs": 1559,
      "goldSql": "SELECT i.title, COUNT(k.id) AS total_percentage_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.id, i.title ORDER BY total_percentage_krs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9104835202325606,
      "finalSql": "SELECT i.title, COUNT(k.id) AS num_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY num_krs DESC LIMIT 10;",
      "executionMatch": false,
      "tableSimilarity": 0.13953488372093026,
      "queryAffinityScore": 0.5250092019767454
    },
    {
      "question": "Qual a média de progresso dos OKRs de iniciativas de alta prioridade?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(iu.progress / NULLIF(iu.target,0)) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 'high'",
          "error": "column iu.progress does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(iu.brutal_facts) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 'high'",
          "fixed": true,
          "error": "function avg(text) does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT AVG(iu.highlights) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 'high'",
          "fixed": true,
          "error": "function avg(text) does not exist"
        }
      ],
      "predictedSql": "SELECT AVG(iu.progress / NULLIF(iu.target,0)) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 'high'",
      "executionTimeMs": 746,
      "goldSql": "SELECT AVG(k.progress / NULLIF(k.target, 0)) AS average_okr_progress_high_priority FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8768131712579318,
      "finalSql": "SELECT AVG(iu.highlights) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 'high'",
      "error": "Erro de execução no banco após 3 tentativa(s): function avg(text) does not exist",
      "executionMatch": false
    },
    {
      "question": "Qual o impacto dos updates de iniciativa no progresso dos KRs associados?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_before_update, AVG(kh2.progress / NULLIF(kh2.target,0)) AS avg_progress_after_update FROM initiative_update iu JOIN kr_history kh ON iu.initiative_id = kh.initiative_id JOIN kr k ON kh.kr_id = k.id JOIN kr_history kh2 ON iu.initiative_id = kh2.initiative_id AND kh2.date > iu.created_date JOIN kr k2 ON kh2.kr_id = k2.id GROUP BY iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month ORDER BY iu.created_date;",
          "error": "column kh.initiative_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_before_update, AVG(kh2.progress / NULLIF(kh2.target,0)) AS avg_progress_after_update FROM initiative_update iu JOIN kr_history kh ON iu.initiative_id = kh.initiative_id JOIN kr k ON kh.kr_id = k.id JOIN kr_history kh2 ON iu.initiative_id = kh2.initiative_id AND kh2.date > iu.created_date JOIN kr k2 ON kh2.kr_id = k2.id WHERE kh.initiative_id IS NOT NULL GROUP BY iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month ORDER BY iu.created_date;",
          "fixed": true,
          "error": "column kh.initiative_id does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_before_update, AVG(kh2.progress / NULLIF(kh2.target,0)) AS avg_progress_after_update FROM initiative_update iu JOIN kr_history kh ON iu.initiative_id = kh.initiative_id JOIN kr k ON kh.kr_id = k.id JOIN kr_history kh2 ON iu.initiative_id = kh2.initiative_id AND kh2.date > iu.created_date JOIN kr k2 ON kh2.kr_id = k2.id WHERE iu.initiative_id IS NOT NULL GROUP BY iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month ORDER BY iu.created_date;",
          "fixed": true,
          "error": "column kh.initiative_id does not exist"
        }
      ],
      "predictedSql": "SELECT iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_before_update, AVG(kh2.progress / NULLIF(kh2.target,0)) AS avg_progress_after_update FROM initiative_update iu JOIN kr_history kh ON iu.initiative_id = kh.initiative_id JOIN kr k ON kh.kr_id = k.id JOIN kr_history kh2 ON iu.initiative_id = kh2.initiative_id AND kh2.date > iu.created_date JOIN kr k2 ON kh2.kr_id = k2.id GROUP BY iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month ORDER BY iu.created_date;",
      "executionTimeMs": 3997,
      "goldSql": "WITH normalized_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(k.target,0)) AS rel_progress, LAG(kh.progress / NULLIF(k.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS rel_before FROM kr_history kh JOIN kr k ON k.id = kh.kr_id), updates AS (SELECT initiative_id, created_date FROM initiative_update), link AS (SELECT nh.kr_id, nh.rel_progress, nh.rel_before, nh.date AS progress_date, (SELECT iu.created_date FROM initiative_update iu JOIN kr k ON iu.initiative_id = k.okr_id JOIN okr o ON k.okr_id = o.id WHERE iu.initiative_id = o.initiative_id AND iu.created_date < nh.date ORDER BY iu.created_date DESC LIMIT 1) AS last_update FROM normalized_history nh JOIN kr k ON nh.kr_id = k.id JOIN okr o ON k.okr_id = o.id) SELECT AVG(rel_progress - rel_before) AS avg_progress_change_after_update FROM link WHERE rel_before IS NOT NULL AND last_update IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 0,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.4375
      },
      "cosineSimilarity": 0.821136245533918,
      "finalSql": "SELECT iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_before_update, AVG(kh2.progress / NULLIF(kh2.target,0)) AS avg_progress_after_update FROM initiative_update iu JOIN kr_history kh ON iu.initiative_id = kh.initiative_id JOIN kr k ON kh.kr_id = k.id JOIN kr_history kh2 ON iu.initiative_id = kh2.initiative_id AND kh2.date > iu.created_date JOIN kr k2 ON kh2.kr_id = k2.id WHERE iu.initiative_id IS NOT NULL GROUP BY iu.id, iu.initiative_id, iu.created_date, iu.brutal_facts, iu.next_steps, iu.year_month ORDER BY iu.created_date;",
      "error": "Erro de execução no banco após 3 tentativa(s): column kh.initiative_id does not exist",
      "executionMatch": false
    },
    {
      "question": "Há aumento no ritmo de updates próximo aos deadlines dos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, i.deadline, COUNT(*) as num_updates, SUM(CASE WHEN iu.last_modified_date > i.deadline - INTERVAL '7 days' THEN 1 ELSE 0 END) as recent_updates FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.last_modified_date > (SELECT MIN(last_modified_date) FROM initiative_update) GROUP BY i.title, i.deadline ORDER BY i.deadline;",
          "error": "column i.deadline does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title, o.deadline, COUNT(*) as num_updates, SUM(CASE WHEN iu.last_modified_date > o.deadline - INTERVAL '7 days' THEN 1 ELSE 0 END) as recent_updates FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.last_modified_date > (SELECT MIN(last_modified_date) FROM initiative_update) GROUP BY i.title, o.deadline ORDER BY o.deadline;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.title, i.deadline, COUNT(*) as num_updates, SUM(CASE WHEN iu.last_modified_date > i.deadline - INTERVAL '7 days' THEN 1 ELSE 0 END) as recent_updates FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.last_modified_date > (SELECT MIN(last_modified_date) FROM initiative_update) GROUP BY i.title, i.deadline ORDER BY i.deadline;",
      "executionTimeMs": 2884,
      "goldSql": "SELECT o.id AS okr_id, o.deadline, SUM(CASE WHEN iu.created_date BETWEEN o.deadline - INTERVAL '30 days' AND o.deadline THEN 1 ELSE 0 END) AS updates_last_30_days, SUM(CASE WHEN iu.created_date < o.deadline - INTERVAL '30 days' THEN 1 ELSE 0 END) AS updates_before_30_days FROM okr o LEFT JOIN initiative_update iu ON iu.initiative_id = o.initiative_id AND iu.created_date <= o.deadline GROUP BY o.id, o.deadline ORDER BY o.deadline;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.846385680822504,
      "finalSql": "SELECT i.title, o.deadline, COUNT(*) as num_updates, SUM(CASE WHEN iu.last_modified_date > o.deadline - INTERVAL '7 days' THEN 1 ELSE 0 END) as recent_updates FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.last_modified_date > (SELECT MIN(last_modified_date) FROM initiative_update) GROUP BY i.title, o.deadline ORDER BY o.deadline;",
      "executionMatch": false,
      "tableSimilarity": 0.36940298507462677,
      "queryAffinityScore": 0.6078943329485653
    },
    {
      "question": "Qual é o alinhamento entre as datas de fim de iniciativa e deadlines de OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.end_date, o.deadline, i.id FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date = o.deadline ORDER BY i.id;"
        }
      ],
      "predictedSql": "SELECT i.end_date, o.deadline, i.id FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date = o.deadline ORDER BY i.id;",
      "executionTimeMs": 2140,
      "goldSql": "SELECT CASE WHEN o.deadline < i.end_date THEN 'OKR ANTES da Iniciativa' WHEN o.deadline = i.end_date THEN 'OKR e Iniciativa na MESMA DATA' WHEN o.deadline > i.end_date THEN 'OKR DEPOIS da Iniciativa' ELSE 'Sem data de fim para Iniciativa' END AS alinhamento, COUNT(o.id) AS total_okrs FROM okr o JOIN initiative i ON o.initiative_id = i.id GROUP BY alinhamento;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.6937222509390999,
      "finalSql": "SELECT i.end_date, o.deadline, i.id FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date = o.deadline ORDER BY i.id;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.34686112546954995
    },
    {
      "question": "Quantos OKRs estão diretamente vinculados a iniciativas prioritárias (por categoria) e quantos ainda não possuem ligação clara com uma iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(i.id) AS okrs_linked_to_priority_initiatives, COUNT(o.id) AS okrs_without_clear_link FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = TRUE GROUP BY i.priority;",
          "error": "operator does not exist: integer = boolean"
        },
        {
          "attempt": 2,
          "sql": "SELECT COUNT(i.id) AS okrs_linked_to_priority_initiatives, COUNT(o.id) AS okrs_without_clear_link FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = 1 GROUP BY i.priority;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT COUNT(i.id) AS okrs_linked_to_priority_initiatives, COUNT(o.id) AS okrs_without_clear_link FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = TRUE GROUP BY i.priority;",
      "executionTimeMs": 2175,
      "goldSql": "SELECT COALESCE(i.category, 'SEM INICIATIVA') AS category, COALESCE(i.priority, -1) AS priority, COUNT(o.id) AS okrs_count FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id GROUP BY category, priority ORDER BY category, priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.7775073535238445,
      "finalSql": "SELECT COUNT(i.id) AS okrs_linked_to_priority_initiatives, COUNT(o.id) AS okrs_without_clear_link FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = 1 GROUP BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.38875367676192224
    },
    {
      "question": "Quantas atualizações de iniciativas foram registradas neste trimestre e quais são os principais temas dos “highlights” e “brutal facts”?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, EXTRACT(QUARTER FROM iu.created_date) AS quarter, ARRAY_AGG(DISTINCT REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts, ',') ORDER BY REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts)) AS highlights_brutal_facts FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id WHERE EXTRACT(QUARTER FROM iu.created_date) = 3 GROUP BY year, month, quarter ORDER BY year, month, quarter;",
          "error": "function regexp_split_to_table(text) does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT COUNT(*) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, EXTRACT(QUARTER FROM iu.created_date) AS quarter, ARRAY_AGG(DISTINCT REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts, ',') ORDER BY REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts)) AS highlights_brutal_facts FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id WHERE EXTRACT(QUARTER FROM iu.created_date) = 3 GROUP BY year, month, quarter ORDER BY year, month, quarter;",
          "fixed": true,
          "error": "function regexp_split_to_table(text) does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT COUNT(*) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, EXTRACT(QUARTER FROM iu.created_date) AS quarter, ARRAY_AGG(DISTINCT REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts, ',') ORDER BY REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts)) AS highlights_brutal_facts FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id WHERE EXTRACT(QUARTER FROM iu.created_date) = 3 GROUP BY year, month, quarter ORDER BY year, month, quarter;",
          "fixed": true,
          "error": "function regexp_split_to_table(text) does not exist"
        }
      ],
      "predictedSql": "SELECT COUNT(*) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, EXTRACT(QUARTER FROM iu.created_date) AS quarter, ARRAY_AGG(DISTINCT REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts, ',') ORDER BY REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts)) AS highlights_brutal_facts FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id WHERE EXTRACT(QUARTER FROM iu.created_date) = 3 GROUP BY year, month, quarter ORDER BY year, month, quarter;",
      "executionTimeMs": 1598,
      "goldSql": "SELECT COUNT(iu.id) AS total_updates_trimestre, STRING_AGG(iu.highlights, ' | ') AS todos_highlights, STRING_AGG(iu.brutal_facts, ' | ') AS todos_brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', CURRENT_DATE) AND iu.created_date < date_trunc('quarter', CURRENT_DATE) + interval '3 month';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.7848793461825326,
      "finalSql": "SELECT COUNT(*) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, EXTRACT(QUARTER FROM iu.created_date) AS quarter, ARRAY_AGG(DISTINCT REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts, ',') ORDER BY REGEXP_SPLIT_TO_TABLE(iu.highlights, ',') || ' - ' || REGEXP_SPLIT_TO_TABLE(iu.brutal_facts)) AS highlights_brutal_facts FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id WHERE EXTRACT(QUARTER FROM iu.created_date) = 3 GROUP BY year, month, quarter ORDER BY year, month, quarter;",
      "error": "Erro de execução no banco após 3 tentativa(s): function regexp_split_to_table(text) does not exist",
      "executionMatch": false
    },
    {
      "question": "Apresentar os KRs com maior desvio padrão de progresso ao longo do histórico, indicando instabilidade.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.id, k.title, k.direction, STDDEV(kh.progress / NULLIF(kh.target,0)) AS std_dev_progress FROM kr k JOIN kr_history kh ON k.id = kh.kr_id GROUP BY k.id, k.title, k.direction ORDER BY STDDEV(kh.progress / NULLIF(kh.target,0)) DESC LIMIT 10;"
        }
      ],
      "predictedSql": "SELECT k.id, k.title, k.direction, STDDEV(kh.progress / NULLIF(kh.target,0)) AS std_dev_progress FROM kr k JOIN kr_history kh ON k.id = kh.kr_id GROUP BY k.id, k.title, k.direction ORDER BY STDDEV(kh.progress / NULLIF(kh.target,0)) DESC LIMIT 10;",
      "executionTimeMs": 1146,
      "goldSql": "SELECT k.title, o.description AS okr_description, STDDEV(kh.progress / NULLIF(kh.target, 0)) AS desvio_padrao_progresso FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id GROUP BY kh.kr_id, k.title, o.description HAVING COUNT(kh.id) > 1 ORDER BY desvio_padrao_progresso DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.7876295054804757,
      "finalSql": "SELECT k.id, k.title, k.direction, STDDEV(kh.progress / NULLIF(kh.target,0)) AS std_dev_progress FROM kr k JOIN kr_history kh ON k.id = kh.kr_id GROUP BY k.id, k.title, k.direction ORDER BY STDDEV(kh.progress / NULLIF(kh.target,0)) DESC LIMIT 10;",
      "executionMatch": false,
      "tableSimilarity": 0.0024999999999999467,
      "queryAffinityScore": 0.39506475274023783
    },
    {
      "question": "Comparar o progresso médio dos KRs com o progresso médio das iniciativas às quais estão vinculados, destacando as maiores variações.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, i.title, k.progress, k.target, kh.progress, kh.target, kh.progress / NULLIF(kh.target,0) AS kr_progress, i.progress / NULLIF(i.target,0) AS initiative_progress, kh.progress - i.progress AS variação FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON iu.id = k.id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.category IN (SELECT category FROM initiative GROUP BY category ORDER BY COUNT(*) DESC LIMIT 5) ORDER BY ABS(kh.progress - iu.progress) DESC;",
          "error": "column i.progress does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.category, i.title, k.progress, k.target, kh.progress, kh.target, kh.progress / NULLIF(kh.target,0) AS kr_progress, iu.progress / NULLIF(iu.target,0) AS initiative_progress, kh.progress - iu.progress AS variação FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON iu.id = k.id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.category IN (SELECT category FROM initiative GROUP BY category ORDER BY COUNT(*) DESC LIMIT 5) ORDER BY ABS(kh.progress - iu.progress) DESC;",
          "fixed": true,
          "error": "column iu.progress does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.category, i.title, k.progress, k.target, kh.progress, kh.target, kh.progress / NULLIF(kh.target,0) AS kr_progress, iu.highlights / NULLIF(iu.target,0) AS initiative_progress, kh.progress - iu.highlights / NULLIF(iu.target,0) AS variação FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON iu.id = k.id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.category IN (SELECT category FROM initiative GROUP BY category ORDER BY COUNT(*) DESC LIMIT 5) ORDER BY ABS(kh.progress - iu.highlights / NULLIF(iu.target,0)) DESC;",
          "fixed": true,
          "error": "column iu.target does not exist"
        }
      ],
      "predictedSql": "SELECT i.category, i.title, k.progress, k.target, kh.progress, kh.target, kh.progress / NULLIF(kh.target,0) AS kr_progress, i.progress / NULLIF(i.target,0) AS initiative_progress, kh.progress - i.progress AS variação FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON iu.id = k.id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.category IN (SELECT category FROM initiative GROUP BY category ORDER BY COUNT(*) DESC LIMIT 5) ORDER BY ABS(kh.progress - iu.progress) DESC;",
      "executionTimeMs": 3162,
      "goldSql": "WITH InitiativeProgress AS (SELECT i.id AS initiative_id, AVG(k.progress / NULLIF(k.target, 0)) AS avg_initiative_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id), CalculatedVariance AS (SELECT k.title AS kr_title, (k.progress / NULLIF(k.target, 0)) AS kr_current_progress, ip.avg_initiative_progress, (k.progress / NULLIF(k.target, 0)) - ip.avg_initiative_progress AS progress_variance FROM kr k JOIN okr o ON k.okr_id = o.id JOIN InitiativeProgress ip ON o.initiative_id = ip.initiative_id) SELECT kr_title, kr_current_progress, avg_initiative_progress, progress_variance FROM CalculatedVariance ORDER BY ABS(progress_variance) DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 0,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.671562717654762,
      "finalSql": "SELECT i.category, i.title, k.progress, k.target, kh.progress, kh.target, kh.progress / NULLIF(kh.target,0) AS kr_progress, iu.highlights / NULLIF(iu.target,0) AS initiative_progress, kh.progress - iu.highlights / NULLIF(iu.target,0) AS variação FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON iu.id = k.id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.category IN (SELECT category FROM initiative GROUP BY category ORDER BY COUNT(*) DESC LIMIT 5) ORDER BY ABS(kh.progress - iu.highlights / NULLIF(iu.target,0)) DESC;",
      "error": "Erro de execução no banco após 3 tentativa(s): column iu.target does not exist",
      "executionMatch": false
    },
    {
      "question": "Construir o ranking das categorias de iniciativa com base no progresso médio ponderado pelo número de KRs associados.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, COUNT(kh.id) AS num_krs, RANK() OVER (ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) * COUNT(kh.id) DESC) AS rank FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category ORDER BY rank;"
        }
      ],
      "predictedSql": "SELECT i.category, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, COUNT(kh.id) AS num_krs, RANK() OVER (ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) * COUNT(kh.id) DESC) AS rank FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category ORDER BY rank;",
      "executionTimeMs": 3659,
      "goldSql": "SELECT i.category, AVG(k.progress / NULLIF(k.target, 0)) AS weighted_average_progress, COUNT(k.id) AS total_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8789594631392278,
      "finalSql": "SELECT i.category, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, COUNT(kh.id) AS num_krs, RANK() OVER (ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) * COUNT(kh.id) DESC) AS rank FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category ORDER BY rank;",
      "executionMatch": false,
      "tableSimilarity": 0.25,
      "queryAffinityScore": 0.564479731569614
    },
    {
      "question": "Avaliar a correlação entre o número de updates registrados em cada iniciativa e o progresso médio de seus KRs.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.id, i.title, COUNT(iu.id) AS num_updates, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id JOIN kr k ON kh.kr_id = k.id GROUP BY i.id, i.title ORDER BY i.id;",
          "error": "column kh.initiative_update_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.id, i.title, COUNT(iu.id) AS num_updates, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON i.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.id, i.title ORDER BY i.id;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.id, i.title, COUNT(iu.id) AS num_updates, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id JOIN kr k ON kh.kr_id = k.id GROUP BY i.id, i.title ORDER BY i.id;",
      "executionTimeMs": 1979,
      "goldSql": "WITH InitiativeMetrics AS (SELECT i.id AS initiative_id, COUNT(iu.id) AS total_updates, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id) SELECT CORR(im.total_updates, im.average_kr_progress) AS correlation_updates_vs_progress FROM InitiativeMetrics im;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8133547641378823,
      "finalSql": "SELECT i.id, i.title, COUNT(iu.id) AS num_updates, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON i.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.id, i.title ORDER BY i.id;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.40667738206894116
    },
    {
      "question": "Detectar iniciativas que apresentaram regressão média no progresso de KRs durante o último ciclo.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) AS avg_progress_prev FROM initiative i JOIN kr_history kh ON i.id = kh.initiative_id JOIN kr k ON kh.kr_id = k.id WHERE kh.year_month = (SELECT MAX(year_month) FROM kr_history) AND kh.direction = 'down' GROUP BY i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) < AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) ORDER BY avg_progress_prev DESC;",
          "error": "column kh.initiative_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) AS avg_progress_prev FROM initiative i JOIN kr_history kh ON i.id = kh.okr_id JOIN kr k ON kh.kr_id = k.id WHERE kh.year_month = (SELECT MAX(year_month) FROM kr_history) AND kh.direction = 'down' GROUP BY i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) < AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) ORDER BY avg_progress_prev DESC;",
          "fixed": true,
          "error": "column kh.okr_id does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) AS avg_progress_prev FROM initiative i JOIN kr_history kh ON i.id = kh.okr_id JOIN kr k ON kh.kr_id = k.id WHERE kh.year_month = (SELECT MAX(year_month) FROM kr_history) AND kh.direction = 'down' GROUP BY i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) < AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) ORDER BY avg_progress_prev DESC;",
          "fixed": true,
          "error": "column kh.okr_id does not exist"
        }
      ],
      "predictedSql": "SELECT i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) AS avg_progress_prev FROM initiative i JOIN kr_history kh ON i.id = kh.initiative_id JOIN kr k ON kh.kr_id = k.id WHERE kh.year_month = (SELECT MAX(year_month) FROM kr_history) AND kh.direction = 'down' GROUP BY i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) < AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) ORDER BY avg_progress_prev DESC;",
      "executionTimeMs": 5230,
      "goldSql": "WITH hist AS (SELECT kh.kr_id, (kh.progress / NULLIF(kh.target,0)) AS rel, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev, o.initiative_id FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id), diffs AS (SELECT initiative_id, rel - prev AS diff FROM hist WHERE prev IS NOT NULL) SELECT i.title, AVG(diff) AS avg_regression_change FROM diffs d JOIN initiative i ON d.initiative_id = i.id GROUP BY i.id, i.title HAVING AVG(diff) < 0 ORDER BY avg_regression_change ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8247963336548415,
      "finalSql": "SELECT i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) AS avg_progress_prev FROM initiative i JOIN kr_history kh ON i.id = kh.okr_id JOIN kr k ON kh.kr_id = k.id WHERE kh.year_month = (SELECT MAX(year_month) FROM kr_history) AND kh.direction = 'down' GROUP BY i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) < AVG(kh.progress_prev / NULLIF(kh.target_prev,0)) ORDER BY avg_progress_prev DESC;",
      "error": "Erro de execução no banco após 3 tentativa(s): column kh.okr_id does not exist",
      "executionMatch": false
    },
    {
      "question": "Qual a distribuição de iniciativas por categoria?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, COUNT(*) as total FROM initiative i GROUP BY i.category ORDER BY i.category;"
        }
      ],
      "predictedSql": "SELECT i.category, COUNT(*) as total FROM initiative i GROUP BY i.category ORDER BY i.category;",
      "executionTimeMs": 1692,
      "goldSql": "SELECT category, COUNT(id) AS total_initiatives, CAST(COUNT(id) AS FLOAT) * 100 / (SELECT COUNT(*) FROM initiative) AS percentage FROM initiative GROUP BY category ORDER BY total_initiatives DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.7492064669691045,
      "finalSql": "SELECT i.category, COUNT(*) as total FROM initiative i GROUP BY i.category ORDER BY i.category;",
      "executionMatch": false,
      "tableSimilarity": 0.6666666666666667,
      "queryAffinityScore": 0.7079365668178856
    },
    {
      "question": "Quais iniciativas têm mais OKRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, COUNT(o.id) AS num_okrs FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY num_okrs DESC LIMIT 10;"
        }
      ],
      "predictedSql": "SELECT i.title, COUNT(o.id) AS num_okrs FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY num_okrs DESC LIMIT 10;",
      "executionTimeMs": 1442,
      "goldSql": "SELECT i.title, COUNT(o.id) AS total_okrs FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY total_okrs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9104495815395665,
      "finalSql": "SELECT i.title, COUNT(o.id) AS num_okrs FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY num_okrs DESC LIMIT 10;",
      "executionMatch": false,
      "tableSimilarity": 0.21739130434782605,
      "queryAffinityScore": 0.5639204429436963
    },
    {
      "question": "Quantas iniciativas estão em andamento neste trimestre?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM initiative WHERE start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE AND start_date <= CURRENT_DATE + INTERVAL '3 month' AND end_date >= CURRENT_DATE + INTERVAL '3 month'"
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM initiative WHERE start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE AND start_date <= CURRENT_DATE + INTERVAL '3 month' AND end_date >= CURRENT_DATE + INTERVAL '3 month'",
      "executionTimeMs": 1523,
      "goldSql": "SELECT COUNT(id) FROM initiative WHERE start_date <= date_trunc('quarter', CURRENT_DATE) + INTERVAL '3 month' - INTERVAL '1 second' AND (end_date IS NULL OR end_date >= date_trunc('quarter', CURRENT_DATE));",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.8473114618956973,
      "finalSql": "SELECT COUNT(*) FROM initiative WHERE start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE AND start_date <= CURRENT_DATE + INTERVAL '3 month' AND end_date >= CURRENT_DATE + INTERVAL '3 month'",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.42365573094784864
    },
    {
      "question": "Quais iniciativas estão sem updates há mais de 30 dias?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.* FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.id IS NULL AND i.last_modified_date < NOW() - INTERVAL '30 days';"
        }
      ],
      "predictedSql": "SELECT i.* FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.id IS NULL AND i.last_modified_date < NOW() - INTERVAL '30 days';",
      "executionTimeMs": 2155,
      "goldSql": "SELECT i.title, MAX(iu.created_date) AS last_update FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title HAVING MAX(iu.created_date) IS NULL OR MAX(iu.created_date) < NOW() - INTERVAL '30' DAY ORDER BY last_update ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8242816911896876,
      "finalSql": "SELECT i.* FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.id IS NULL AND i.last_modified_date < NOW() - INTERVAL '30 days';",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4121408455948438
    },
    {
      "question": "Quais iniciativas têm prioridade máxima, mas baixo progresso de OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, i.priority, i.id FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON o.id = iu.initiative_id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.priority = 1 AND (kh.progress / NULLIF(kh.target,0)) < 0.5 GROUP BY i.title, i.priority, i.id ORDER BY i.priority DESC;"
        }
      ],
      "predictedSql": "SELECT i.title, i.priority, i.id FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON o.id = iu.initiative_id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.priority = 1 AND (kh.progress / NULLIF(kh.target,0)) < 0.5 GROUP BY i.title, i.priority, i.id ORDER BY i.priority DESC;",
      "executionTimeMs": 2909,
      "goldSql": "SELECT i.title, i.priority, AVG(k.progress / NULLIF(k.target, 0)) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.5 ORDER BY avg_okr_progress ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8379004918327273,
      "finalSql": "SELECT i.title, i.priority, i.id FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON o.id = iu.initiative_id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE i.priority = 1 AND (kh.progress / NULLIF(kh.target,0)) < 0.5 GROUP BY i.title, i.priority, i.id ORDER BY i.priority DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.16666666666666663,
      "queryAffinityScore": 0.5022835792496969
    },
    {
      "question": "Quantas iniciativas estão planejadas para começar no próximo mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM initiative WHERE start_date >= CURRENT_DATE AND start_date <= CURRENT_DATE + INTERVAL '1 month'"
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM initiative WHERE start_date >= CURRENT_DATE AND start_date <= CURRENT_DATE + INTERVAL '1 month'",
      "executionTimeMs": 1458,
      "goldSql": "SELECT COUNT(id) FROM initiative WHERE start_date >= date_trunc('month', CURRENT_DATE) + INTERVAL '1 month' AND start_date < date_trunc('month', CURRENT_DATE) + INTERVAL '2 month';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9138016120866351,
      "finalSql": "SELECT COUNT(*) FROM initiative WHERE start_date >= CURRENT_DATE AND start_date <= CURRENT_DATE + INTERVAL '1 month'",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9569008060433175
    },
    {
      "question": "Quais iniciativas têm fim previsto antes do término de seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, i.end_date FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.deadline < i.end_date;"
        }
      ],
      "predictedSql": "SELECT i.title, i.end_date FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.deadline < i.end_date;",
      "executionTimeMs": 1669,
      "goldSql": "SELECT i.title, i.end_date, MAX(o.deadline) AS latest_okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date IS NOT NULL GROUP BY i.id, i.title, i.end_date HAVING i.end_date < MAX(o.deadline);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8935545058114421,
      "finalSql": "SELECT i.title, i.end_date FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.deadline < i.end_date;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.44677725290572107
    },
    {
      "question": "Quais iniciativas têm mais de três pessoas no time?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, COUNT(DISTINCT im.managers_id) AS num_managers FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id, i.title HAVING COUNT(DISTINCT im.managers_id) > 3;"
        }
      ],
      "predictedSql": "SELECT i.title, COUNT(DISTINCT im.managers_id) AS num_managers FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id, i.title HAVING COUNT(DISTINCT im.managers_id) > 3;",
      "executionTimeMs": 716,
      "goldSql": "SELECT i.id, i.title, COUNT(im.managers_id) AS team_size FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id HAVING COUNT(im.managers_id) > 3",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.913229481809343,
      "finalSql": "SELECT i.title, COUNT(DISTINCT im.managers_id) AS num_managers FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id, i.title HAVING COUNT(DISTINCT im.managers_id) > 3;",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9566147409046715
    },
    {
      "question": "Qual é a média de duração (em dias) das iniciativas concluídas?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (CURRENT_DATE - i.end_date)) AS avg_duração FROM initiative i WHERE i.end_date IS NOT NULL AND i.status = 'concluído';",
          "error": "syntax error at or near \"AS\""
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (CURRENT_DATE - i.end_date))) AS avg_duração FROM initiative i WHERE i.end_date IS NOT NULL AND i.priority = 3;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (CURRENT_DATE - i.end_date)) AS avg_duração FROM initiative i WHERE i.end_date IS NOT NULL AND i.status = 'concluído';",
      "executionTimeMs": 2093,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.7931909049438187,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (CURRENT_DATE - i.end_date))) AS avg_duração FROM initiative i WHERE i.end_date IS NOT NULL AND i.priority = 3;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.39659545247190936
    },
    {
      "question": "Qual percentual de iniciativas por categoria está concluído?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, COUNT(i.id) AS total_initiatives, COUNT(CASE WHEN kh.progress >= 1 THEN 1 ELSE NULL END) AS completed_initiatives, ROUND((COUNT(CASE WHEN kh.progress >= 1 THEN 1 ELSE NULL END) * 100.0 / COUNT(i.id))::numeric, 2) AS completion_percentage FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id JOIN kr_history kh ON im.managers_id = kh.collaborator_id GROUP BY i.category;"
        }
      ],
      "predictedSql": "SELECT i.category, COUNT(i.id) AS total_initiatives, COUNT(CASE WHEN kh.progress >= 1 THEN 1 ELSE NULL END) AS completed_initiatives, ROUND((COUNT(CASE WHEN kh.progress >= 1 THEN 1 ELSE NULL END) * 100.0 / COUNT(i.id))::numeric, 2) AS completion_percentage FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id JOIN kr_history kh ON im.managers_id = kh.collaborator_id GROUP BY i.category;",
      "executionTimeMs": 2937,
      "goldSql": "WITH InitiativeKRStatus AS (SELECT i.id AS initiative_id, i.category, CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END AS kr_is_concluded FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT category, CAST(SUM(kr_is_concluded) AS FLOAT) * 100 / COUNT(*) AS percent_krs_concluded FROM InitiativeKRStatus GROUP BY category ORDER BY percent_krs_concluded DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8310336766899711,
      "finalSql": "SELECT i.category, COUNT(i.id) AS total_initiatives, COUNT(CASE WHEN kh.progress >= 1 THEN 1 ELSE NULL END) AS completed_initiatives, ROUND((COUNT(CASE WHEN kh.progress >= 1 THEN 1 ELSE NULL END) * 100.0 / COUNT(i.id))::numeric, 2) AS completion_percentage FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id JOIN kr_history kh ON im.managers_id = kh.collaborator_id GROUP BY i.category;",
      "executionMatch": false,
      "tableSimilarity": 0.25,
      "queryAffinityScore": 0.5405168383449855
    },
    {
      "question": "Quais iniciativas estão com maior prioridade, mas apresentam baixo progresso ou atualizações atrasadas?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, i.priority, i.last_modified_date, i.end_date, i.start_date, i.category, i.owner_id, i.description FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = (SELECT MAX(priority) FROM initiative) AND (iu.last_modified_date IS NULL OR iu.last_modified_date < i.start_date OR (iu.last_modified_date > i.start_date AND iu.last_modified_date < i.end_date))"
        }
      ],
      "predictedSql": "SELECT i.title, i.priority, i.last_modified_date, i.end_date, i.start_date, i.category, i.owner_id, i.description FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = (SELECT MAX(priority) FROM initiative) AND (iu.last_modified_date IS NULL OR iu.last_modified_date < i.start_date OR (iu.last_modified_date > i.start_date AND iu.last_modified_date < i.end_date))",
      "executionTimeMs": 3549,
      "goldSql": "WITH InitiativePerformance AS (SELECT i.id AS initiative_id, i.title, i.priority, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS avg_okr_progress, (SELECT MAX(created_date) FROM initiative_update iu WHERE iu.initiative_id = i.id) AS last_update_date FROM initiative i) SELECT title, priority, avg_okr_progress, last_update_date FROM InitiativePerformance WHERE priority = 1 AND (avg_okr_progress < 0.5 OR last_update_date < NOW() - INTERVAL '30 days' OR last_update_date IS NULL) ORDER BY avg_okr_progress ASC NULLS FIRST, last_update_date ASC NULLS FIRST;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7525249277232257,
      "finalSql": "SELECT i.title, i.priority, i.last_modified_date, i.end_date, i.start_date, i.category, i.owner_id, i.description FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = (SELECT MAX(priority) FROM initiative) AND (iu.last_modified_date IS NULL OR iu.last_modified_date < i.start_date OR (iu.last_modified_date > i.start_date AND iu.last_modified_date < i.end_date))",
      "executionMatch": false,
      "tableSimilarity": 0.0023148148148148806,
      "queryAffinityScore": 0.37741987126902027
    },
    {
      "question": "Quais KRs estão com direção “NEGATIVA” (indicando desempenho decrescente) e estão abaixo de 50% do target?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.id, k.title, k.direction, k.target, kh.progress, kh.progress / NULLIF(kh.target,0) AS kr_progress FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE k.direction = 'down' AND kh.progress / NULLIF(kh.target,0) < 0.5;"
        }
      ],
      "predictedSql": "SELECT k.id, k.title, k.direction, k.target, kh.progress, kh.progress / NULLIF(kh.target,0) AS kr_progress FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE k.direction = 'down' AND kh.progress / NULLIF(kh.target,0) < 0.5;",
      "executionTimeMs": 4080,
      "goldSql": "SELECT title, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / NULLIF(target,0)) < 0.5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.843805982187632,
      "finalSql": "SELECT k.id, k.title, k.direction, k.target, kh.progress, kh.progress / NULLIF(kh.target,0) AS kr_progress FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE k.direction = 'down' AND kh.progress / NULLIF(kh.target,0) < 0.5;",
      "executionMatch": false,
      "tableSimilarity": 0.024584237165582112,
      "queryAffinityScore": 0.43419510967660707
    },
    {
      "question": "Quais iniciativas apresentaram maior variação positiva de progresso nos últimos ciclos de atualização?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, i.category, SUM(CASE WHEN kh.progress > kh.prev_progress THEN kh.progress - kh.prev_progress ELSE 0 END) AS total_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY i.title, i.category ORDER BY total_progress DESC LIMIT 10;",
          "error": "column kh.initiative_update_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title, i.category, SUM(CASE WHEN kh.progress > kh.prev_progress THEN kh.progress - kh.prev_progress ELSE 0 END) AS total_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY i.title, i.category ORDER BY total_progress DESC LIMIT 10;",
          "fixed": true,
          "error": "column kh.initiative_update_id does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.title, i.category, SUM(CASE WHEN kh.progress > kh.prev_progress THEN kh.progress - kh.prev_progress ELSE 0 END) AS total_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY i.title, i.category ORDER BY total_progress DESC LIMIT 10;",
          "fixed": true,
          "error": "column kh.initiative_update_id does not exist"
        }
      ],
      "predictedSql": "SELECT i.title, i.category, SUM(CASE WHEN kh.progress > kh.prev_progress THEN kh.progress - kh.prev_progress ELSE 0 END) AS total_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY i.title, i.category ORDER BY total_progress DESC LIMIT 10;",
      "executionTimeMs": 1911,
      "goldSql": "WITH NormHist AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh), Changes AS (SELECT nh.kr_id, nh.date, nh.norm_prog, nh.norm_prog - LAG(nh.norm_prog) OVER (PARTITION BY nh.kr_id ORDER BY nh.date) AS delta FROM NormHist nh), PosChanges AS (SELECT o.initiative_id, CASE WHEN k.direction = 'up'   AND delta > 0 THEN delta WHEN k.direction = 'down' AND delta < 0 THEN -delta END AS norm_delta FROM Changes c JOIN kr k ON c.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE delta IS NOT NULL AND c.date >= NOW() - INTERVAL '6 month' AND ((k.direction='up' AND delta > 0) OR (k.direction='down' AND delta < 0))) SELECT i.title, AVG(pc.norm_delta) AS avg_positive_change FROM initiative i JOIN PosChanges pc ON i.id = pc.initiative_id GROUP BY i.id, i.title ORDER BY avg_positive_change DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.6305044595457456,
      "finalSql": "SELECT i.title, i.category, SUM(CASE WHEN kh.progress > kh.prev_progress THEN kh.progress - kh.prev_progress ELSE 0 END) AS total_progress FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY i.title, i.category ORDER BY total_progress DESC LIMIT 10;",
      "error": "Erro de execução no banco após 3 tentativa(s): column kh.initiative_update_id does not exist",
      "executionMatch": false
    },
    {
      "question": "Quais colaboradores foram responsáveis pelos KRs com melhor taxa de atingimento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, RANK() OVER (ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE k.direction = 'up' GROUP BY c.id, c.name ORDER BY rank;"
        }
      ],
      "predictedSql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, RANK() OVER (ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE k.direction = 'up' GROUP BY c.id, c.name ORDER BY rank;",
      "executionTimeMs": 1148,
      "goldSql": "SELECT c.name, AVG(k.progress / k.target) AS avg_achievement_rate FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name HAVING COUNT(DISTINCT k.id) > 1 ORDER BY avg_achievement_rate DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8303553512794266,
      "finalSql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, RANK() OVER (ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE k.direction = 'up' GROUP BY c.id, c.name ORDER BY rank;",
      "executionMatch": false,
      "tableSimilarity": 0.33333333333333337,
      "queryAffinityScore": 0.5818443423063799
    },
    {
      "question": "Quais colaboradores têm progresso médio de KRs acima da média geral dos colaboradores?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id);"
        }
      ],
      "predictedSql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id);",
      "executionTimeMs": 1875,
      "goldSql": "WITH CollaboratorAvg AS (SELECT kh.collaborator_id, AVG(kh.progress / NULLIF(kh.target,0)) AS collaborator_progress FROM kr_history kh GROUP BY kh.collaborator_id), GlobalAvg AS (SELECT AVG(progress / NULLIF(target,0)) AS global_progress FROM kr_history) SELECT c.name, ca.collaborator_progress FROM collaborator c JOIN CollaboratorAvg ca ON c.id = ca.collaborator_id CROSS JOIN GlobalAvg ga WHERE ca.collaborator_progress > ga.global_progress ORDER BY ca.collaborator_progress DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8982275105974294,
      "finalSql": "SELECT c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id);",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9491137552987148
    },
    {
      "question": "Quais colaboradores possuem mais KRs “bookmarked” do que a média geral de bookmarks por colaborador?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING COUNT(kh.bookmarked) > (SELECT AVG(total_bookmarks) FROM (SELECT c.id, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id) AS subquery);",
          "error": "column kh.bookmarked does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT c.name, COUNT(kh.bookmarked_by_id) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING COUNT(kh.bookmarked_by_id) > (SELECT AVG(total_bookmarks) FROM (SELECT c.id, COUNT(kh.bookmarked_by_id) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id) AS subquery);",
          "fixed": true,
          "error": "column kh.bookmarked_by_id does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT c.name, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING COUNT(kh.bookmarked) > (SELECT AVG(total_bookmarks) FROM (SELECT c.id, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id) AS subquery);",
          "fixed": true,
          "error": "column kh.bookmarked does not exist"
        }
      ],
      "predictedSql": "SELECT c.name, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING COUNT(kh.bookmarked) > (SELECT AVG(total_bookmarks) FROM (SELECT c.id, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id) AS subquery);",
      "executionTimeMs": 2423,
      "goldSql": "WITH BookmarkCount AS ( SELECT bookmarked_by_id, COUNT(id) AS total_bookmarks FROM kr WHERE bookmarked_by_id IS NOT NULL GROUP BY bookmarked_by_id ), AvgBookmarks AS ( SELECT AVG(total_bookmarks) AS global_avg FROM BookmarkCount ) SELECT c.name, bc.total_bookmarks FROM collaborator c JOIN BookmarkCount bc ON c.id = bc.bookmarked_by_id CROSS JOIN AvgBookmarks ab WHERE bc.total_bookmarks > ab.global_avg ORDER BY bc.total_bookmarks DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.89176613579486,
      "finalSql": "SELECT c.name, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name HAVING COUNT(kh.bookmarked) > (SELECT AVG(total_bookmarks) FROM (SELECT c.id, COUNT(kh.bookmarked) AS total_bookmarks FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id) AS subquery);",
      "error": "Erro de execução no banco após 3 tentativa(s): column kh.bookmarked does not exist",
      "executionMatch": false
    },
    {
      "question": "Gerar o ranking de colaboradores com maior média de progresso em KRs dentro de cada categoria de iniciativa.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;"
        }
      ],
      "predictedSql": "SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;",
      "executionTimeMs": 4184,
      "goldSql": "SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;",
      "exactMatch": true,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 1
      },
      "cosineSimilarity": 1,
      "finalSql": "SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 1
    },
    {
      "question": "Selecionar colaboradores que contribuíram para KRs com progresso superior ao percentil 90 global.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, c.email, kh.progress, kh.target, k.direction FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE (kh.progress / NULLIF(kh.target,0)) > (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (kh2.progress / NULLIF(kh2.target,0))) FROM kr_history kh2);"
        }
      ],
      "predictedSql": "SELECT c.name, c.email, kh.progress, kh.target, k.direction FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE (kh.progress / NULLIF(kh.target,0)) > (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (kh2.progress / NULLIF(kh2.target,0))) FROM kr_history kh2);",
      "executionTimeMs": 1269,
      "goldSql": "WITH GlobalPercentile AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (progress / NULLIF(target,0))) AS p90_progress FROM kr_history) SELECT DISTINCT c.name FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id CROSS JOIN GlobalPercentile gp WHERE (kh.progress / NULLIF(kh.target,0)) > gp.p90_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8744819582130574,
      "finalSql": "SELECT c.name, c.email, kh.progress, kh.target, k.direction FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE (kh.progress / NULLIF(kh.target,0)) > (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (kh2.progress / NULLIF(kh2.target,0))) FROM kr_history kh2);",
      "executionMatch": false,
      "tableSimilarity": 0.023834196891191817,
      "queryAffinityScore": 0.4491580775521246
    },
    {
      "question": "Como evoluiu o progresso médio dos KRs nos últimos 6 meses?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '6 months' GROUP BY EXTRACT(YEAR FROM kh.date), EXTRACT(MONTH FROM kh.date) ORDER BY kh.date;",
          "error": "column \"kh.date\" must appear in the GROUP BY clause or be used in an aggregate function"
        },
        {
          "attempt": 2,
          "sql": "SELECT EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '6 months' GROUP BY EXTRACT(YEAR FROM kh.date), EXTRACT(MONTH FROM kh.date) ORDER BY kh.date ASC;",
          "fixed": true,
          "error": "column \"kh.date\" must appear in the GROUP BY clause or be used in an aggregate function"
        },
        {
          "attempt": 3,
          "sql": "SELECT EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '6 months' GROUP BY EXTRACT(YEAR FROM kh.date), EXTRACT(MONTH FROM kh.date) ORDER BY EXTRACT(YEAR FROM kh.date), EXTRACT(MONTH FROM kh.date) ASC;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '6 months' GROUP BY EXTRACT(YEAR FROM kh.date), EXTRACT(MONTH FROM kh.date) ORDER BY kh.date;",
      "executionTimeMs": 1085,
      "goldSql": "SELECT DATE_TRUNC('month', date) AS month_start, AVG(progress / NULLIF(target,0)) AS avg_monthly_progress FROM kr_history WHERE date >= DATE_TRUNC('month', NOW() - INTERVAL '6 month') AND date <= NOW() GROUP BY month_start ORDER BY month_start;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.9145405059783248,
      "finalSql": "SELECT EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '6 months' GROUP BY EXTRACT(YEAR FROM kh.date), EXTRACT(MONTH FROM kh.date) ORDER BY EXTRACT(YEAR FROM kh.date), EXTRACT(MONTH FROM kh.date) ASC;",
      "executionMatch": false,
      "tableSimilarity": 0.25,
      "queryAffinityScore": 0.5822702529891624
    },
    {
      "question": "Qual foi a variação de progresso por colaborador no último trimestre?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, k.direction, (AVG(kh.progress / NULLIF(kh.target,0)) - (SELECT AVG(progress / NULLIF(target,0)) FROM kr_history WHERE EXTRACT(QUARTER FROM created_date) = 4 AND EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM NOW()))) AS progress_variation FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE EXTRACT(QUARTER FROM kh.created_date) = 4 AND EXTRACT(YEAR FROM kh.created_date) = EXTRACT(YEAR FROM NOW()) GROUP BY c.name, k.direction ORDER BY progress_variation DESC;",
          "error": "column reference \"created_date\" is ambiguous"
        },
        {
          "attempt": 2,
          "sql": "SELECT c.name, k.direction, (AVG(kh.progress / NULLIF(kh.target,0)) - (SELECT AVG(progress / NULLIF(target,0)) FROM kr_history WHERE EXTRACT(QUARTER FROM kh.created_date) = 4 AND EXTRACT(YEAR FROM kh.created_date) = EXTRACT(YEAR FROM NOW()))) AS progress_variation FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE EXTRACT(QUARTER FROM kh.created_date) = 4 AND EXTRACT(YEAR FROM kh.created_date) = EXTRACT(YEAR FROM NOW()) GROUP BY c.name, k.direction ORDER BY progress_variation DESC;",
          "fixed": true,
          "error": "column kh.created_date does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT c.name, k.direction, (AVG(kh.progress / NULLIF(kh.target,0)) - (SELECT AVG(progress / NULLIF(target,0)) FROM kr_history WHERE EXTRACT(QUARTER FROM kh.date) = 4 AND EXTRACT(YEAR FROM kh.date) = EXTRACT(YEAR FROM NOW()))) AS progress_variation FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE EXTRACT(QUARTER FROM kh.date) = 4 AND EXTRACT(YEAR FROM kh.date) = EXTRACT(YEAR FROM NOW()) GROUP BY c.name, k.direction ORDER BY progress_variation DESC;",
          "fixed": true,
          "error": "subquery uses ungrouped column \"kh.date\" from outer query"
        }
      ],
      "predictedSql": "SELECT c.name, k.direction, (AVG(kh.progress / NULLIF(kh.target,0)) - (SELECT AVG(progress / NULLIF(target,0)) FROM kr_history WHERE EXTRACT(QUARTER FROM created_date) = 4 AND EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM NOW()))) AS progress_variation FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE EXTRACT(QUARTER FROM kh.created_date) = 4 AND EXTRACT(YEAR FROM kh.created_date) = EXTRACT(YEAR FROM NOW()) GROUP BY c.name, k.direction ORDER BY progress_variation DESC;",
      "executionTimeMs": 3110,
      "goldSql": "WITH Hist AS (SELECT kh.collaborator_id, kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '3 month'), Ranked AS (SELECT collaborator_id, kr_id, norm_prog, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date ASC) AS rn_first, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date DESC) AS rn_last FROM Hist), FirstLast AS (SELECT collaborator_id, kr_id, MAX(CASE WHEN rn_first = 1 THEN norm_prog END) AS first_prog, MAX(CASE WHEN rn_last = 1 THEN norm_prog END) AS last_prog FROM Ranked GROUP BY collaborator_id, kr_id) SELECT c.name, AVG(last_prog - first_prog) AS progress_change_qtr FROM collaborator c JOIN FirstLast fl ON c.id = fl.collaborator_id GROUP BY c.id, c.name ORDER BY progress_change_qtr DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.7507648151317178,
      "finalSql": "SELECT c.name, k.direction, (AVG(kh.progress / NULLIF(kh.target,0)) - (SELECT AVG(progress / NULLIF(target,0)) FROM kr_history WHERE EXTRACT(QUARTER FROM kh.date) = 4 AND EXTRACT(YEAR FROM kh.date) = EXTRACT(YEAR FROM NOW()))) AS progress_variation FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE EXTRACT(QUARTER FROM kh.date) = 4 AND EXTRACT(YEAR FROM kh.date) = EXTRACT(YEAR FROM NOW()) GROUP BY c.name, k.direction ORDER BY progress_variation DESC;",
      "error": "Erro de execução no banco após 3 tentativa(s): subquery uses ungrouped column \"kh.date\" from outer query",
      "executionMatch": false
    },
    {
      "question": "Quantos registros de histórico de KR foram criados no último mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM kr_history WHERE created_date >= NOW() - INTERVAL '1 month'",
          "error": "column \"created_date\" does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month'",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM kr_history WHERE created_date >= NOW() - INTERVAL '1 month'",
      "executionTimeMs": 1320,
      "goldSql": "SELECT COUNT(id) AS history_count_last_month FROM kr_history WHERE date >= NOW() - INTERVAL '1' MONTH;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.8861887102328603,
      "finalSql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month'",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9430943551164301
    },
    {
      "question": "Quais KRs apresentaram regressão de progresso em algum momento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.progress < (SELECT AVG(progress) FROM kr_history WHERE kr_id = k.id AND direction = 'down')"
        }
      ],
      "predictedSql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.progress < (SELECT AVG(progress) FROM kr_history WHERE kr_id = k.id AND direction = 'down')",
      "executionTimeMs": 2124,
      "goldSql": "WITH Regressions AS (SELECT kr_id, (progress / NULLIF(target,0)) AS norm_progress, LAG(progress / NULLIF(target,0)) OVER (PARTITION BY kr_id ORDER BY date) AS prev_norm_progress FROM kr_history) SELECT DISTINCT k.title FROM kr k JOIN Regressions r ON k.id = r.kr_id WHERE r.norm_progress < r.prev_norm_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.6167955713174312,
      "finalSql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.progress < (SELECT AVG(progress) FROM kr_history WHERE kr_id = k.id AND direction = 'down')",
      "executionMatch": false,
      "tableSimilarity": 0.004942848316342396,
      "queryAffinityScore": 0.3108692098168868
    },
    {
      "question": "Qual a média de variação percentual de progresso por métrica (PERC, NUMERIC, YES_NO)?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.metric, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM kr JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY k.metric ORDER BY k.metric;",
          "error": "missing FROM-clause entry for table \"k\""
        },
        {
          "attempt": 2,
          "sql": "SELECT k.metric, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM kr JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY k.metric ORDER BY k.metric;",
          "fixed": true,
          "error": "missing FROM-clause entry for table \"k\""
        },
        {
          "attempt": 3,
          "sql": "SELECT k.metric, AVG(kh.progress / NULLIF(kh.target, 0)) AS avg_progress FROM kr JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY k.metric ORDER BY k.metric;",
          "fixed": true,
          "error": "missing FROM-clause entry for table \"k\""
        }
      ],
      "predictedSql": "SELECT k.metric, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM kr JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY k.metric ORDER BY k.metric;",
      "executionTimeMs": 5997,
      "goldSql": "WITH ranked_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog, k.metric, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_norm_prog FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), progress_changes AS (SELECT metric, ABS(norm_prog - prev_norm_prog) / NULLIF(prev_norm_prog, 0) * 100 AS variation_percent FROM ranked_history WHERE prev_norm_prog IS NOT NULL) SELECT metric, AVG(variation_percent) AS avg_variation_percent FROM progress_changes GROUP BY metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8063894285783516,
      "finalSql": "SELECT k.metric, AVG(kh.progress / NULLIF(kh.target, 0)) AS avg_progress FROM kr JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY k.metric ORDER BY k.metric;",
      "error": "Erro de execução no banco após 3 tentativa(s): missing FROM-clause entry for table \"k\"",
      "executionMatch": false
    },
    {
      "question": "Quantos KRs tiveram histórico de progresso acima de 90% antes do prazo final?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target,0) > 0.9 AND kh.date < (SELECT deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.id = k.okr_id);"
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target,0) > 0.9 AND kh.date < (SELECT deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.id = k.okr_id);",
      "executionTimeMs": 2284,
      "goldSql": "SELECT COUNT(DISTINCT kh.kr_id) as krs_acima_90 FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE (kh.progress/k.target)*100 >= 90 AND kh.date < o.deadline;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8366481190014102,
      "finalSql": "SELECT COUNT(*) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target,0) > 0.9 AND kh.date < (SELECT deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.id = k.okr_id);",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4183240595007051
    },
    {
      "question": "Quais colaboradores atualizaram o maior número de KRs no histórico?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, COUNT(*) AS num_krs_updated FROM collaborator c JOIN initiative_update iu ON c.id = iu.collaborator_id JOIN initiative i ON iu.initiative_id = i.id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY c.id, c.name ORDER BY COUNT(*) DESC LIMIT 1;",
          "error": "column iu.collaborator_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT c.name, COUNT(*) AS num_krs_updated FROM collaborator c JOIN initiative_update iu ON c.id = iu.created_by JOIN initiative i ON iu.initiative_id = i.id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY c.id, c.name ORDER BY COUNT(*) DESC LIMIT 1;",
          "fixed": true,
          "error": "operator does not exist: bigint = character varying"
        },
        {
          "attempt": 3,
          "sql": "SELECT c.name, COUNT(*) AS num_krs_updated FROM collaborator c JOIN initiative_update iu ON c.id = iu.created_by JOIN initiative i ON iu.initiative_id = i.id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY c.id, c.name ORDER BY COUNT(*) DESC LIMIT 1;",
          "fixed": true,
          "error": "operator does not exist: bigint = character varying"
        }
      ],
      "predictedSql": "SELECT c.name, COUNT(*) AS num_krs_updated FROM collaborator c JOIN initiative_update iu ON c.id = iu.collaborator_id JOIN initiative i ON iu.initiative_id = i.id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY c.id, c.name ORDER BY COUNT(*) DESC LIMIT 1;",
      "executionTimeMs": 2454,
      "goldSql": "SELECT c.id, c.name, COUNT(kh.id) as total_atualizacoes FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name ORDER BY total_atualizacoes DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8284176057089101,
      "finalSql": "SELECT c.name, COUNT(*) AS num_krs_updated FROM collaborator c JOIN initiative_update iu ON c.id = iu.created_by JOIN initiative i ON iu.initiative_id = i.id JOIN kr_history kh ON iu.id = kh.initiative_update_id GROUP BY c.id, c.name ORDER BY COUNT(*) DESC LIMIT 1;",
      "error": "Erro de execução no banco após 3 tentativa(s): operator does not exist: bigint = character varying",
      "executionMatch": false
    },
    {
      "question": "Quantos updates de iniciativa foram registrados por mês neste ano?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, COUNT(*) AS updates FROM initiative_update iu WHERE EXTRACT(YEAR FROM iu.created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY year, month ORDER BY year, month;"
        }
      ],
      "predictedSql": "SELECT EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, COUNT(*) AS updates FROM initiative_update iu WHERE EXTRACT(YEAR FROM iu.created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY year, month ORDER BY year, month;",
      "executionTimeMs": 661,
      "goldSql": "SELECT EXTRACT(YEAR FROM created_date) as ano, EXTRACT(MONTH FROM created_date) as mes, COUNT(*) as total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY ano, mes ORDER BY ano, mes;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9163415327627961,
      "finalSql": "SELECT EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month, COUNT(*) AS updates FROM initiative_update iu WHERE EXTRACT(YEAR FROM iu.created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY year, month ORDER BY year, month;",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9581707663813981
    },
    {
      "question": "Quais iniciativas tiveram maior número de updates em um único mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, COUNT(iu.id) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.title, EXTRACT(YEAR FROM iu.created_date), EXTRACT(MONTH FROM iu.created_date) ORDER BY num_updates DESC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT i.title, COUNT(iu.id) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.title, EXTRACT(YEAR FROM iu.created_date), EXTRACT(MONTH FROM iu.created_date) ORDER BY num_updates DESC LIMIT 1;",
      "executionTimeMs": 2301,
      "goldSql": "SELECT i.id, i.title, EXTRACT(YEAR FROM iu.created_date) as ano, EXTRACT(MONTH FROM iu.created_date) as mes, COUNT(iu.id) as updates_mes FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title, ano, mes ORDER BY updates_mes DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.9651510686184829,
      "finalSql": "SELECT i.title, COUNT(iu.id) AS num_updates, EXTRACT(YEAR FROM iu.created_date) AS year, EXTRACT(MONTH FROM iu.created_date) AS month FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.title, EXTRACT(YEAR FROM iu.created_date), EXTRACT(MONTH FROM iu.created_date) ORDER BY num_updates DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.040000000000000036,
      "queryAffinityScore": 0.5025755343092415
    },
    {
      "question": "Qual o tempo médio entre updates consecutivos de uma mesma iniciativa?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(DATEDIFF(updated_at, previous_updated_at)) AS avg_time_between_updates FROM (SELECT initiative_id, updated_at, LAG(updated_at) OVER (PARTITION BY initiative_id ORDER BY updated_at) AS previous_updated_at FROM initiative_update) AS subquery;",
          "error": "column \"updated_at\" does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(DATEDIFF(updated_at, LAG(updated_at) OVER (PARTITION BY initiative_id ORDER BY updated_at))) AS avg_time_between_updates FROM initiative_update;",
          "fixed": true,
          "error": "column \"updated_at\" does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT AVG(DATEDIFF(last_modified_date, LAG(last_modified_date) OVER (PARTITION BY initiative_id ORDER BY last_modified_date))) AS avg_time_between_updates FROM initiative_update;",
          "fixed": true,
          "error": "function datediff(timestamp with time zone, timestamp with time zone) does not exist"
        }
      ],
      "predictedSql": "SELECT AVG(DATEDIFF(updated_at, previous_updated_at)) AS avg_time_between_updates FROM (SELECT initiative_id, updated_at, LAG(updated_at) OVER (PARTITION BY initiative_id ORDER BY updated_at) AS previous_updated_at FROM initiative_update) AS subquery;",
      "executionTimeMs": 2564,
      "goldSql": "WITH update_gaps AS (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) / 86400 as dias_entre_updates FROM initiative_update) SELECT AVG(dias_entre_updates) as tempo_medio_dias FROM update_gaps WHERE dias_entre_updates IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8138461608960296,
      "finalSql": "SELECT AVG(DATEDIFF(last_modified_date, LAG(last_modified_date) OVER (PARTITION BY initiative_id ORDER BY last_modified_date))) AS avg_time_between_updates FROM initiative_update;",
      "error": "Erro de execução no banco após 3 tentativa(s): function datediff(timestamp with time zone, timestamp with time zone) does not exist",
      "executionMatch": false
    },
    {
      "question": "Para cada iniciativa, qual é o KR mais recente e seu progresso atual?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, k.progress, k.target, k.direction, k.date FROM kr k JOIN initiative i ON k.okr_id = i.id JOIN (SELECT MAX(created_date) AS max_date, okr_id FROM kr GROUP BY okr_id) m ON k.okr_id = m.okr_id AND k.created_date = m.max_date;",
          "error": "column k.date does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title, k.progress, k.target, k.direction, k.created_date AS date FROM kr k JOIN initiative i ON k.okr_id = i.id JOIN (SELECT MAX(created_date) AS max_date, okr_id FROM kr GROUP BY okr_id) m ON k.okr_id = m.okr_id AND k.created_date = m.max_date;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.title, k.progress, k.target, k.direction, k.date FROM kr k JOIN initiative i ON k.okr_id = i.id JOIN (SELECT MAX(created_date) AS max_date, okr_id FROM kr GROUP BY okr_id) m ON k.okr_id = m.okr_id AND k.created_date = m.max_date;",
      "executionTimeMs": 2420,
      "goldSql": "WITH ranked_krs AS (SELECT i.id as iniciativa_id, i.title as iniciativa, k.id as kr_id, k.title as kr, k.progress, k.last_modified_date, ROW_NUMBER() OVER (PARTITION BY i.id ORDER BY k.last_modified_date DESC) as rn FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT iniciativa_id, iniciativa, kr_id, kr, progress FROM ranked_krs WHERE rn = 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.7917298636155641,
      "finalSql": "SELECT i.title, k.progress, k.target, k.direction, k.created_date AS date FROM kr k JOIN initiative i ON k.okr_id = i.id JOIN (SELECT MAX(created_date) AS max_date, okr_id FROM kr GROUP BY okr_id) m ON k.okr_id = m.okr_id AND k.created_date = m.max_date;",
      "executionMatch": false,
      "tableSimilarity": 0.2666666666666667,
      "queryAffinityScore": 0.5291982651411153
    },
    {
      "question": "Analisar a tendência de redução na frequência de updates conforme o deadline dos OKRs se aproxima.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH okr_updates AS (SELECT o.deadline, COUNT(iu.id) AS num_updates FROM initiative_update iu JOIN okr o ON iu.okr_id = o.id GROUP BY o.deadline) SELECT deadline, num_updates, LAG(num_updates) OVER (ORDER BY deadline) AS prev_num_updates, num_updates - LAG(num_updates) OVER (ORDER BY deadline) AS diff FROM okr_updates ORDER BY deadline",
          "error": "column iu.okr_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "WITH okr_updates AS (SELECT o.deadline, COUNT(iu.initiative_id) AS num_updates FROM initiative_update iu JOIN okr o ON iu.initiative_id = o.id GROUP BY o.deadline) SELECT deadline, num_updates, LAG(num_updates) OVER (ORDER BY deadline) AS prev_num_updates, num_updates - LAG(num_updates) OVER (ORDER BY deadline) AS diff FROM okr_updates ORDER BY deadline",
          "fixed": true
        }
      ],
      "predictedSql": "WITH okr_updates AS (SELECT o.deadline, COUNT(iu.id) AS num_updates FROM initiative_update iu JOIN okr o ON iu.okr_id = o.id GROUP BY o.deadline) SELECT deadline, num_updates, LAG(num_updates) OVER (ORDER BY deadline) AS prev_num_updates, num_updates - LAG(num_updates) OVER (ORDER BY deadline) AS diff FROM okr_updates ORDER BY deadline",
      "executionTimeMs": 1241,
      "goldSql": "SELECT i.id, i.title, o.deadline, COUNT(iu.id) as total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / 86400) as dias_antes_prazo_medio FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.created_date <= o.deadline GROUP BY i.id, i.title, o.deadline ORDER BY dias_antes_prazo_medio;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.770943636749198,
      "finalSql": "WITH okr_updates AS (SELECT o.deadline, COUNT(iu.initiative_id) AS num_updates FROM initiative_update iu JOIN okr o ON iu.initiative_id = o.id GROUP BY o.deadline) SELECT deadline, num_updates, LAG(num_updates) OVER (ORDER BY deadline) AS prev_num_updates, num_updates - LAG(num_updates) OVER (ORDER BY deadline) AS diff FROM okr_updates ORDER BY deadline",
      "executionMatch": false,
      "tableSimilarity": 0.06825396825396834,
      "queryAffinityScore": 0.41959880250158316
    },
    {
      "question": "Listar KRs com lacunas maiores que 30 dias entre atualizações de progresso",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date > kh.last_modified_date + INTERVAL '30 day' GROUP BY k.id HAVING COUNT(kh.date) > 1;",
          "error": "column kh.last_modified_date does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date > kh.created_date + INTERVAL '30 day' GROUP BY k.id HAVING COUNT(kh.date) > 1;",
          "fixed": true,
          "error": "column kh.created_date does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date > kh.created_at + INTERVAL '30 day' GROUP BY k.id HAVING COUNT(kh.date) > 1;",
          "fixed": true,
          "error": "column kh.created_at does not exist"
        }
      ],
      "predictedSql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date > kh.last_modified_date + INTERVAL '30 day' GROUP BY k.id HAVING COUNT(kh.date) > 1;",
      "executionTimeMs": 2283,
      "goldSql": "WITH kr_update_gaps AS (SELECT kh.kr_id, k.title as kr_title, kh.date as current_date, LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) as previous_date, EXTRACT(EPOCH FROM (kh.date - LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date))) / 86400 as dias_entre_atualizacoes FROM kr_history kh JOIN kr k ON kh.kr_id = k.id) SELECT kr_id, kr_title, previous_date, current_date, dias_entre_atualizacoes FROM kr_update_gaps WHERE dias_entre_atualizacoes > 30 ORDER BY dias_entre_atualizacoes DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.6156790130767547,
      "finalSql": "SELECT k.* FROM kr k JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date > kh.created_at + INTERVAL '30 day' GROUP BY k.id HAVING COUNT(kh.date) > 1;",
      "error": "Erro de execução no banco após 3 tentativa(s): column kh.created_at does not exist",
      "executionMatch": false
    },
    {
      "question": "Quais OKRs estão com prazo próximo do vencimento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, i.end_date FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.deadline < NOW() + INTERVAL '1 month' AND iu.deadline > NOW() - INTERVAL '1 month' ORDER BY iu.deadline;",
          "error": "column iu.deadline does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title, i.end_date FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.deadline > NOW() - INTERVAL '1 month' AND o.deadline < NOW() + INTERVAL '1 month' ORDER BY o.deadline;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.title, i.end_date FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.deadline < NOW() + INTERVAL '1 month' AND iu.deadline > NOW() - INTERVAL '1 month' ORDER BY iu.deadline;",
      "executionTimeMs": 1744,
      "goldSql": "SELECT id, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' ORDER BY deadline ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.5612858070503154,
      "finalSql": "SELECT i.title, i.end_date FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE o.deadline > NOW() - INTERVAL '1 month' AND o.deadline < NOW() + INTERVAL '1 month' ORDER BY o.deadline;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.2806429035251577
    },
    {
      "question": "Qual é a média de progresso dos KRs em cada OKR?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id, o.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN kr_history kh ON o.id = kh.okr_id GROUP BY o.id, o.title ORDER BY o.id;",
          "error": "column kh.okr_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT o.id, o.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN kr ON o.id = kr.okr_id JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY o.id, o.title ORDER BY o.id;",
          "fixed": true,
          "error": "column o.title does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT o.id, o.description, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN kr ON o.id = kr.okr_id JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY o.id, o.description ORDER BY o.id;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT o.id, o.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN kr_history kh ON o.id = kh.okr_id GROUP BY o.id, o.title ORDER BY o.id;",
      "executionTimeMs": 1721,
      "goldSql": "SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8326350374944663,
      "finalSql": "SELECT o.id, o.description, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN kr ON o.id = kr.okr_id JOIN kr_history kh ON kr.id = kh.kr_id GROUP BY o.id, o.description ORDER BY o.id;",
      "executionMatch": false,
      "tableSimilarity": 0.34079601990049746,
      "queryAffinityScore": 0.5867155286974819
    },
    {
      "question": "Quais OKRs têm menor progresso médio?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id, o.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN initiative_update iu ON o.id = iu.initiative_id JOIN initiative i ON iu.initiative_id = i.id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY o.id, o.title ORDER BY avg_progress ASC LIMIT 10;",
          "error": "column o.title does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT o.id, o.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN initiative_update iu ON o.id = iu.initiative_id JOIN initiative i ON iu.initiative_id = i.id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY o.id ORDER BY avg_progress ASC LIMIT 10;",
          "fixed": true,
          "error": "column o.title does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT o.id, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY o.id ORDER BY avg_progress ASC LIMIT 10;",
          "fixed": true,
          "error": "column \"i.title\" must appear in the GROUP BY clause or be used in an aggregate function"
        }
      ],
      "predictedSql": "SELECT o.id, o.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN initiative_update iu ON o.id = iu.initiative_id JOIN initiative i ON iu.initiative_id = i.id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY o.id, o.title ORDER BY avg_progress ASC LIMIT 10;",
      "executionTimeMs": 2435,
      "goldSql": "SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id ORDER BY avg_progress ASC LIMIT 5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8185021634689198,
      "finalSql": "SELECT o.id, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON iu.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY o.id ORDER BY avg_progress ASC LIMIT 10;",
      "error": "Erro de execução no banco após 3 tentativa(s): column \"i.title\" must appear in the GROUP BY clause or be used in an aggregate function",
      "executionMatch": false
    },
    {
      "question": "Qual é o percentual de KRs concluídos por iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, COUNT(CASE WHEN kh.progress >= 1.0 THEN 1 ELSE NULL END) * 100.0 / COUNT(kh.id) AS percentagem_concluidos FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.title;"
        }
      ],
      "predictedSql": "SELECT i.title, COUNT(CASE WHEN kh.progress >= 1.0 THEN 1 ELSE NULL END) * 100.0 / COUNT(kh.id) AS percentagem_concluidos FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.title;",
      "executionTimeMs": 2854,
      "goldSql": "SELECT i.id AS initiative_id, SUM(CASE WHEN (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8845379650674021,
      "finalSql": "SELECT i.title, COUNT(CASE WHEN kh.progress >= 1.0 THEN 1 ELSE NULL END) * 100.0 / COUNT(kh.id) AS percentagem_concluidos FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.title;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.44226898253370106
    },
    {
      "question": "Qual o tempo médio restante até o deadline dos OKRs ativos?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - CURRENT_TIMESTAMP))) AS avg_time_remaining FROM okr WHERE active = TRUE;",
          "error": "column \"active\" does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - CURRENT_TIMESTAMP))) AS avg_time_remaining FROM okr WHERE id IN (SELECT id FROM okr WHERE active = TRUE);",
          "fixed": true,
          "error": "column \"active\" does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - CURRENT_TIMESTAMP)) AS avg_time_remaining FROM okr WHERE id IN (SELECT id FROM okr WHERE active IS TRUE);",
          "fixed": true,
          "error": "syntax error at or near \"AS\""
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - CURRENT_TIMESTAMP))) AS avg_time_remaining FROM okr WHERE active = TRUE;",
      "executionTimeMs": 2092,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - NOW())) / 86400) AS avg_days_remaining FROM okr WHERE deadline > NOW();",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9131722670704455,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - CURRENT_TIMESTAMP)) AS avg_time_remaining FROM okr WHERE id IN (SELECT id FROM okr WHERE active IS TRUE);",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"AS\"",
      "executionMatch": false
    },
    {
      "question": "Quais OKRs estão vinculados a iniciativas que já encerraram?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id, o.title, i.id AS initiative_id, i.title AS initiative_title, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL;",
          "error": "column o.title does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT o.id, o.description AS okr_title, i.id AS initiative_id, i.title AS initiative_title, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT o.id, o.title, i.id AS initiative_id, i.title AS initiative_title, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL;",
      "executionTimeMs": 1986,
      "goldSql": "SELECT o.id AS okr_id, o.initiative_id, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL AND i.end_date < NOW();",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9214009570700156,
      "finalSql": "SELECT o.id, o.description AS okr_title, i.id AS initiative_id, i.title AS initiative_title, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL;",
      "executionMatch": false,
      "tableSimilarity": 0.30447761194029854,
      "queryAffinityScore": 0.6129392845051571
    },
    {
      "question": "Quantos KRs estão atrasados em relação à meta planejada?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM kr WHERE (SELECT EXTRACT(EPOCH FROM (NOW() AT TIME ZONE 'UTC' - kr.deadline) / INTERVAL '1 day') * 86400) > 0 AND kr.direction = 'down';",
          "error": "column kr.deadline does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT COUNT(*) FROM kr WHERE (SELECT EXTRACT(EPOCH FROM (NOW() AT TIME ZONE 'UTC' - kr.deadline) / INTERVAL '1 day') * 86400) > 0 AND kr.direction = 'down'",
          "fixed": true,
          "error": "column kr.deadline does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT COUNT(*) FROM kr WHERE (SELECT EXTRACT(EPOCH FROM (NOW() AT TIME ZONE 'UTC' - okr.deadline) / INTERVAL '1 day') * 86400) > 0 AND kr.direction = 'down'",
          "fixed": true,
          "error": "missing FROM-clause entry for table \"okr\""
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM kr WHERE (SELECT EXTRACT(EPOCH FROM (NOW() AT TIME ZONE 'UTC' - kr.deadline) / INTERVAL '1 day') * 86400) > 0 AND kr.direction = 'down';",
      "executionTimeMs": 2631,
      "goldSql": "SELECT COUNT(*) AS delayed_kr_count FROM kr k JOIN kr_history kh ON kh.kr_id = k.id AND kh.date = (SELECT MAX(h.date) FROM kr_history h WHERE h.kr_id = k.id) WHERE (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) < 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > 1);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.6634126482600303,
      "finalSql": "SELECT COUNT(*) FROM kr WHERE (SELECT EXTRACT(EPOCH FROM (NOW() AT TIME ZONE 'UTC' - okr.deadline) / INTERVAL '1 day') * 86400) > 0 AND kr.direction = 'down'",
      "error": "Erro de execução no banco após 3 tentativa(s): missing FROM-clause entry for table \"okr\"",
      "executionMatch": false
    },
    {
      "question": "Qual o progresso médio dos KRs de tipo “PERC” em comparação aos de tipo “NUMERIC”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT metric, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric ORDER BY metric;"
        }
      ],
      "predictedSql": "SELECT metric, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric ORDER BY metric;",
      "executionTimeMs": 2708,
      "goldSql": "SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9674602929943622,
      "finalSql": "SELECT metric, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric ORDER BY metric;",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.983730146497181
    },
    {
      "question": "Quais OKRs têm maior número de KRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id, o.title, COUNT(k.id) AS num_krs FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_managers im ON i.id = im.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.title ORDER BY COUNT(k.id) DESC LIMIT 1;",
          "error": "column o.title does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT o.id, o.description, COUNT(k.id) AS num_krs FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_managers im ON i.id = im.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY COUNT(k.id) DESC LIMIT 1;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT o.id, o.title, COUNT(k.id) AS num_krs FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_managers im ON i.id = im.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.title ORDER BY COUNT(k.id) DESC LIMIT 1;",
      "executionTimeMs": 2558,
      "goldSql": "SELECT okr_id, COUNT(*) AS kr_count FROM kr GROUP BY okr_id ORDER BY kr_count DESC LIMIT 5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7092081622816543,
      "finalSql": "SELECT o.id, o.description, COUNT(k.id) AS num_krs FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_managers im ON i.id = im.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY COUNT(k.id) DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.35460408114082714
    },
    {
      "question": "Qual o percentual de KRs marcados como “bookmarked” pelos colaboradores?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT CAST(SUM(CASE WHEN k.bookmarked THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(k.id) AS bookmarked_percentage FROM kr k"
        }
      ],
      "predictedSql": "SELECT CAST(SUM(CASE WHEN k.bookmarked THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(k.id) AS bookmarked_percentage FROM kr k",
      "executionTimeMs": 1811,
      "goldSql": "SELECT COUNT(*) FILTER (WHERE bookmarked) * 100.0 / COUNT(*) AS percent_bookmarked FROM kr;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.7962227942848837,
      "finalSql": "SELECT CAST(SUM(CASE WHEN k.bookmarked THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(k.id) AS bookmarked_percentage FROM kr k",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.39811139714244187
    },
    {
      "question": "Qual é o percentual médio de progresso dos KRs (Key Results) em relação às metas estabelecidas nos últimos três meses?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 month' AND k.direction = 'up' OR k.direction = 'down'"
        }
      ],
      "predictedSql": "SELECT AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 month' AND k.direction = 'up' OR k.direction = 'down'",
      "executionTimeMs": 1215,
      "goldSql": "SELECT AVG(kh.progress / NULLIF(k.target, 0)) * 100 AS avg_progress_percent FROM kr k JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 months';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9081234378517516,
      "finalSql": "SELECT AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 month' AND k.direction = 'up' OR k.direction = 'down'",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4540617189258758
    },
    {
      "question": "Quais colaboradores têm mais KRs marcados como “bookmarked” (favoritos) e demonstram maior engajamento com os objetivos da empresa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, COUNT(kh.id) AS num_bookmarked_krs, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE kh.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY avg_progress DESC LIMIT 10;",
          "error": "column kh.bookmarked does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT c.name, COUNT(kh.id) AS num_bookmarked_krs, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY avg_progress DESC LIMIT 10;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT c.name, COUNT(kh.id) AS num_bookmarked_krs, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE kh.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY avg_progress DESC LIMIT 10;",
      "executionTimeMs": 1710,
      "goldSql": "SELECT c.id, c.name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator c JOIN kr k ON k.bookmarked_by_id = c.id AND k.bookmarked = true GROUP BY c.id, c.name ORDER BY bookmarked_kr_count DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7741629603887376,
      "finalSql": "SELECT c.name, COUNT(kh.id) AS num_bookmarked_krs, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY avg_progress DESC LIMIT 10;",
      "executionMatch": false,
      "tableSimilarity": 0.1333333333333333,
      "queryAffinityScore": 0.45374814686103543
    },
    {
      "question": "Qual é o tempo médio entre a criação de um OKR e a primeira atualização de progresso registrada?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (iu.last_modified_date - o.created_date))) AS avg_time_between_okr_creation_and_first_update FROM okr o JOIN initiative_update iu ON o.id = iu.initiative_id WHERE iu.id IN (SELECT MIN(id) FROM initiative_update WHERE initiative_id = o.id) AND o.created_date < iu.last_modified_date;"
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (iu.last_modified_date - o.created_date))) AS avg_time_between_okr_creation_and_first_update FROM okr o JOIN initiative_update iu ON o.id = iu.initiative_id WHERE iu.id IN (SELECT MIN(id) FROM initiative_update WHERE initiative_id = o.id) AND o.created_date < iu.last_modified_date;",
      "executionTimeMs": 2611,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.first_update - o.created_date)) / 86400) AS avg_days_to_first_update FROM okr o JOIN (SELECT k.okr_id, MIN(kh.date) AS first_update FROM kr k JOIN kr_history kh ON kh.kr_id = k.id GROUP BY k.okr_id) kh ON kh.okr_id = o.id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8469690635410375,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (iu.last_modified_date - o.created_date))) AS avg_time_between_okr_creation_and_first_update FROM okr o JOIN initiative_update iu ON o.id = iu.initiative_id WHERE iu.id IN (SELECT MIN(id) FROM initiative_update WHERE initiative_id = o.id) AND o.created_date < iu.last_modified_date;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.42348453177051876
    },
    {
      "question": "Quantos OKRs estão próximos do prazo final (deadline) e ainda não atingiram 80% de progresso?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.deadline - iu.created_date <= INTERVAL '1 month' AND iu.progress < 0.8;",
          "error": "column iu.deadline does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT COUNT(*) FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON o.id = iu.initiative_id WHERE iu.deadline - iu.created_date <= INTERVAL '1 month' AND iu.progress < 0.8;",
          "fixed": true,
          "error": "column iu.deadline does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT COUNT(*) FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON o.id = iu.initiative_id WHERE iu.year_month - iu.created_date <= INTERVAL '1 month' AND iu.progress < 0.8;",
          "fixed": true,
          "error": "operator does not exist: character varying - timestamp with time zone"
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.deadline - iu.created_date <= INTERVAL '1 month' AND iu.progress < 0.8;",
      "executionTimeMs": 2388,
      "goldSql": "SELECT COUNT(*) AS okrs_near_deadline_low_progress FROM ( SELECT o.id FROM okr o JOIN kr k ON k.okr_id = o.id WHERE o.deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' GROUP BY o.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8 ) sub;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.5568320245727273,
      "finalSql": "SELECT COUNT(*) FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON o.id = iu.initiative_id WHERE iu.year_month - iu.created_date <= INTERVAL '1 month' AND iu.progress < 0.8;",
      "error": "Erro de execução no banco após 3 tentativa(s): operator does not exist: character varying - timestamp with time zone",
      "executionMatch": false
    },
    {
      "question": "Quais iniciativas possuem OKRs cujo progresso médio supera o progresso médio global de todas as iniciativas da mesma categoria?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_initiative, AVG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY i.category) AS avg_progress_in_category FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_history kh ON o.id = kh.okr_id JOIN kr k ON kh.kr_id = k.id GROUP BY i.category, i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category);",
          "error": "column kh.okr_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.category, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_initiative, AVG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY i.category) AS avg_progress_in_category FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category, i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category)",
          "fixed": true,
          "error": "column \"kh.progress\" must appear in the GROUP BY clause or be used in an aggregate function"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.category, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_initiative, AVG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY i.category) AS avg_progress_in_category FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category, i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category)",
          "fixed": true,
          "error": "column \"kh.progress\" must appear in the GROUP BY clause or be used in an aggregate function"
        }
      ],
      "predictedSql": "SELECT i.category, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_initiative, AVG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY i.category) AS avg_progress_in_category FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_history kh ON o.id = kh.okr_id JOIN kr k ON kh.kr_id = k.id GROUP BY i.category, i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category);",
      "executionTimeMs": 3571,
      "goldSql": "WITH initiative_avg AS (SELECT i.id, i.category, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, i.category), category_avg AS (SELECT category, AVG(avg_progress) AS category_avg_progress FROM initiative_avg GROUP BY category) SELECT ia.id, ia.category, ia.avg_progress FROM initiative_avg ia JOIN category_avg ca ON ia.category = ca.category WHERE ia.avg_progress > ca.category_avg_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.9091291927773407,
      "finalSql": "SELECT i.category, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_initiative, AVG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY i.category) AS avg_progress_in_category FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.category, i.id, i.title HAVING AVG(kh.progress / NULLIF(kh.target,0)) > (SELECT AVG(kh.progress / NULLIF(kh.target,0)) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category)",
      "error": "Erro de execução no banco após 3 tentativa(s): column \"kh.progress\" must appear in the GROUP BY clause or be used in an aggregate function",
      "executionMatch": false
    },
    {
      "question": "Qual colaborador teve o maior aumento percentual de progresso médio de KRs entre o último e o penúltimo mês?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, c.id, (AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.created_date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) / LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.created_date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS progress_increase FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id WHERE EXTRACT(MONTH FROM kh.created_date) = EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '1 month')) OR EXTRACT(MONTH FROM kh.created_date) = EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '2 month')) ORDER BY progress_increase DESC LIMIT 1;",
          "error": "column kh.created_date does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT c.name, c.id, (AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) / LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS progress_increase FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id WHERE EXTRACT(MONTH FROM kh.date) = EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '1 month')) OR EXTRACT(MONTH FROM kh.date) = EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '2 month')) ORDER BY progress_increase DESC LIMIT 1;",
          "fixed": true,
          "error": "column \"c.name\" must appear in the GROUP BY clause or be used in an aggregate function"
        },
        {
          "attempt": 3,
          "sql": "SELECT c.name, c.id, (AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) / LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS progress_increase FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id WHERE EXTRACT(MONTH FROM kh.date) IN (EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '1 month')), EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '2 month'))) GROUP BY c.name, c.id ORDER BY progress_increase DESC LIMIT 1;",
          "fixed": true,
          "error": "column \"kh.date\" must appear in the GROUP BY clause or be used in an aggregate function"
        }
      ],
      "predictedSql": "SELECT c.name, c.id, (AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.created_date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) / LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.created_date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS progress_increase FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id WHERE EXTRACT(MONTH FROM kh.created_date) = EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '1 month')) OR EXTRACT(MONTH FROM kh.created_date) = EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '2 month')) ORDER BY progress_increase DESC LIMIT 1;",
      "executionTimeMs": 3738,
      "goldSql": "WITH monthly_progress AS (SELECT collaborator_id, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr_history GROUP BY collaborator_id, month), ranked_progress AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY collaborator_id ORDER BY month DESC) AS rn FROM monthly_progress), last_two_months AS (SELECT p1.collaborator_id, p1.avg_progress AS last_month_progress, p2.avg_progress AS prev_month_progress, CASE WHEN p2.avg_progress = 0 THEN NULL ELSE ((p1.avg_progress - p2.avg_progress) / p2.avg_progress) * 100 END AS pct_increase FROM ranked_progress p1 JOIN ranked_progress p2 ON p1.collaborator_id = p2.collaborator_id WHERE p1.rn = 1 AND p2.rn = 2) SELECT collaborator_id, pct_increase FROM last_two_months ORDER BY pct_increase DESC LIMIT 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8576928377519072,
      "finalSql": "SELECT c.name, c.id, (AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) / LAG(AVG(kh.progress / NULLIF(kh.target,0))) OVER (PARTITION BY c.id ORDER BY kh.date ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS progress_increase FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id WHERE EXTRACT(MONTH FROM kh.date) IN (EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '1 month')), EXTRACT(MONTH FROM (CURRENT_DATE - INTERVAL '2 month'))) GROUP BY c.name, c.id ORDER BY progress_increase DESC LIMIT 1;",
      "error": "Erro de execução no banco após 3 tentativa(s): column \"kh.date\" must appear in the GROUP BY clause or be used in an aggregate function",
      "executionMatch": false
    },
    {
      "question": "Quais iniciativas tiveram pelo menos um KR com progresso superior a 100% em algum ponto do histórico?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.id, i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id WHERE kh.progress > 100 GROUP BY i.id, i.title;",
          "error": "column kh.initiative_update_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.id, i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id WHERE kh.progress > 100 GROUP BY i.id, i.title;",
          "fixed": true,
          "error": "column kh.initiative_update_id does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.id, i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_id WHERE kh.progress > 100 GROUP BY i.id, i.title;",
          "fixed": true,
          "error": "column kh.initiative_id does not exist"
        }
      ],
      "predictedSql": "SELECT i.id, i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_update_id WHERE kh.progress > 100 GROUP BY i.id, i.title;",
      "executionTimeMs": 2929,
      "goldSql": "SELECT DISTINCT i.id, i.title FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target, 0) > 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8458443302304492,
      "finalSql": "SELECT i.id, i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id JOIN kr_history kh ON iu.id = kh.initiative_id WHERE kh.progress > 100 GROUP BY i.id, i.title;",
      "error": "Erro de execução no banco após 3 tentativa(s): column kh.initiative_id does not exist",
      "executionMatch": false
    },
    {
      "question": "Qual é o tempo médio (em dias) entre atualizações consecutivas de um mesmo KR no histórico?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (kh2.created_date - kh1.created_date)) / 86400) AS avg_time_between_updates FROM kr_history kh1 JOIN kr_history kh2 ON kh1.kr_id = kh2.kr_id AND kh1.id < kh2.id",
          "error": "column kh2.created_date does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (kh2.created_date - kh1.created_date)) / 86400) AS avg_time_between_updates FROM kr_history kh1 JOIN kr_history kh2 ON kh1.kr_id = kh2.kr_id AND kh1.id < kh2.id",
          "fixed": true,
          "error": "column kh2.created_date does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (kh2.created_date - kh1.created_date)) / 86400) AS avg_time_between_updates FROM kr_history kh1 JOIN kr_history kh2 ON kh1.kr_id = kh2.kr_id AND kh1.id < kh2.id",
          "fixed": true,
          "error": "column kh2.created_date does not exist"
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh2.created_date - kh1.created_date)) / 86400) AS avg_time_between_updates FROM kr_history kh1 JOIN kr_history kh2 ON kh1.kr_id = kh2.kr_id AND kh1.id < kh2.id",
      "executionTimeMs": 1703,
      "goldSql": "WITH diffs AS (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date FROM kr_history) SELECT AVG(EXTRACT(EPOCH FROM (next_date - date)) / 86400) AS avg_days_between_updates FROM diffs WHERE next_date IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8544311458457058,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh2.created_date - kh1.created_date)) / 86400) AS avg_time_between_updates FROM kr_history kh1 JOIN kr_history kh2 ON kh1.kr_id = kh2.kr_id AND kh1.id < kh2.id",
      "error": "Erro de execução no banco após 3 tentativa(s): column kh2.created_date does not exist",
      "executionMatch": false
    },
    {
      "question": "Quais iniciativas têm pelo menos dois OKRs com deadlines no mesmo mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.id, i.title, i.deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE EXTRACT(MONTH FROM o.deadline) = EXTRACT(MONTH FROM i.deadline) GROUP BY i.id, i.title, i.deadline HAVING COUNT(DISTINCT o.id) >= 2;",
          "error": "column i.deadline does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.id, i.title, i.end_date AS deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE EXTRACT(MONTH FROM o.deadline) = EXTRACT(MONTH FROM i.end_date) GROUP BY i.id, i.title, i.end_date HAVING COUNT(DISTINCT o.id) >= 2;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.id, i.title, i.deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE EXTRACT(MONTH FROM o.deadline) = EXTRACT(MONTH FROM i.deadline) GROUP BY i.id, i.title, i.deadline HAVING COUNT(DISTINCT o.id) >= 2;",
      "executionTimeMs": 3005,
      "goldSql": "SELECT initiative_id FROM okr GROUP BY initiative_id, DATE_TRUNC('month', deadline) HAVING COUNT(*) >= 2;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8396582399340216,
      "finalSql": "SELECT i.id, i.title, i.end_date AS deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE EXTRACT(MONTH FROM o.deadline) = EXTRACT(MONTH FROM i.end_date) GROUP BY i.id, i.title, i.end_date HAVING COUNT(DISTINCT o.id) >= 2;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4198291199670108
    },
    {
      "question": "Qual é a distribuição percentual de KRs por tipo de métrica dentro de cada iniciativa?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, k.metric, COUNT(kr.id) AS total_krs, ROUND(COUNT(kr.id) * 100.0 / (SELECT COUNT(*) FROM kr WHERE okr_id = o.id), 2) AS percent_total FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.title, k.metric ORDER BY i.title, k.metric;",
          "error": "invalid reference to FROM-clause entry for table \"kr\""
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title, k.metric, COUNT(kr.id) AS total_krs, ROUND(COUNT(kr.id) * 100.0 / (SELECT COUNT(*) FROM kr WHERE okr_id = o.id), 2) AS percent_total FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.title, k.metric ORDER BY i.title, k.metric;",
          "fixed": true,
          "error": "invalid reference to FROM-clause entry for table \"kr\""
        },
        {
          "attempt": 3,
          "sql": "SELECT i.title, k.metric, COUNT(kr.id) AS total_krs, ROUND(COUNT(kr.id) * 100.0 / (SELECT COUNT(*) FROM kr WHERE okr_id = o.id), 2) AS percent_total FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.title, k.metric ORDER BY i.title, k.metric;",
          "fixed": true,
          "error": "invalid reference to FROM-clause entry for table \"kr\""
        }
      ],
      "predictedSql": "SELECT i.title, k.metric, COUNT(kr.id) AS total_krs, ROUND(COUNT(kr.id) * 100.0 / (SELECT COUNT(*) FROM kr WHERE okr_id = o.id), 2) AS percent_total FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id GROUP BY i.title, k.metric ORDER BY i.title, k.metric;",
      "executionTimeMs": 2773,
      "goldSql": "WITH kr_counts AS (SELECT i.id AS initiative_id, k.metric, COUNT(*) AS count FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, k.metric), initiative_totals AS (SELECT initiative_id, SUM(count) AS total FROM kr_counts GROUP BY initiative_id) SELECT kc.initiative_id, kc.metric, (kc.count::float / it.total) * 100 AS percent FROM kr_counts kc JOIN initiative_totals it ON kc.initiative_id = it.initiative_id ORDER BY kc.initiative_id, percent DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8865934961051248,
      "finalSql": "SELECT i.title, k.metric, COUNT(kr.id) AS total_krs, ROUND(COUNT(kr.id) * 100.0 / (SELECT COUNT(*) FROM kr WHERE okr_id = o.id), 2) AS percent_total FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.title, k.metric ORDER BY i.title, k.metric;",
      "error": "Erro de execução no banco após 3 tentativa(s): invalid reference to FROM-clause entry for table \"kr\"",
      "executionMatch": false
    },
    {
      "question": "Listar os KRs cujo progresso atual está abaixo da média dos KRs do mesmo tipo e direção.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.* FROM kr k JOIN (SELECT kr_id, direction, metric, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr GROUP BY kr_id, direction, metric) AS kr_avg ON k.id = kr_avg.kr_id WHERE (k.direction = 'up' AND k.progress / NULLIF(k.target,0) < kr_avg.avg_progress) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > kr_avg.avg_progress);",
          "error": "column \"kr_id\" does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT k.* FROM kr k JOIN (SELECT id, direction, metric, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr GROUP BY id, direction, metric) AS kr_avg ON k.id = kr_avg.id WHERE (k.direction = 'up' AND k.progress / NULLIF(k.target,0) < kr_avg.avg_progress) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > kr_avg.avg_progress);",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT k.* FROM kr k JOIN (SELECT kr_id, direction, metric, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr GROUP BY kr_id, direction, metric) AS kr_avg ON k.id = kr_avg.kr_id WHERE (k.direction = 'up' AND k.progress / NULLIF(k.target,0) < kr_avg.avg_progress) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > kr_avg.avg_progress);",
      "executionTimeMs": 3268,
      "goldSql": "WITH avg_progress AS (SELECT metric, direction, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY metric, direction) SELECT k.* FROM kr k JOIN avg_progress ap ON k.metric = ap.metric AND k.direction = ap.direction WHERE (k.progress / NULLIF(k.target, 0)) < ap.avg_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.9294957908523719,
      "finalSql": "SELECT k.* FROM kr k JOIN (SELECT id, direction, metric, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr GROUP BY id, direction, metric) AS kr_avg ON k.id = kr_avg.id WHERE (k.direction = 'up' AND k.progress / NULLIF(k.target,0) < kr_avg.avg_progress) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > kr_avg.avg_progress);",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.46474789542618594
    },
    {
      "question": "Identificar iniciativas que mantêm registros de atualização em meses consecutivos, sem interrupções.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.id, i.title, i.category FROM initiative i JOIN initiative_update u ON i.id = u.initiative_id WHERE u.year_month >= (SELECT MAX(u2.year_month) - INTERVAL '1 month' FROM initiative_update u2 WHERE u2.initiative_id = i.id) GROUP BY i.id, i.title, i.category HAVING COUNT(DISTINCT u.year_month) = (SELECT MAX(u2.year_month) - (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id) + 1) AND (SELECT MAX(u2.year_month) - (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id) + 1) > 1",
          "error": "operator does not exist: text - interval"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.id, i.title, i.category FROM initiative i JOIN initiative_update u ON i.id = u.initiative_id WHERE u.year_month >= (SELECT MAX(u2.year_month) - INTERVAL '1 month' FROM initiative_update u2 WHERE u2.initiative_id = i.id) GROUP BY i.id, i.title, i.category HAVING COUNT(DISTINCT EXTRACT(YEAR FROM u.year_month) * 100 + EXTRACT(MONTH FROM u.year_month)) = (SELECT MAX(u2.year_month) - INTERVAL '1 month' + EXTRACT(YEAR FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) * 100 + EXTRACT(MONTH FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) + 1) AND (SELECT MAX(u2.year_month) - INTERVAL '1 month' + EXTRACT(YEAR FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) * 100 + EXTRACT(MONTH FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) + 1) > 1",
          "fixed": true,
          "error": "operator does not exist: text - interval"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.id, i.title, i.category FROM initiative i JOIN initiative_update u ON i.id = u.initiative_id WHERE u.year_month >= (SELECT MAX(u2.year_month) - INTERVAL '1 month' FROM initiative_update u2 WHERE u2.initiative_id = i.id) GROUP BY i.id, i.title, i.category HAVING COUNT(DISTINCT EXTRACT(YEAR FROM u.year_month) * 100 + EXTRACT(MONTH FROM u.year_month)) = (SELECT MAX(u2.year_month) - INTERVAL '1 month' + EXTRACT(YEAR FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) * 100 + EXTRACT(MONTH FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) + 1) AND (SELECT MAX(u2.year_month) - INTERVAL '1 month' + EXTRACT(YEAR FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) * 100 + EXTRACT(MONTH FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) + 1) > 1",
          "fixed": true,
          "error": "operator does not exist: text - interval"
        }
      ],
      "predictedSql": "SELECT i.id, i.title, i.category FROM initiative i JOIN initiative_update u ON i.id = u.initiative_id WHERE u.year_month >= (SELECT MAX(u2.year_month) - INTERVAL '1 month' FROM initiative_update u2 WHERE u2.initiative_id = i.id) GROUP BY i.id, i.title, i.category HAVING COUNT(DISTINCT u.year_month) = (SELECT MAX(u2.year_month) - (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id) + 1) AND (SELECT MAX(u2.year_month) - (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id) + 1) > 1",
      "executionTimeMs": 4437,
      "goldSql": "WITH updates_months AS (SELECT initiative_id, DATE_TRUNC('month', created_date) AS month FROM initiative_update GROUP BY initiative_id, month), consecutive AS (SELECT initiative_id, month, LAG(month) OVER (PARTITION BY initiative_id ORDER BY month) AS prev_month FROM updates_months), gaps AS (SELECT initiative_id, COUNT(*) FILTER (WHERE prev_month IS NOT NULL AND month - INTERVAL '1 month' <> prev_month) AS gap_count, COUNT(month) AS total_months FROM consecutive GROUP BY initiative_id) SELECT initiative_id FROM gaps WHERE gap_count = 0 AND total_months > 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.375
      },
      "cosineSimilarity": 0.7595782836531144,
      "finalSql": "SELECT i.id, i.title, i.category FROM initiative i JOIN initiative_update u ON i.id = u.initiative_id WHERE u.year_month >= (SELECT MAX(u2.year_month) - INTERVAL '1 month' FROM initiative_update u2 WHERE u2.initiative_id = i.id) GROUP BY i.id, i.title, i.category HAVING COUNT(DISTINCT EXTRACT(YEAR FROM u.year_month) * 100 + EXTRACT(MONTH FROM u.year_month)) = (SELECT MAX(u2.year_month) - INTERVAL '1 month' + EXTRACT(YEAR FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) * 100 + EXTRACT(MONTH FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) + 1) AND (SELECT MAX(u2.year_month) - INTERVAL '1 month' + EXTRACT(YEAR FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) * 100 + EXTRACT(MONTH FROM (SELECT MIN(u2.year_month) FROM initiative_update u2 WHERE u2.initiative_id = i.id)) + 1) > 1",
      "error": "Erro de execução no banco após 3 tentativa(s): operator does not exist: text - interval",
      "executionMatch": false
    },
    {
      "question": "Calcular a taxa média de crescimento mensal do progresso dos KRs, segmentada por tipo de métrica.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.metric, EXTRACT(MONTH FROM kh.date) AS month, EXTRACT(YEAR FROM kh.date) AS year, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0)), 1, 0) OVER (PARTITION BY k.metric ORDER BY kh.date) AS monthly_growth FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.metric, EXTRACT(MONTH FROM kh.date), EXTRACT(YEAR FROM kh.date) ORDER BY k.metric, year, month;",
          "error": "column \"kh.date\" must appear in the GROUP BY clause or be used in an aggregate function"
        },
        {
          "attempt": 2,
          "sql": "SELECT k.metric, EXTRACT(MONTH FROM kh.date) AS month, EXTRACT(YEAR FROM kh.date) AS year, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0)), 1, 0) OVER (PARTITION BY k.metric ORDER BY kh.date) AS monthly_growth FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.metric, EXTRACT(MONTH FROM kh.date), EXTRACT(YEAR FROM kh.date) ORDER BY k.metric, year, month;",
          "fixed": true,
          "error": "column \"kh.date\" must appear in the GROUP BY clause or be used in an aggregate function"
        },
        {
          "attempt": 3,
          "sql": "SELECT k.metric, EXTRACT(MONTH FROM kh.date) AS month, EXTRACT(YEAR FROM kh.date) AS year, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0)), 1, 0) OVER (PARTITION BY k.metric ORDER BY kh.date) AS monthly_growth FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.metric, EXTRACT(MONTH FROM kh.date), EXTRACT(YEAR FROM kh.date), kh.date ORDER BY k.metric, year, month;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT k.metric, EXTRACT(MONTH FROM kh.date) AS month, EXTRACT(YEAR FROM kh.date) AS year, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0)), 1, 0) OVER (PARTITION BY k.metric ORDER BY kh.date) AS monthly_growth FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.metric, EXTRACT(MONTH FROM kh.date), EXTRACT(YEAR FROM kh.date) ORDER BY k.metric, year, month;",
      "executionTimeMs": 2762,
      "goldSql": "WITH monthly_kr_progress AS (SELECT kr_id, metric, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr_history GROUP BY kr_id, metric, month), monthly_growth AS (SELECT kr_id, metric, month, avg_progress, LAG(avg_progress) OVER (PARTITION BY kr_id ORDER BY month) AS prev_avg_progress FROM monthly_kr_progress), growth_rate AS (SELECT metric, AVG(CASE WHEN prev_avg_progress IS NOT NULL THEN (avg_progress - prev_avg_progress) / NULLIF(prev_avg_progress,0) ELSE NULL END) AS avg_monthly_growth_rate FROM monthly_growth GROUP BY metric) SELECT metric, avg_monthly_growth_rate FROM growth_rate;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8609004862938556,
      "finalSql": "SELECT k.metric, EXTRACT(MONTH FROM kh.date) AS month, EXTRACT(YEAR FROM kh.date) AS year, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress, AVG(kh.progress / NULLIF(kh.target,0)) - LAG(AVG(kh.progress / NULLIF(kh.target,0)), 1, 0) OVER (PARTITION BY k.metric ORDER BY kh.date) AS monthly_growth FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.metric, EXTRACT(MONTH FROM kh.date), EXTRACT(YEAR FROM kh.date), kh.date ORDER BY k.metric, year, month;",
      "executionMatch": false,
      "tableSimilarity": 0.00043572984749462584,
      "queryAffinityScore": 0.4306681080706751
    },
    {
      "question": "Detectar iniciativas que apresentaram regressão média no progresso de seus KRs durante o último ciclo de atualização.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH kr_history AS (SELECT kr_id, initiative_id, progress, target, created_date, direction FROM kr_history WHERE created_date BETWEEN CURRENT_DATE - INTERVAL '1 year' AND CURRENT_DATE), regressao_krs AS (SELECT initiative_id, AVG(CASE WHEN direction = 'down' THEN (progress / NULLIF(target, 0)) ELSE 0 END) - AVG(CASE WHEN direction = 'up' THEN (progress / NULLIF(target, 0)) ELSE 0 END) AS media_regressao FROM kr_history GROUP BY initiative_id), regressao_initiatives AS (SELECT i.id, i.title, r.media_regressao FROM initiative i JOIN regressao_krs r ON i.id = r.initiative_id WHERE r.media_regressao IS NOT NULL AND r.media_regressao < 0) SELECT * FROM regressao_initiatives ORDER BY media_regressao DESC;",
          "error": "column \"initiative_id\" does not exist"
        },
        {
          "attempt": 2,
          "sql": "WITH kr_history AS (SELECT kr_id, initiative_id, progress, target, created_date, direction FROM kr_history WHERE created_date BETWEEN CURRENT_DATE - INTERVAL '1 year' AND CURRENT_DATE), regressao_krs AS (SELECT initiative_id, AVG(CASE WHEN direction = 'down' THEN (progress / NULLIF(target, 0)) ELSE 0 END) - AVG(CASE WHEN direction = 'up' THEN (progress / NULLIF(target, 0)) ELSE 0 END) AS media_regressao FROM kr_history GROUP BY initiative_id), regressao_initiatives AS (SELECT i.id, i.title, r.media_regressao FROM initiative i JOIN regressao_krs r ON i.id = r.initiative_id WHERE r.media_regressao IS NOT NULL AND r.media_regressao < 0) SELECT * FROM regressao_initiatives ORDER BY media_regressao DESC;",
          "fixed": true,
          "error": "column \"initiative_id\" does not exist"
        },
        {
          "attempt": 3,
          "sql": "WITH kr_history AS (SELECT kr_id, initiative_id, progress, target, created_date, direction FROM kr_history WHERE created_date BETWEEN CURRENT_DATE - INTERVAL '1 year' AND CURRENT_DATE), regressao_krs AS (SELECT initiative_id, AVG(CASE WHEN direction = 'down' THEN (progress / NULLIF(target, 0)) ELSE 0 END) - AVG(CASE WHEN direction = 'up' THEN (progress / NULLIF(target, 0)) ELSE 0 END) AS media_regressao FROM kr_history GROUP BY initiative_id), regressao_initiatives AS (SELECT i.id, i.title, r.media_regressao FROM initiative i JOIN regressao_krs r ON i.id = r.initiative_id WHERE r.media_regressao IS NOT NULL AND r.media_regressao < 0) SELECT * FROM regressao_initiatives ORDER BY media_regressao DESC;",
          "fixed": true,
          "error": "column \"initiative_id\" does not exist"
        }
      ],
      "predictedSql": "WITH kr_history AS (SELECT kr_id, initiative_id, progress, target, created_date, direction FROM kr_history WHERE created_date BETWEEN CURRENT_DATE - INTERVAL '1 year' AND CURRENT_DATE), regressao_krs AS (SELECT initiative_id, AVG(CASE WHEN direction = 'down' THEN (progress / NULLIF(target, 0)) ELSE 0 END) - AVG(CASE WHEN direction = 'up' THEN (progress / NULLIF(target, 0)) ELSE 0 END) AS media_regressao FROM kr_history GROUP BY initiative_id), regressao_initiatives AS (SELECT i.id, i.title, r.media_regressao FROM initiative i JOIN regressao_krs r ON i.id = r.initiative_id WHERE r.media_regressao IS NOT NULL AND r.media_regressao < 0) SELECT * FROM regressao_initiatives ORDER BY media_regressao DESC;",
      "executionTimeMs": 4326,
      "goldSql": "WITH last_two_updates AS (SELECT kh.kr_id, i.id AS initiative_id, kh.date, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn, kh.progress / NULLIF(k.target, 0) AS relative_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id), progress_diff AS (SELECT a.initiative_id, AVG(a.relative_progress - b.relative_progress) AS avg_progress_change FROM last_two_updates a JOIN last_two_updates b ON a.kr_id = b.kr_id AND a.rn = 1 AND b.rn = 2 GROUP BY a.initiative_id) SELECT initiative_id FROM progress_diff WHERE avg_progress_change < 0;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.7597659373326184,
      "finalSql": "WITH kr_history AS (SELECT kr_id, initiative_id, progress, target, created_date, direction FROM kr_history WHERE created_date BETWEEN CURRENT_DATE - INTERVAL '1 year' AND CURRENT_DATE), regressao_krs AS (SELECT initiative_id, AVG(CASE WHEN direction = 'down' THEN (progress / NULLIF(target, 0)) ELSE 0 END) - AVG(CASE WHEN direction = 'up' THEN (progress / NULLIF(target, 0)) ELSE 0 END) AS media_regressao FROM kr_history GROUP BY initiative_id), regressao_initiatives AS (SELECT i.id, i.title, r.media_regressao FROM initiative i JOIN regressao_krs r ON i.id = r.initiative_id WHERE r.media_regressao IS NOT NULL AND r.media_regressao < 0) SELECT * FROM regressao_initiatives ORDER BY media_regressao DESC;",
      "error": "Erro de execução no banco após 3 tentativa(s): column \"initiative_id\" does not exist",
      "executionMatch": false
    },
    {
      "question": "Apontar iniciativas cujos OKRs estão vencidos, mas cujo progresso médio permanece abaixo de 80%.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.id, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_history kh ON o.id = kh.okr_id WHERE o.end_date <= CURRENT_DATE AND AVG(kh.progress / NULLIF(kh.target,0)) < 0.8 GROUP BY i.id, i.title HAVING COUNT(kh.id) > 0;",
          "error": "column kh.okr_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.id, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_history kh ON o.id = kh.okr_id WHERE o.end_date <= CURRENT_DATE AND AVG(kh.progress / NULLIF(kh.target,0)) < 0.8 GROUP BY i.id, i.title HAVING COUNT(DISTINCT kh.id) > 0;",
          "fixed": true,
          "error": "column kh.okr_id does not exist"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.id, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE o.end_date <= CURRENT_DATE AND AVG(kh.progress / NULLIF(kh.target,0)) < 0.8 GROUP BY i.id, i.title HAVING COUNT(DISTINCT kh.id) > 0;",
          "fixed": true,
          "error": "column o.end_date does not exist"
        }
      ],
      "predictedSql": "SELECT i.id, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_history kh ON o.id = kh.okr_id WHERE o.end_date <= CURRENT_DATE AND AVG(kh.progress / NULLIF(kh.target,0)) < 0.8 GROUP BY i.id, i.title HAVING COUNT(kh.id) > 0;",
      "executionTimeMs": 2454,
      "goldSql": "SELECT i.id AS initiative_id FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id WHERE o.deadline < NOW() GROUP BY i.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8832446158057838,
      "finalSql": "SELECT i.id, i.title, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE o.end_date <= CURRENT_DATE AND AVG(kh.progress / NULLIF(kh.target,0)) < 0.8 GROUP BY i.id, i.title HAVING COUNT(DISTINCT kh.id) > 0;",
      "error": "Erro de execução no banco após 3 tentativa(s): column o.end_date does not exist",
      "executionMatch": false
    },
    {
      "question": "Identificar KRs com direção “NEGATIVA” que mantêm melhora contínua e atingem o target definido.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.id, k.progress, k.target, k.direction, i.title FROM kr k JOIN initiative i ON k.okr_id = i.id WHERE k.direction = 'down' AND k.progress = k.target AND k.progress / k.target = 1.0;"
        }
      ],
      "predictedSql": "SELECT k.id, k.progress, k.target, k.direction, i.title FROM kr k JOIN initiative i ON k.okr_id = i.id WHERE k.direction = 'down' AND k.progress = k.target AND k.progress / k.target = 1.0;",
      "executionTimeMs": 2191,
      "goldSql": "WITH kr_direction AS (SELECT k.id AS kr_id, k.target, k.direction FROM kr k WHERE k.direction = 'down'), history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kd.target, 0)) AS relative_progress, LAG(kh.progress / NULLIF(kd.target, 0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_progress FROM kr_history kh JOIN kr_direction kd ON kd.kr_id = kh.kr_id), fully_improving AS (SELECT kr_id FROM history GROUP BY kr_id HAVING COUNT(*) FILTER (WHERE prev_progress IS NOT NULL AND relative_progress >= prev_progress) = COUNT(*) - 1), achieved AS (SELECT kr_id FROM (SELECT kh.kr_id, (kh.progress / NULLIF(k.target,0)) AS relative_progress, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn FROM kr_history kh JOIN kr k ON k.id = kh.kr_id WHERE k.direction = 'down') last_value WHERE rn = 1 AND relative_progress <= 1) SELECT DISTINCT kr_id FROM fully_improving JOIN achieved USING(kr_id);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.375
      },
      "cosineSimilarity": 0.7193893463834206,
      "finalSql": "SELECT k.id, k.progress, k.target, k.direction, i.title FROM kr k JOIN initiative i ON k.okr_id = i.id WHERE k.direction = 'down' AND k.progress = k.target AND k.progress / k.target = 1.0;",
      "executionMatch": false,
      "tableSimilarity": 0.03809523809523818,
      "queryAffinityScore": 0.37874229223932937
    }
  ]
}