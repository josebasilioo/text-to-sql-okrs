{
  "timestamp": "2025-11-28T02:26:08.851Z",
  "totalQuestions": 76,
  "successful": 72,
  "errors": 4,
  "retries": {
    "totalWithRetries": 13,
    "totalRetryAttempts": 19,
    "averageRetriesPerQuestion": 1.46,
    "maxRetries": 2,
    "successfulAfterRetry": 9,
    "failedAfterRetry": 4
  },
  "metrics": {
    "exactMatch": {
      "total": 72,
      "matches": 0,
      "accuracy": 0
    },
    "componentMatch": {
      "total": 72,
      "averageCM": 0.7517
    },
    "executionMatch": {
      "total": 72,
      "matches": 4,
      "accuracy": 0.05555555555555555
    },
    "cosineSimilarity": {
      "total": 72,
      "average": 0.8645
    },
    "tableSimilarity": {
      "total": 72,
      "average": 0.3263
    },
    "queryAffinityScore": {
      "total": 72,
      "average": 0.5954
    }
  },
  "results": [
    {
      "question": "Existe correlação entre a prioridade da iniciativa e o progresso médio de seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE (k.target::numeric / NULLIF(k.progress, 0)) END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;"
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE (k.target::numeric / NULLIF(k.progress, 0)) END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 6707,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9281936707427036,
      "finalSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE (k.target::numeric / NULLIF(k.progress, 0)) END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7140968353713518
    },
    {
      "question": "Iniciativas com maior prioridade tendem a ter maior progresso médio nos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;"
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 3173,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9228336469748265,
      "finalSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7114168234874132
    },
    {
      "question": "Qual é a relação entre prioridade da iniciativa e o desempenho médio dos seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_okr_performance FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;"
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_okr_performance FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 2972,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.8989465425937647,
      "finalSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_okr_performance FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.6994732712968823
    },
    {
      "question": "Iniciativas de qual categoria têm maior taxa de conclusão de KRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS completed_krs, COUNT(k.id) AS total_krs, CAST(COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS DECIMAL) * 100 / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;"
        }
      ],
      "predictedSql": "SELECT i.category, COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS completed_krs, COUNT(k.id) AS total_krs, CAST(COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS DECIMAL) * 100 / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;",
      "executionTimeMs": 3497,
      "goldSql": "SELECT i.category, CAST(SUM(CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) AS FLOAT) / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9458080454160802,
      "finalSql": "SELECT i.category, COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS completed_krs, COUNT(k.id) AS total_krs, CAST(COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS DECIMAL) * 100 / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.25,
      "queryAffinityScore": 0.5979040227080401
    },
    {
      "question": "Qual categoria de iniciativa apresenta menor frequência de updates?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY COUNT(iu.id) ASC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT i.category FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY COUNT(iu.id) ASC LIMIT 1;",
      "executionTimeMs": 2776,
      "goldSql": "SELECT i.category, CAST(COUNT(iu.id) AS FLOAT) / COUNT(DISTINCT i.id) AS avg_updates_per_initiative FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY avg_updates_per_initiative ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.81313586788258,
      "finalSql": "SELECT i.category FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY COUNT(iu.id) ASC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.125,
      "queryAffinityScore": 0.46906793394129
    },
    {
      "question": "Colaboradores com mais KRs favoritos têm desempenho melhor nos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS favorited_krs_count, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) AS avg_okr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY favorited_krs_count DESC;"
        }
      ],
      "predictedSql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS favorited_krs_count, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) AS avg_okr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY favorited_krs_count DESC;",
      "executionTimeMs": 3195,
      "goldSql": "SELECT c.name, COUNT(k.id) AS total_bookmarked_krs, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress_of_bookmarked_krs FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ORDER BY total_bookmarked_krs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8943945144226667,
      "finalSql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS favorited_krs_count, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) AS avg_okr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY favorited_krs_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.33999999999999997,
      "queryAffinityScore": 0.6171972572113333
    },
    {
      "question": "Há diferença de progresso médio entre KRs do tipo “YES_NO” e “NUMERIC”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.metric, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE NULL END) AS average_progress FROM kr AS k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;"
        }
      ],
      "predictedSql": "SELECT k.metric, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE NULL END) AS average_progress FROM kr AS k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;",
      "executionTimeMs": 3139,
      "goldSql": "SELECT k.metric, AVG(k.progress / NULLIF(k.target, 0)) AS average_progress FROM kr k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9312688835901151,
      "finalSql": "SELECT k.metric, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE NULL END) AS average_progress FROM kr AS k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7156344417950575
    },
    {
      "question": "Quais iniciativas concentram mais KRs com métrica percentual?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, COUNT(k.id) AS kr_count FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY kr_count DESC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, COUNT(k.id) AS kr_count FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY kr_count DESC;",
      "executionTimeMs": 2627,
      "goldSql": "SELECT i.title, COUNT(k.id) AS total_percentage_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.id, i.title ORDER BY total_percentage_krs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9179372037897746,
      "finalSql": "SELECT i.title AS initiative_title, COUNT(k.id) AS kr_count FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY kr_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.33720930232558133,
      "queryAffinityScore": 0.627573253057678
    },
    {
      "question": "Qual a média de progresso dos OKRs de iniciativas de alta prioridade?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target ELSE kr.target::NUMERIC / kr.progress END) AS average_okr_progress FROM okr JOIN kr ON okr.id = kr.okr_id JOIN initiative ON okr.initiative_id = initiative.id WHERE initiative.priority = 1;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target ELSE kr.target::NUMERIC / kr.progress END) AS average_okr_progress FROM okr JOIN kr ON okr.id = kr.okr_id JOIN initiative ON okr.initiative_id = initiative.id WHERE initiative.priority = 1 AND kr.target != 0 AND kr.progress != 0;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target ELSE kr.target::NUMERIC / kr.progress END) AS average_okr_progress FROM okr JOIN kr ON okr.id = kr.okr_id JOIN initiative ON okr.initiative_id = initiative.id WHERE initiative.priority = 1;",
      "executionTimeMs": 2679,
      "goldSql": "SELECT AVG(k.progress / NULLIF(k.target, 0)) AS average_okr_progress_high_priority FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8879660037422059,
      "finalSql": "SELECT AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target ELSE kr.target::NUMERIC / kr.progress END) AS average_okr_progress FROM okr JOIN kr ON okr.id = kr.okr_id JOIN initiative ON okr.initiative_id = initiative.id WHERE initiative.priority = 1 AND kr.target != 0 AND kr.progress != 0;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.44398300187110296
    },
    {
      "question": "Qual o impacto dos updates de iniciativa no progresso dos KRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT iu.initiative_id, iu.year_month AS update_period, AVG(CASE WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0) ELSE (krh.target::numeric / NULLIF(krh.progress, 0)) END) AS avg_kr_progress_after_update FROM initiative_update AS iu JOIN kr AS k ON iu.initiative_id = k.okr_id JOIN kr_history AS krh ON k.id = krh.kr_id WHERE krh.date >= iu.created_date GROUP BY iu.initiative_id, iu.year_month ORDER BY iu.initiative_id, iu.year_month;"
        }
      ],
      "predictedSql": "SELECT iu.initiative_id, iu.year_month AS update_period, AVG(CASE WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0) ELSE (krh.target::numeric / NULLIF(krh.progress, 0)) END) AS avg_kr_progress_after_update FROM initiative_update AS iu JOIN kr AS k ON iu.initiative_id = k.okr_id JOIN kr_history AS krh ON k.id = krh.kr_id WHERE krh.date >= iu.created_date GROUP BY iu.initiative_id, iu.year_month ORDER BY iu.initiative_id, iu.year_month;",
      "executionTimeMs": 3322,
      "goldSql": "WITH normalized_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(k.target,0)) AS rel_progress, LAG(kh.progress / NULLIF(k.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS rel_before FROM kr_history kh JOIN kr k ON k.id = kh.kr_id), updates AS (SELECT initiative_id, created_date FROM initiative_update), link AS (SELECT nh.kr_id, nh.rel_progress, nh.rel_before, nh.date AS progress_date, (SELECT iu.created_date FROM initiative_update iu JOIN kr k ON iu.initiative_id = k.okr_id JOIN okr o ON k.okr_id = o.id WHERE iu.initiative_id = o.initiative_id AND iu.created_date < nh.date ORDER BY iu.created_date DESC LIMIT 1) AS last_update FROM normalized_history nh JOIN kr k ON nh.kr_id = k.id JOIN okr o ON k.okr_id = o.id) SELECT AVG(rel_progress - rel_before) AS avg_progress_change_after_update FROM link WHERE rel_before IS NOT NULL AND last_update IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 0,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.4375
      },
      "cosineSimilarity": 0.7877944115307246,
      "finalSql": "SELECT iu.initiative_id, iu.year_month AS update_period, AVG(CASE WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0) ELSE (krh.target::numeric / NULLIF(krh.progress, 0)) END) AS avg_kr_progress_after_update FROM initiative_update AS iu JOIN kr AS k ON iu.initiative_id = k.okr_id JOIN kr_history AS krh ON k.id = krh.kr_id WHERE krh.date >= iu.created_date GROUP BY iu.initiative_id, iu.year_month ORDER BY iu.initiative_id, iu.year_month;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.3938972057653623
    },
    {
      "question": "Há aumento no ritmo de updates próximo aos deadlines dos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT CASE WHEN iu.created_date BETWEEN (o.deadline - INTERVAL '7 days') AND o.deadline THEN 'Últimos 7 dias antes do deadline' ELSE 'Mais de 7 dias antes do deadline' END AS periodo, COUNT(iu.id) AS total_updates FROM initiative_update AS iu JOIN okr AS o ON iu.initiative_id = o.initiative_id GROUP BY periodo ORDER BY periodo DESC;"
        }
      ],
      "predictedSql": "SELECT CASE WHEN iu.created_date BETWEEN (o.deadline - INTERVAL '7 days') AND o.deadline THEN 'Últimos 7 dias antes do deadline' ELSE 'Mais de 7 dias antes do deadline' END AS periodo, COUNT(iu.id) AS total_updates FROM initiative_update AS iu JOIN okr AS o ON iu.initiative_id = o.initiative_id GROUP BY periodo ORDER BY periodo DESC;",
      "executionTimeMs": 3286,
      "goldSql": "SELECT o.id AS okr_id, o.deadline, SUM(CASE WHEN iu.created_date BETWEEN o.deadline - INTERVAL '30 days' AND o.deadline THEN 1 ELSE 0 END) AS updates_last_30_days, SUM(CASE WHEN iu.created_date < o.deadline - INTERVAL '30 days' THEN 1 ELSE 0 END) AS updates_before_30_days FROM okr o LEFT JOIN initiative_update iu ON iu.initiative_id = o.initiative_id AND iu.created_date <= o.deadline GROUP BY o.id, o.deadline ORDER BY o.deadline;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8692069831012191,
      "finalSql": "SELECT CASE WHEN iu.created_date BETWEEN (o.deadline - INTERVAL '7 days') AND o.deadline THEN 'Últimos 7 dias antes do deadline' ELSE 'Mais de 7 dias antes do deadline' END AS periodo, COUNT(iu.id) AS total_updates FROM initiative_update AS iu JOIN okr AS o ON iu.initiative_id = o.initiative_id GROUP BY periodo ORDER BY periodo DESC;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.43460349155060957
    },
    {
      "question": "Qual é o alinhamento entre as datas de fim de iniciativa e deadlines de OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id ORDER BY i.end_date, o.deadline;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id ORDER BY i.end_date, o.deadline;",
      "executionTimeMs": 2830,
      "goldSql": "SELECT CASE WHEN o.deadline < i.end_date THEN 'OKR ANTES da Iniciativa' WHEN o.deadline = i.end_date THEN 'OKR e Iniciativa na MESMA DATA' WHEN o.deadline > i.end_date THEN 'OKR DEPOIS da Iniciativa' ELSE 'Sem data de fim para Iniciativa' END AS alinhamento, COUNT(o.id) AS total_okrs FROM okr o JOIN initiative i ON o.initiative_id = i.id GROUP BY alinhamento;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.6624515962800406,
      "finalSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id ORDER BY i.end_date, o.deadline;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.3312257981400203
    },
    {
      "question": "Quantos OKRs estão diretamente vinculados a iniciativas prioritárias (por categoria) e quantos ainda não possuem ligação clara com uma iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, COUNT(DISTINCT o.id) AS okrs_vinculados_prioritarias FROM okr o JOIN kr k ON o.id = k.okr_id JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = 1 GROUP BY i.category UNION ALL SELECT 'Sem Iniciativa Vinculada', COUNT(DISTINCT o.id) FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id WHERE i.id IS NULL;"
        }
      ],
      "predictedSql": "SELECT i.category, COUNT(DISTINCT o.id) AS okrs_vinculados_prioritarias FROM okr o JOIN kr k ON o.id = k.okr_id JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = 1 GROUP BY i.category UNION ALL SELECT 'Sem Iniciativa Vinculada', COUNT(DISTINCT o.id) FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id WHERE i.id IS NULL;",
      "executionTimeMs": 2830,
      "goldSql": "SELECT COALESCE(i.category, 'SEM INICIATIVA') AS category, COALESCE(i.priority, -1) AS priority, COUNT(o.id) AS okrs_count FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id GROUP BY category, priority ORDER BY category, priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 0,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8852852665806332,
      "finalSql": "SELECT i.category, COUNT(DISTINCT o.id) AS okrs_vinculados_prioritarias FROM okr o JOIN kr k ON o.id = k.okr_id JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = 1 GROUP BY i.category UNION ALL SELECT 'Sem Iniciativa Vinculada', COUNT(DISTINCT o.id) FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id WHERE i.id IS NULL;",
      "executionMatch": false,
      "tableSimilarity": 0.15277777777777768,
      "queryAffinityScore": 0.5190315221792055
    },
    {
      "question": "Quantas atualizações de iniciativas foram registradas neste trimestre e quais são os principais temas dos “highlights” e “brutal facts”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(iu.id) AS total_updates, iu.highlights, iu.brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', current_date) AND iu.created_date < date_trunc('quarter', current_date) + interval '3 months' GROUP BY iu.highlights, iu.brutal_facts ORDER BY total_updates DESC;"
        }
      ],
      "predictedSql": "SELECT COUNT(iu.id) AS total_updates, iu.highlights, iu.brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', current_date) AND iu.created_date < date_trunc('quarter', current_date) + interval '3 months' GROUP BY iu.highlights, iu.brutal_facts ORDER BY total_updates DESC;",
      "executionTimeMs": 2947,
      "goldSql": "SELECT COUNT(iu.id) AS total_updates_trimestre, STRING_AGG(iu.highlights, ' | ') AS todos_highlights, STRING_AGG(iu.brutal_facts, ' | ') AS todos_brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', CURRENT_DATE) AND iu.created_date < date_trunc('quarter', CURRENT_DATE) + interval '3 month';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8842101272374412,
      "finalSql": "SELECT COUNT(iu.id) AS total_updates, iu.highlights, iu.brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', current_date) AND iu.created_date < date_trunc('quarter', current_date) + interval '3 months' GROUP BY iu.highlights, iu.brutal_facts ORDER BY total_updates DESC;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4421050636187206
    },
    {
      "question": "Apresentar os KRs com maior desvio padrão de progresso ao longo do histórico, indicando instabilidade.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.title AS kr_title, STDDEV(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) ELSE (kh.target::numeric / NULLIF(kh.progress, 0)) END) AS progress_stddev FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.id, k.title, k.direction HAVING COUNT(kh.id) > 1 ORDER BY progress_stddev DESC;"
        }
      ],
      "predictedSql": "SELECT k.title AS kr_title, STDDEV(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) ELSE (kh.target::numeric / NULLIF(kh.progress, 0)) END) AS progress_stddev FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.id, k.title, k.direction HAVING COUNT(kh.id) > 1 ORDER BY progress_stddev DESC;",
      "executionTimeMs": 2983,
      "goldSql": "SELECT k.title, o.description AS okr_description, STDDEV(kh.progress / NULLIF(kh.target, 0)) AS desvio_padrao_progresso FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id GROUP BY kh.kr_id, k.title, o.description HAVING COUNT(kh.id) > 1 ORDER BY desvio_padrao_progresso DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8541690449294932,
      "finalSql": "SELECT k.title AS kr_title, STDDEV(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) ELSE (kh.target::numeric / NULLIF(kh.progress, 0)) END) AS progress_stddev FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.id, k.title, k.direction HAVING COUNT(kh.id) > 1 ORDER BY progress_stddev DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.6100000000000001,
      "queryAffinityScore": 0.7320845224647466
    },
    {
      "question": "Comparar o progresso médio dos KRs com o progresso médio das iniciativas às quais estão vinculados, destacando as maiores variações.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "{ \"sql\": \"WITH KR_Progress AS (\\n SELECT\\n k.okr_id,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0)\\n WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) -- Ajuste para 'down'\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr AS k\\n GROUP BY\\n k.okr_id\\n),\\nInitiative_Progress AS (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_initiative_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n)\\nSELECT\\n i.title AS initiative_title,\\n COALESCE(ip.avg_initiative_progress, 0) AS avg_initiative_progress,\\n COALESCE(krp.avg_kr_progress, 0) AS avg_kr_progress_for_initiative,\\n ABS(COALESCE(ip.avg_initiative_progress, 0) - COALESCE(krp.avg_kr_progress, 0)) AS progress_variation\\nFROM initiative AS i\\nLEFT JOIN Initiative_Progress AS ip\\n ON i.id = ip.initiative_id\\nLEFT JOIN KR_Progress AS krp\\n ON i.id = (SELECT okr.initiative_id FROM okr WHERE okr.id = krp.okr_id)\\nORDER BY\\n progress_variation DESC;\", \"complementaryText\": \"Esta query compara o progresso médio dos KRs com o progresso médio das iniciativas. Ela calcula o progresso médio de cada KR, considerando a direção ('up' ou 'down'), depois o progresso médio das iniciativas com base nos KRs associados. Finalmente, ela exibe o título da iniciativa, o progresso médio da iniciativa, o progresso médio dos KRs para aquela",
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH KR_Progress AS (\\n SELECT\\n k.okr_id,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0)\\n WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0)\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr AS k\\n GROUP BY\\n k.okr_id\\n),\\nInitiative_Progress AS (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_initiative_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n)\\nSELECT\\n i.title AS initiative_title,\\n COALESCE(ip.avg_initiative_progress, 0) AS avg_initiative_progress,\\n COALESCE(avg_kr_for_initiative.avg_kr_progress, 0) AS avg_kr_progress_for_initiative,\\n ABS(COALESCE(ip.avg_initiative_progress, 0) - COALESCE(avg_kr_for_initiative.avg_kr_progress, 0)) AS progress_variation\\nFROM initiative AS i\\nLEFT JOIN Initiative_Progress AS ip\\n ON i.id = ip.initiative_id\\nLEFT JOIN (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_kr_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n) AS avg_kr_for_initiative\\n ON i.id = avg_kr_for_initiative.initiative_id\\nORDER BY\\n progress_variation DESC;\", \"explanation\": \"O erro 'syntax error at or near",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"WITH KR_Progress AS (\\n SELECT\\n k.okr_id,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0)\\n WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0)\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr AS k\\n GROUP BY\\n k.okr_id\\n),\\nInitiative_Progress AS (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_initiative_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n)\\nSELECT\\n i.title AS initiative_title,\\n COALESCE(ip.avg_initiative_progress, 0) AS avg_initiative_progress,\\n COALESCE(avg_kr_for_initiative.avg_kr_progress, 0) AS avg_kr_progress_for_initiative,\\n ABS(COALESCE(ip.avg_initiative_progress, 0) - COALESCE(avg_kr_for_initiative.avg_kr_progress, 0)) AS progress_variation\\nFROM initiative AS i\\nLEFT JOIN Initiative_Progress AS ip\\n ON i.id = ip.initiative_id\\nLEFT JOIN (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_kr_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n) AS avg_kr_for_initiative\\n ON i.id = avg_kr_for_initiative.initiative_id\\nORDER BY\\n progress_variation DESC;\", \"explanation\": \"O erro 'syntax error at or near",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "{ \"sql\": \"WITH KR_Progress AS (\\n SELECT\\n k.okr_id,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0)\\n WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) -- Ajuste para 'down'\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr AS k\\n GROUP BY\\n k.okr_id\\n),\\nInitiative_Progress AS (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_initiative_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n)\\nSELECT\\n i.title AS initiative_title,\\n COALESCE(ip.avg_initiative_progress, 0) AS avg_initiative_progress,\\n COALESCE(krp.avg_kr_progress, 0) AS avg_kr_progress_for_initiative,\\n ABS(COALESCE(ip.avg_initiative_progress, 0) - COALESCE(krp.avg_kr_progress, 0)) AS progress_variation\\nFROM initiative AS i\\nLEFT JOIN Initiative_Progress AS ip\\n ON i.id = ip.initiative_id\\nLEFT JOIN KR_Progress AS krp\\n ON i.id = (SELECT okr.initiative_id FROM okr WHERE okr.id = krp.okr_id)\\nORDER BY\\n progress_variation DESC;\", \"complementaryText\": \"Esta query compara o progresso médio dos KRs com o progresso médio das iniciativas. Ela calcula o progresso médio de cada KR, considerando a direção ('up' ou 'down'), depois o progresso médio das iniciativas com base nos KRs associados. Finalmente, ela exibe o título da iniciativa, o progresso médio da iniciativa, o progresso médio dos KRs para aquela",
      "executionTimeMs": 3797,
      "goldSql": "WITH InitiativeProgress AS (SELECT i.id AS initiative_id, AVG(k.progress / NULLIF(k.target, 0)) AS avg_initiative_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id), CalculatedVariance AS (SELECT k.title AS kr_title, (k.progress / NULLIF(k.target, 0)) AS kr_current_progress, ip.avg_initiative_progress, (k.progress / NULLIF(k.target, 0)) - ip.avg_initiative_progress AS progress_variance FROM kr k JOIN okr o ON k.okr_id = o.id JOIN InitiativeProgress ip ON o.initiative_id = ip.initiative_id) SELECT kr_title, kr_current_progress, avg_initiative_progress, progress_variance FROM CalculatedVariance ORDER BY ABS(progress_variance) DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.6193900328736618,
      "finalSql": "{ \"sql\": \"WITH KR_Progress AS (\\n SELECT\\n k.okr_id,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0)\\n WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0)\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr AS k\\n GROUP BY\\n k.okr_id\\n),\\nInitiative_Progress AS (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_initiative_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n)\\nSELECT\\n i.title AS initiative_title,\\n COALESCE(ip.avg_initiative_progress, 0) AS avg_initiative_progress,\\n COALESCE(avg_kr_for_initiative.avg_kr_progress, 0) AS avg_kr_progress_for_initiative,\\n ABS(COALESCE(ip.avg_initiative_progress, 0) - COALESCE(avg_kr_for_initiative.avg_kr_progress, 0)) AS progress_variation\\nFROM initiative AS i\\nLEFT JOIN Initiative_Progress AS ip\\n ON i.id = ip.initiative_id\\nLEFT JOIN (\\n SELECT\\n o.initiative_id,\\n AVG(krp.avg_kr_progress) AS avg_kr_progress\\n FROM okr AS o\\n JOIN KR_Progress AS krp\\n ON o.id = krp.okr_id\\n GROUP BY\\n o.initiative_id\\n) AS avg_kr_for_initiative\\n ON i.id = avg_kr_for_initiative.initiative_id\\nORDER BY\\n progress_variation DESC;\", \"explanation\": \"O erro 'syntax error at or near",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Construir o ranking das categorias de iniciativa com base no progresso médio ponderado pelo número de KRs associados.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH CategoryProgress AS (SELECT i.category, COUNT(k.id) AS num_krs, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS total_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category) SELECT category, (total_progress / num_krs) AS weighted_average_progress, RANK() OVER (ORDER BY (total_progress / num_krs) DESC) AS ranking FROM CategoryProgress ORDER BY ranking;"
        }
      ],
      "predictedSql": "WITH CategoryProgress AS (SELECT i.category, COUNT(k.id) AS num_krs, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS total_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category) SELECT category, (total_progress / num_krs) AS weighted_average_progress, RANK() OVER (ORDER BY (total_progress / num_krs) DESC) AS ranking FROM CategoryProgress ORDER BY ranking;",
      "executionTimeMs": 3287,
      "goldSql": "SELECT i.category, AVG(k.progress / NULLIF(k.target, 0)) AS weighted_average_progress, COUNT(k.id) AS total_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8613967020122589,
      "finalSql": "WITH CategoryProgress AS (SELECT i.category, COUNT(k.id) AS num_krs, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS total_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category) SELECT category, (total_progress / num_krs) AS weighted_average_progress, RANK() OVER (ORDER BY (total_progress / num_krs) DESC) AS ranking FROM CategoryProgress ORDER BY ranking;",
      "executionMatch": false,
      "tableSimilarity": 0.33333333333333337,
      "queryAffinityScore": 0.5973650176727962
    },
    {
      "question": "Avaliar a correlação entre o número de updates registrados em cada iniciativa e o progresso médio de seus KRs.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH InitiativeUpdates AS (SELECT initiative_id, COUNT(*) AS num_updates FROM initiative_update GROUP BY initiative_id), KRProgress AS (SELECT k.okr_id, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_kr_progress FROM kr k GROUP BY k.okr_id), OKRInitiative AS (SELECT o.id AS okr_id, o.initiative_id FROM okr o) SELECT iu.initiative_id, iu.num_updates, COALESCE(AVG(kp.avg_kr_progress), 0) AS average_kr_progress FROM InitiativeUpdates iu LEFT JOIN OKRInitiative oi ON iu.initiative_id = oi.initiative_id LEFT JOIN KRProgress kp ON oi.okr_id = kp.okr_id GROUP BY iu.initiative_id, iu.num_updates ORDER BY iu.initiative_id;"
        }
      ],
      "predictedSql": "WITH InitiativeUpdates AS (SELECT initiative_id, COUNT(*) AS num_updates FROM initiative_update GROUP BY initiative_id), KRProgress AS (SELECT k.okr_id, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_kr_progress FROM kr k GROUP BY k.okr_id), OKRInitiative AS (SELECT o.id AS okr_id, o.initiative_id FROM okr o) SELECT iu.initiative_id, iu.num_updates, COALESCE(AVG(kp.avg_kr_progress), 0) AS average_kr_progress FROM InitiativeUpdates iu LEFT JOIN OKRInitiative oi ON iu.initiative_id = oi.initiative_id LEFT JOIN KRProgress kp ON oi.okr_id = kp.okr_id GROUP BY iu.initiative_id, iu.num_updates ORDER BY iu.initiative_id;",
      "executionTimeMs": 3423,
      "goldSql": "WITH InitiativeMetrics AS (SELECT i.id AS initiative_id, COUNT(iu.id) AS total_updates, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id) SELECT CORR(im.total_updates, im.average_kr_progress) AS correlation_updates_vs_progress FROM InitiativeMetrics im;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8302380860896975,
      "finalSql": "WITH InitiativeUpdates AS (SELECT initiative_id, COUNT(*) AS num_updates FROM initiative_update GROUP BY initiative_id), KRProgress AS (SELECT k.okr_id, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_kr_progress FROM kr k GROUP BY k.okr_id), OKRInitiative AS (SELECT o.id AS okr_id, o.initiative_id FROM okr o) SELECT iu.initiative_id, iu.num_updates, COALESCE(AVG(kp.avg_kr_progress), 0) AS average_kr_progress FROM InitiativeUpdates iu LEFT JOIN OKRInitiative oi ON iu.initiative_id = oi.initiative_id LEFT JOIN KRProgress kp ON oi.okr_id = kp.okr_id GROUP BY iu.initiative_id, iu.num_updates ORDER BY iu.initiative_id;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.41511904304484876
    },
    {
      "question": "Detectar iniciativas que apresentaram regressão média no progresso de KRs durante o último ciclo.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, AVG(CASE WHEN kh.direction = 'up' THEN (kh.progress - LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date)) / NULLIF(kh.target, 0) WHEN kh.direction = 'down' THEN (LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_regression FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date >= (SELECT MAX(date) - INTERVAL '1 month' FROM kr_history) GROUP BY i.id, i.title HAVING AVG(CASE WHEN kh.direction = 'up' THEN (kh.progress - LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date)) / NULLIF(kh.target, 0) WHEN kh.direction = 'down' THEN (LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) < 0 ORDER BY avg_regression ASC;",
          "error": "aggregate function calls cannot contain window function calls"
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH kr_progress_changes AS (\\n SELECT\\n kh.kr_id,\\n kh.date,\\n kh.progress,\\n kh.target,\\n kh.direction,\\n LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS previous_progress,\\n k.okr_id\\n FROM\\n kr_history kh\\n JOIN\\n kr k ON kh.kr_id = k.id\\n WHERE\\n kh.date >= (SELECT MAX(date) - INTERVAL '1 month' FROM kr_history)\\n),\\nkr_regression_values AS (\\n SELECT\\n kpc.okr_id,\\n CASE\\n WHEN kpc.direction = 'up' THEN (kpc.progress - kpc.previous_progress) / NULLIF(kpc.target, 0)\\n WHEN kpc.direction = 'down' THEN (kpc.previous_progress - kpc.progress) / NULLIF(kpc.target, 0)\\n ELSE 0\\n END AS regression_value\\n FROM\\n kr_progress_changes kpc\\n)\\nSELECT\\n i.title AS initiative_title,\\n AVG(krv.regression_value) AS avg_regression\\nFROM\\n initiative i\\nJOIN\\n okr o ON i.id = o.initiative_id\\nJOIN\\n kr_regression_values krv ON o.id = krv.okr_id\\nGROUP BY\\n i.id, i.title\\nHAVING\\n AVG(krv.regression_value) < 0\\nORDER BY\\n avg_regression ASC;\", \"explanation\": \"O erro 'aggregate function calls cannot contain window function calls' ocorre porque a função de janela `LAG` estava sendo usada diretamente dentro de uma função agregada `AVG` no `HAVING` e no `SELECT`. Para corrigir isso, a lógica que calcula a mudança de progresso usando `LAG` foi movida para uma CTE (Common Table Expression) chamada `kr_progress_changes`. Em seguida, outra CTE `kr_",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"WITH kr_progress_changes AS (\\n SELECT\\n kh.kr_id,\\n kh.date,\\n kh.progress,\\n kh.target,\\n k.direction,\\n LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS previous_progress,\\n k.okr_id\\n FROM\\n kr_history kh\\n JOIN\\n kr k ON kh.kr_id = k.id\\n WHERE\\n kh.date >= (SELECT MAX(date) - INTERVAL '1 month' FROM kr_history)\\n),\\nkr_regression_values AS (\\n SELECT\\n kpc.okr_id,\\n CASE\\n WHEN kpc.direction = 'up' THEN (kpc.progress - kpc.previous_progress) / NULLIF(kpc.target, 0)\\n WHEN kpc.direction = 'down' THEN (kpc.previous_progress - kpc.progress) / NULLIF(kpc.target, 0)\\n ELSE 0\\n END AS regression_value\\n FROM\\n kr_progress_changes kpc\\n)\\nSELECT\\n i.title AS initiative_title,\\n AVG(krv.regression_value) AS avg_regression\\nFROM\\n initiative i\\nJOIN\\n okr o ON i.id = o.initiative_id\\nJOIN\\n kr_regression_values krv ON o.id = krv.okr_id\\nGROUP BY\\n i.id, i.title\\nHAVING\\n AVG(krv.regression_value) < 0\\nORDER BY\\n avg_regression ASC;\", \"explanation\": \"O erro 'syntax error at or near \\\"{\\\"' na mensagem de erro do PostgreSQL indica que o problema não está na lógica SQL em si, mas sim no formato em que a query foi fornecida. O SQL foi encapsulado em um objeto JSON com a chave 'sql', o que não é uma sintaxe SQL válida. A correção removeu o encapsulamento JSON, fornecendo apenas a string SQL pura e executável. Além",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, AVG(CASE WHEN kh.direction = 'up' THEN (kh.progress - LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date)) / NULLIF(kh.target, 0) WHEN kh.direction = 'down' THEN (LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_regression FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date >= (SELECT MAX(date) - INTERVAL '1 month' FROM kr_history) GROUP BY i.id, i.title HAVING AVG(CASE WHEN kh.direction = 'up' THEN (kh.progress - LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date)) / NULLIF(kh.target, 0) WHEN kh.direction = 'down' THEN (LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) < 0 ORDER BY avg_regression ASC;",
      "executionTimeMs": 4313,
      "goldSql": "WITH hist AS (SELECT kh.kr_id, (kh.progress / NULLIF(kh.target,0)) AS rel, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev, o.initiative_id FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id), diffs AS (SELECT initiative_id, rel - prev AS diff FROM hist WHERE prev IS NOT NULL) SELECT i.title, AVG(diff) AS avg_regression_change FROM diffs d JOIN initiative i ON d.initiative_id = i.id GROUP BY i.id, i.title HAVING AVG(diff) < 0 ORDER BY avg_regression_change ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8018665928965779,
      "finalSql": "{ \"sql\": \"WITH kr_progress_changes AS (\\n SELECT\\n kh.kr_id,\\n kh.date,\\n kh.progress,\\n kh.target,\\n k.direction,\\n LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS previous_progress,\\n k.okr_id\\n FROM\\n kr_history kh\\n JOIN\\n kr k ON kh.kr_id = k.id\\n WHERE\\n kh.date >= (SELECT MAX(date) - INTERVAL '1 month' FROM kr_history)\\n),\\nkr_regression_values AS (\\n SELECT\\n kpc.okr_id,\\n CASE\\n WHEN kpc.direction = 'up' THEN (kpc.progress - kpc.previous_progress) / NULLIF(kpc.target, 0)\\n WHEN kpc.direction = 'down' THEN (kpc.previous_progress - kpc.progress) / NULLIF(kpc.target, 0)\\n ELSE 0\\n END AS regression_value\\n FROM\\n kr_progress_changes kpc\\n)\\nSELECT\\n i.title AS initiative_title,\\n AVG(krv.regression_value) AS avg_regression\\nFROM\\n initiative i\\nJOIN\\n okr o ON i.id = o.initiative_id\\nJOIN\\n kr_regression_values krv ON o.id = krv.okr_id\\nGROUP BY\\n i.id, i.title\\nHAVING\\n AVG(krv.regression_value) < 0\\nORDER BY\\n avg_regression ASC;\", \"explanation\": \"O erro 'syntax error at or near \\\"{\\\"' na mensagem de erro do PostgreSQL indica que o problema não está na lógica SQL em si, mas sim no formato em que a query foi fornecida. O SQL foi encapsulado em um objeto JSON com a chave 'sql', o que não é uma sintaxe SQL válida. A correção removeu o encapsulamento JSON, fornecendo apenas a string SQL pura e executável. Além",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Qual a distribuição de iniciativas por categoria?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY category;"
        }
      ],
      "predictedSql": "SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY category;",
      "executionTimeMs": 2322,
      "goldSql": "SELECT category, COUNT(id) AS total_initiatives, CAST(COUNT(id) AS FLOAT) * 100 / (SELECT COUNT(*) FROM initiative) AS percentage FROM initiative GROUP BY category ORDER BY total_initiatives DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.7185599424789657,
      "finalSql": "SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY category;",
      "executionMatch": false,
      "tableSimilarity": 0.6666666666666667,
      "queryAffinityScore": 0.6926133045728162
    },
    {
      "question": "Quais iniciativas têm mais OKRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;",
      "executionTimeMs": 2713,
      "goldSql": "SELECT i.title, COUNT(o.id) AS total_okrs FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY total_okrs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9714846892303369,
      "finalSql": "SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.17391304347826086,
      "queryAffinityScore": 0.5726988663542989
    },
    {
      "question": "Quantas iniciativas estão em andamento neste trimestre?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();"
        }
      ],
      "predictedSql": "SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();",
      "executionTimeMs": 2443,
      "goldSql": "SELECT COUNT(id) FROM initiative WHERE start_date <= date_trunc('quarter', CURRENT_DATE) + INTERVAL '3 month' - INTERVAL '1 second' AND (end_date IS NULL OR end_date >= date_trunc('quarter', CURRENT_DATE));",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 1
      },
      "cosineSimilarity": 0.7218548000196441,
      "finalSql": "SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.860927400009822
    },
    {
      "question": "Quais iniciativas estão sem updates há mais de 30 dias?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title, i.description FROM initiative i LEFT JOIN (SELECT initiative_id, MAX(created_date) AS last_update_date FROM initiative_update GROUP BY initiative_id) AS latest_updates ON i.id = latest_updates.initiative_id WHERE latest_updates.last_update_date IS NULL OR latest_updates.last_update_date < NOW() - INTERVAL '30 days';"
        }
      ],
      "predictedSql": "SELECT i.title, i.description FROM initiative i LEFT JOIN (SELECT initiative_id, MAX(created_date) AS last_update_date FROM initiative_update GROUP BY initiative_id) AS latest_updates ON i.id = latest_updates.initiative_id WHERE latest_updates.last_update_date IS NULL OR latest_updates.last_update_date < NOW() - INTERVAL '30 days';",
      "executionTimeMs": 2788,
      "goldSql": "SELECT i.title, MAX(iu.created_date) AS last_update FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title HAVING MAX(iu.created_date) IS NULL OR MAX(iu.created_date) < NOW() - INTERVAL '30' DAY ORDER BY last_update ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8894032320986407,
      "finalSql": "SELECT i.title, i.description FROM initiative i LEFT JOIN (SELECT initiative_id, MAX(created_date) AS last_update_date FROM initiative_update GROUP BY initiative_id) AS latest_updates ON i.id = latest_updates.initiative_id WHERE latest_updates.last_update_date IS NULL OR latest_updates.last_update_date < NOW() - INTERVAL '30 days';",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.6947016160493203
    },
    {
      "question": "Quais iniciativas têm prioridade máxima, mas baixo progresso de OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 'high' GROUP BY i.id, i.title, i.priority HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) < 0.5 ORDER BY avg_okr_progress ASC;",
          "error": "invalid input syntax for type integer: \"high\""
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title AS initiative_title, i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) < 0.5 ORDER BY avg_okr_progress ASC;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 'high' GROUP BY i.id, i.title, i.priority HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) < 0.5 ORDER BY avg_okr_progress ASC;",
      "executionTimeMs": 3329,
      "goldSql": "SELECT i.title, i.priority, AVG(k.progress / NULLIF(k.target, 0)) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.5 ORDER BY avg_okr_progress ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.928188482145908,
      "finalSql": "SELECT i.title AS initiative_title, i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) < 0.5 ORDER BY avg_okr_progress ASC;",
      "executionMatch": false,
      "tableSimilarity": 0.5555555555555556,
      "queryAffinityScore": 0.7418720188507317
    },
    {
      "question": "Quantas iniciativas estão planejadas para começar no próximo mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(id) FROM initiative WHERE start_date BETWEEN date_trunc('month', NOW() + INTERVAL '1 month') AND date_trunc('month', NOW() + INTERVAL '2 months') - INTERVAL '1 day';"
        }
      ],
      "predictedSql": "SELECT COUNT(id) FROM initiative WHERE start_date BETWEEN date_trunc('month', NOW() + INTERVAL '1 month') AND date_trunc('month', NOW() + INTERVAL '2 months') - INTERVAL '1 day';",
      "executionTimeMs": 2710,
      "goldSql": "SELECT COUNT(id) FROM initiative WHERE start_date >= date_trunc('month', CURRENT_DATE) + INTERVAL '1 month' AND start_date < date_trunc('month', CURRENT_DATE) + INTERVAL '2 month';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 1
      },
      "cosineSimilarity": 0.9463632493914386,
      "finalSql": "SELECT COUNT(id) FROM initiative WHERE start_date BETWEEN date_trunc('month', NOW() + INTERVAL '1 month') AND date_trunc('month', NOW() + INTERVAL '2 months') - INTERVAL '1 day';",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9731816246957192
    },
    {
      "question": "Quais iniciativas têm fim previsto antes do término de seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;",
      "executionTimeMs": 2906,
      "goldSql": "SELECT i.title, i.end_date, MAX(o.deadline) AS latest_okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date IS NOT NULL GROUP BY i.id, i.title, i.end_date HAVING i.end_date < MAX(o.deadline);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8885885696276701,
      "finalSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.944294284813835
    },
    {
      "question": "Quais iniciativas têm mais de três pessoas no time?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, COUNT(im.managers_id) AS number_of_managers FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.title HAVING COUNT(im.managers_id) > 3;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, COUNT(im.managers_id) AS number_of_managers FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.title HAVING COUNT(im.managers_id) > 3;",
      "executionTimeMs": 3029,
      "goldSql": "SELECT i.id, i.title, COUNT(im.managers_id) AS team_size FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id HAVING COUNT(im.managers_id) > 3",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9390639224508858,
      "finalSql": "SELECT i.title AS initiative_title, COUNT(im.managers_id) AS number_of_managers FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.title HAVING COUNT(im.managers_id) > 3;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4695319612254429
    },
    {
      "question": "Qual é a média de duração (em dias) das iniciativas concluídas?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / (60 * 60 * 24)) AS average_duration_in_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL AND end_date >= start_date;"
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / (60 * 60 * 24)) AS average_duration_in_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL AND end_date >= start_date;",
      "executionTimeMs": 2828,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9698872824713506,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / (60 * 60 * 24)) AS average_duration_in_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL AND end_date >= start_date;",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9849436412356753
    },
    {
      "question": "Qual percentual de iniciativas por categoria está concluído?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT category, CAST(SUM(CASE WHEN progress >= 1.0 THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(*) AS percentage_completed FROM (SELECT i.category, CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END AS progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) AS subquery GROUP BY category;"
        }
      ],
      "predictedSql": "SELECT category, CAST(SUM(CASE WHEN progress >= 1.0 THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(*) AS percentage_completed FROM (SELECT i.category, CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END AS progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) AS subquery GROUP BY category;",
      "executionTimeMs": 3488,
      "goldSql": "WITH InitiativeKRStatus AS (SELECT i.id AS initiative_id, i.category, CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END AS kr_is_concluded FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT category, CAST(SUM(kr_is_concluded) AS FLOAT) * 100 / COUNT(*) AS percent_krs_concluded FROM InitiativeKRStatus GROUP BY category ORDER BY percent_krs_concluded DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.9321616036191638,
      "finalSql": "SELECT category, CAST(SUM(CASE WHEN progress >= 1.0 THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(*) AS percentage_completed FROM (SELECT i.category, CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END AS progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) AS subquery GROUP BY category;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7160808018095819
    },
    {
      "question": "Quais iniciativas estão com maior prioridade, mas apresentam baixo progresso ou atualizações atrasadas?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.priority, i.end_date, COALESCE(MAX(iu.created_date), i.created_date) AS last_update_date, (SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) FROM kr k WHERE k.okr_id IN (SELECT id FROM okr WHERE initiative_id = i.id)) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority, i.end_date HAVING COALESCE(MAX(iu.created_date), i.created_date) < NOW() - INTERVAL '30 days' OR (SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) FROM kr k WHERE k.okr_id IN (SELECT id FROM okr WHERE initiative_id = i.id)) < 0.5 ORDER BY i.priority DESC, last_update_date ASC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.priority, i.end_date, COALESCE(MAX(iu.created_date), i.created_date) AS last_update_date, (SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) FROM kr k WHERE k.okr_id IN (SELECT id FROM okr WHERE initiative_id = i.id)) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority, i.end_date HAVING COALESCE(MAX(iu.created_date), i.created_date) < NOW() - INTERVAL '30 days' OR (SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) FROM kr k WHERE k.okr_id IN (SELECT id FROM okr WHERE initiative_id = i.id)) < 0.5 ORDER BY i.priority DESC, last_update_date ASC;",
      "executionTimeMs": 3766,
      "goldSql": "WITH InitiativePerformance AS (SELECT i.id AS initiative_id, i.title, i.priority, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS avg_okr_progress, (SELECT MAX(created_date) FROM initiative_update iu WHERE iu.initiative_id = i.id) AS last_update_date FROM initiative i) SELECT title, priority, avg_okr_progress, last_update_date FROM InitiativePerformance WHERE priority = 1 AND (avg_okr_progress < 0.5 OR last_update_date < NOW() - INTERVAL '30 days' OR last_update_date IS NULL) ORDER BY avg_okr_progress ASC NULLS FIRST, last_update_date ASC NULLS FIRST;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8669447401164846,
      "finalSql": "SELECT i.title AS initiative_title, i.priority, i.end_date, COALESCE(MAX(iu.created_date), i.created_date) AS last_update_date, (SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) FROM kr k WHERE k.okr_id IN (SELECT id FROM okr WHERE initiative_id = i.id)) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority, i.end_date HAVING COALESCE(MAX(iu.created_date), i.created_date) < NOW() - INTERVAL '30 days' OR (SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) FROM kr k WHERE k.okr_id IN (SELECT id FROM okr WHERE initiative_id = i.id)) < 0.5 ORDER BY i.priority DESC, last_update_date ASC;",
      "executionMatch": false,
      "tableSimilarity": 0.65,
      "queryAffinityScore": 0.7584723700582423
    },
    {
      "question": "Quais KRs estão com direção “NEGATIVA” (indicando desempenho decrescente) e estão abaixo de 50% do target?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT id, title, metric, direction, progress, target FROM kr WHERE direction = 'down' AND (progress / NULLIF(target, 0)) < 0.5;"
        }
      ],
      "predictedSql": "SELECT id, title, metric, direction, progress, target FROM kr WHERE direction = 'down' AND (progress / NULLIF(target, 0)) < 0.5;",
      "executionTimeMs": 2491,
      "goldSql": "SELECT title, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / NULLIF(target,0)) < 0.5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9551258734507533,
      "finalSql": "SELECT id, title, metric, direction, progress, target FROM kr WHERE direction = 'down' AND (progress / NULLIF(target, 0)) < 0.5;",
      "executionMatch": false,
      "tableSimilarity": 0.6666666666666667,
      "queryAffinityScore": 0.81089627005871
    },
    {
      "question": "Quais iniciativas apresentaram maior variação positiva de progresso nos últimos ciclos de atualização?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "{ \"sql\": \"WITH InitiativeProgress AS (\\n SELECT\\n iu.initiative_id,\\n iu.year_month,\\n MAX(CASE\\n WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0)\\n WHEN k.direction = 'down' THEN (krh.target::numeric - krh.progress) / NULLIF(krh.target, 0) -- Ajuste para 'down'\\n ELSE 0\\n END) AS latest_kr_progress\\n FROM\\n initiative_update iu\\n JOIN\\n kr_history krh ON iu.initiative_id = krh.kr_id -- Assumindo que kr_history está ligado a KR, e KR a OKR, e OKR a Initiative\\n JOIN\\n kr k ON krh.kr_id = k.id\\n GROUP BY\\n iu.initiative_id, iu.year_month\\n),\\nRankedProgress AS (\\n SELECT\\n initiative_id,\\n year_month,\\n latest_kr_progress,\\n LAG(latest_kr_progress, 1, 0) OVER (PARTITION BY initiative_id ORDER BY year_month) AS previous_kr_progress\\n FROM\\n InitiativeProgress\\n)\\nSELECT\\n i.title AS initiative_title,\\n rp.year_month,\\n (rp.latest_kr_progress - rp.previous_kr_progress) AS progress_variation\\nFROM\\n RankedProgress rp\\nJOIN\\n initiative i ON rp.initiative_id = i.id\\nWHERE\\n (rp.latest_kr_progress - rp.previous_kr_progress) > 0\\nORDER BY\\n progress_variation DESC;\\n\", \"complementaryText\": \"Esta query identifica iniciativas com a maior variação positiva de progresso entre ciclos de atualização. Ela calcula o progresso de cada KR (ajustando para direções 'up' e 'down'), rastreia as mudanças ao longo do tempo e retorna as iniciativas com as maiores variações positivas, juntamente com o mês/ano da atualização e",
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH InitiativeProgress AS (\\n SELECT\\n iu.initiative_id,\\n iu.year_month,\\n MAX(CASE\\n WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0)\\n WHEN k.direction = 'down' THEN (krh.target::numeric - krh.progress) / NULLIF(krh.target, 0)\\n ELSE 0\\n END) AS latest_kr_progress\\n FROM\\n initiative_update iu\\n JOIN\\n okr o ON iu.initiative_id = o.initiative_id\\n JOIN\\n kr k ON o.id = k.okr_id\\n JOIN\\n kr_history krh ON k.id = krh.kr_id\\n GROUP BY\\n iu.initiative_id, iu.year_month\\n),\\nRankedProgress AS (\\n SELECT\\n initiative_id,\\n year_month,\\n latest_kr_progress,\\n LAG(latest_kr_progress, 1, 0) OVER (PARTITION BY initiative_id ORDER BY year_month) AS previous_kr_progress\\n FROM\\n InitiativeProgress\\n)\\nSELECT\\n i.title AS initiative_title,\\n rp.year_month,\\n (rp.latest_kr_progress - rp.previous_kr_progress) AS progress_variation\\nFROM\\n RankedProgress rp\\nJOIN\\n initiative i ON rp.initiative_id = i.id\\nWHERE\\n (rp.latest_kr_progress - rp.previous_kr_progress) > 0\\nORDER BY\\n progress_variation DESC;\", \"explanation\": \"O erro 'syntax error at or near \\\"{\\\"' indica que a query SQL foi passada para o analisador com caracteres JSON extras. Removi os caracteres JSON externos que envolviam a string SQL. Além disso, a lógica de JOIN entre `initiative_update` e `kr_history` estava incorreta. `initiative_update` está diretamente ligada a `initiative`, e `kr_history` está ligada",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"WITH InitiativeProgress AS (\\n SELECT\\n iu.initiative_id,\\n iu.year_month,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0)\\n WHEN k.direction = 'down' THEN (krh.target::numeric - krh.progress) / NULLIF(krh.target, 0)\\n ELSE 0\\n END) AS avg_kr_progress_for_update\\n FROM\\n initiative_update iu\\n JOIN\\n okr o ON iu.initiative_id = o.initiative_id\\n JOIN\\n kr k ON o.id = k.okr_id\\n JOIN\\n kr_history krh ON k.id = krh.kr_id AND krh.date::date <= iu.created_date::date -- Assuming krh.date is relevant to the update's creation date\\n GROUP BY\\n iu.initiative_id, iu.year_month, iu.created_date -- Added created_date to ensure unique update cycles if year_month is not unique enough\\n),\\nRankedProgress AS (\\n SELECT\\n initiative_id,\\n year_month,\\n avg_kr_progress_for_update,\\n LAG(avg_kr_progress_for_update, 1, 0) OVER (PARTITION BY initiative_id ORDER BY year_month) AS previous_kr_progress\\n FROM\\n InitiativeProgress\\n)\\nSELECT\\n i.title AS initiative_title,\\n rp.year_month,\\n (rp.avg_kr_progress_for_update - rp.previous_kr_progress) AS progress_variation\\nFROM\\n RankedProgress rp\\nJOIN\\n initiative i ON rp.initiative_id = i.id\\nWHERE\\n (rp.avg_kr_progress_for_update - rp.previous_kr_progress) > 0\\nORDER BY\\n progress_variation DESC;\", \"explanation\": \"O erro 'syntax error at or near \\\"{\\\"'",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "{ \"sql\": \"WITH InitiativeProgress AS (\\n SELECT\\n iu.initiative_id,\\n iu.year_month,\\n MAX(CASE\\n WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0)\\n WHEN k.direction = 'down' THEN (krh.target::numeric - krh.progress) / NULLIF(krh.target, 0) -- Ajuste para 'down'\\n ELSE 0\\n END) AS latest_kr_progress\\n FROM\\n initiative_update iu\\n JOIN\\n kr_history krh ON iu.initiative_id = krh.kr_id -- Assumindo que kr_history está ligado a KR, e KR a OKR, e OKR a Initiative\\n JOIN\\n kr k ON krh.kr_id = k.id\\n GROUP BY\\n iu.initiative_id, iu.year_month\\n),\\nRankedProgress AS (\\n SELECT\\n initiative_id,\\n year_month,\\n latest_kr_progress,\\n LAG(latest_kr_progress, 1, 0) OVER (PARTITION BY initiative_id ORDER BY year_month) AS previous_kr_progress\\n FROM\\n InitiativeProgress\\n)\\nSELECT\\n i.title AS initiative_title,\\n rp.year_month,\\n (rp.latest_kr_progress - rp.previous_kr_progress) AS progress_variation\\nFROM\\n RankedProgress rp\\nJOIN\\n initiative i ON rp.initiative_id = i.id\\nWHERE\\n (rp.latest_kr_progress - rp.previous_kr_progress) > 0\\nORDER BY\\n progress_variation DESC;\\n\", \"complementaryText\": \"Esta query identifica iniciativas com a maior variação positiva de progresso entre ciclos de atualização. Ela calcula o progresso de cada KR (ajustando para direções 'up' e 'down'), rastreia as mudanças ao longo do tempo e retorna as iniciativas com as maiores variações positivas, juntamente com o mês/ano da atualização e",
      "executionTimeMs": 4684,
      "goldSql": "WITH NormHist AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh), Changes AS (SELECT nh.kr_id, nh.date, nh.norm_prog, nh.norm_prog - LAG(nh.norm_prog) OVER (PARTITION BY nh.kr_id ORDER BY nh.date) AS delta FROM NormHist nh), PosChanges AS (SELECT o.initiative_id, CASE WHEN k.direction = 'up'   AND delta > 0 THEN delta WHEN k.direction = 'down' AND delta < 0 THEN -delta END AS norm_delta FROM Changes c JOIN kr k ON c.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE delta IS NOT NULL AND c.date >= NOW() - INTERVAL '6 month' AND ((k.direction='up' AND delta > 0) OR (k.direction='down' AND delta < 0))) SELECT i.title, AVG(pc.norm_delta) AS avg_positive_change FROM initiative i JOIN PosChanges pc ON i.id = pc.initiative_id GROUP BY i.id, i.title ORDER BY avg_positive_change DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.6589956245686271,
      "finalSql": "{ \"sql\": \"WITH InitiativeProgress AS (\\n SELECT\\n iu.initiative_id,\\n iu.year_month,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN krh.progress::numeric / NULLIF(krh.target, 0)\\n WHEN k.direction = 'down' THEN (krh.target::numeric - krh.progress) / NULLIF(krh.target, 0)\\n ELSE 0\\n END) AS avg_kr_progress_for_update\\n FROM\\n initiative_update iu\\n JOIN\\n okr o ON iu.initiative_id = o.initiative_id\\n JOIN\\n kr k ON o.id = k.okr_id\\n JOIN\\n kr_history krh ON k.id = krh.kr_id AND krh.date::date <= iu.created_date::date -- Assuming krh.date is relevant to the update's creation date\\n GROUP BY\\n iu.initiative_id, iu.year_month, iu.created_date -- Added created_date to ensure unique update cycles if year_month is not unique enough\\n),\\nRankedProgress AS (\\n SELECT\\n initiative_id,\\n year_month,\\n avg_kr_progress_for_update,\\n LAG(avg_kr_progress_for_update, 1, 0) OVER (PARTITION BY initiative_id ORDER BY year_month) AS previous_kr_progress\\n FROM\\n InitiativeProgress\\n)\\nSELECT\\n i.title AS initiative_title,\\n rp.year_month,\\n (rp.avg_kr_progress_for_update - rp.previous_kr_progress) AS progress_variation\\nFROM\\n RankedProgress rp\\nJOIN\\n initiative i ON rp.initiative_id = i.id\\nWHERE\\n (rp.avg_kr_progress_for_update - rp.previous_kr_progress) > 0\\nORDER BY\\n progress_variation DESC;\", \"explanation\": \"O erro 'syntax error at or near \\\"{\\\"'",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Quais colaboradores foram responsáveis pelos KRs com melhor taxa de atingimento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_achievement_rate FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY average_achievement_rate DESC;"
        }
      ],
      "predictedSql": "SELECT c.name, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_achievement_rate FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY average_achievement_rate DESC;",
      "executionTimeMs": 2986,
      "goldSql": "SELECT c.name, AVG(k.progress / k.target) AS avg_achievement_rate FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name HAVING COUNT(DISTINCT k.id) > 1 ORDER BY avg_achievement_rate DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8642828557493251,
      "finalSql": "SELECT c.name, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_achievement_rate FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY average_achievement_rate DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.2542372881355932,
      "queryAffinityScore": 0.5592600719424592
    },
    {
      "question": "Quais colaboradores têm progresso médio de KRs acima da média geral dos colaboradores?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH CollaboratorAvgProgress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_kr_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name), OverallAvgProgress AS (SELECT AVG(avg_kr_progress) AS overall_avg FROM CollaboratorAvgProgress) SELECT cap.collaborator_name, cap.avg_kr_progress FROM CollaboratorAvgProgress cap CROSS JOIN OverallAvgProgress oap WHERE cap.avg_kr_progress > oap.overall_avg ORDER BY cap.avg_kr_progress DESC;"
        }
      ],
      "predictedSql": "WITH CollaboratorAvgProgress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_kr_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name), OverallAvgProgress AS (SELECT AVG(avg_kr_progress) AS overall_avg FROM CollaboratorAvgProgress) SELECT cap.collaborator_name, cap.avg_kr_progress FROM CollaboratorAvgProgress cap CROSS JOIN OverallAvgProgress oap WHERE cap.avg_kr_progress > oap.overall_avg ORDER BY cap.avg_kr_progress DESC;",
      "executionTimeMs": 3441,
      "goldSql": "WITH CollaboratorAvg AS (SELECT kh.collaborator_id, AVG(kh.progress / NULLIF(kh.target,0)) AS collaborator_progress FROM kr_history kh GROUP BY kh.collaborator_id), GlobalAvg AS (SELECT AVG(progress / NULLIF(target,0)) AS global_progress FROM kr_history) SELECT c.name, ca.collaborator_progress FROM collaborator c JOIN CollaboratorAvg ca ON c.id = ca.collaborator_id CROSS JOIN GlobalAvg ga WHERE ca.collaborator_progress > ga.global_progress ORDER BY ca.collaborator_progress DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8670134131338862,
      "finalSql": "WITH CollaboratorAvgProgress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_kr_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name), OverallAvgProgress AS (SELECT AVG(avg_kr_progress) AS overall_avg FROM CollaboratorAvgProgress) SELECT cap.collaborator_name, cap.avg_kr_progress FROM CollaboratorAvgProgress cap CROSS JOIN OverallAvgProgress oap WHERE cap.avg_kr_progress > oap.overall_avg ORDER BY cap.avg_kr_progress DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.40625,
      "queryAffinityScore": 0.6366317065669431
    },
    {
      "question": "Quais colaboradores possuem mais KRs “bookmarked” do que a média geral de bookmarks por colaborador?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH UserBookmarkCounts AS (SELECT bookmarked_by_id AS collaborator_id, COUNT(*) AS bookmark_count FROM kr WHERE bookmarked = TRUE GROUP BY bookmarked_by_id), AverageBookmarkCount AS (SELECT AVG(bookmark_count) AS avg_bookmarks FROM UserBookmarkCounts) SELECT c.name, ubc.bookmark_count FROM collaborator c JOIN UserBookmarkCounts ubc ON c.id = ubc.collaborator_id CROSS JOIN AverageBookmarkCount abc WHERE ubc.bookmark_count > abc.avg_bookmarks ORDER BY ubc.bookmark_count DESC;"
        }
      ],
      "predictedSql": "WITH UserBookmarkCounts AS (SELECT bookmarked_by_id AS collaborator_id, COUNT(*) AS bookmark_count FROM kr WHERE bookmarked = TRUE GROUP BY bookmarked_by_id), AverageBookmarkCount AS (SELECT AVG(bookmark_count) AS avg_bookmarks FROM UserBookmarkCounts) SELECT c.name, ubc.bookmark_count FROM collaborator c JOIN UserBookmarkCounts ubc ON c.id = ubc.collaborator_id CROSS JOIN AverageBookmarkCount abc WHERE ubc.bookmark_count > abc.avg_bookmarks ORDER BY ubc.bookmark_count DESC;",
      "executionTimeMs": 3216,
      "goldSql": "WITH BookmarkCount AS ( SELECT bookmarked_by_id, COUNT(id) AS total_bookmarks FROM kr WHERE bookmarked_by_id IS NOT NULL GROUP BY bookmarked_by_id ), AvgBookmarks AS ( SELECT AVG(total_bookmarks) AS global_avg FROM BookmarkCount ) SELECT c.name, bc.total_bookmarks FROM collaborator c JOIN BookmarkCount bc ON c.id = bc.bookmarked_by_id CROSS JOIN AvgBookmarks ab WHERE bc.total_bookmarks > ab.global_avg ORDER BY bc.total_bookmarks DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.92893604036945,
      "finalSql": "WITH UserBookmarkCounts AS (SELECT bookmarked_by_id AS collaborator_id, COUNT(*) AS bookmark_count FROM kr WHERE bookmarked = TRUE GROUP BY bookmarked_by_id), AverageBookmarkCount AS (SELECT AVG(bookmark_count) AS avg_bookmarks FROM UserBookmarkCounts) SELECT c.name, ubc.bookmark_count FROM collaborator c JOIN UserBookmarkCounts ubc ON c.id = ubc.collaborator_id CROSS JOIN AverageBookmarkCount abc WHERE ubc.bookmark_count > abc.avg_bookmarks ORDER BY ubc.bookmark_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.38235294117647056,
      "queryAffinityScore": 0.6556444907729603
    },
    {
      "question": "Gerar o ranking de colaboradores com maior média de progresso em KRs dentro de cada categoria de iniciativa.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, c.name, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN kh.target::numeric / NULLIF(kh.progress, 0) ELSE 0 END) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN kh.target::numeric / NULLIF(kh.progress, 0) ELSE 0 END) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;"
        }
      ],
      "predictedSql": "SELECT i.category, c.name, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN kh.target::numeric / NULLIF(kh.progress, 0) ELSE 0 END) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN kh.target::numeric / NULLIF(kh.progress, 0) ELSE 0 END) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;",
      "executionTimeMs": 3358,
      "goldSql": "SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9365834677964604,
      "finalSql": "SELECT i.category, c.name, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN kh.target::numeric / NULLIF(kh.progress, 0) ELSE 0 END) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN kh.target::numeric / NULLIF(kh.progress, 0) ELSE 0 END) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;",
      "executionMatch": false,
      "tableSimilarity": 0.7787610619469026,
      "queryAffinityScore": 0.8576722648716815
    },
    {
      "question": "Selecionar colaboradores que contribuíram para KRs com progresso superior ao percentil 90 global.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH KRProgress AS (SELECT kh.collaborator_id, CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END AS calculated_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), Percentile90 AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM KRProgress) SELECT DISTINCT c.name, c.email FROM collaborator c JOIN KRProgress kp ON c.id = kp.collaborator_id WHERE kp.calculated_progress > (SELECT p90_value FROM Percentile90);"
        }
      ],
      "predictedSql": "WITH KRProgress AS (SELECT kh.collaborator_id, CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END AS calculated_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), Percentile90 AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM KRProgress) SELECT DISTINCT c.name, c.email FROM collaborator c JOIN KRProgress kp ON c.id = kp.collaborator_id WHERE kp.calculated_progress > (SELECT p90_value FROM Percentile90);",
      "executionTimeMs": 3311,
      "goldSql": "WITH GlobalPercentile AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (progress / NULLIF(target,0))) AS p90_progress FROM kr_history) SELECT DISTINCT c.name FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id CROSS JOIN GlobalPercentile gp WHERE (kh.progress / NULLIF(kh.target,0)) > gp.p90_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8198558643122471,
      "finalSql": "WITH KRProgress AS (SELECT kh.collaborator_id, CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END AS calculated_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), Percentile90 AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM KRProgress) SELECT DISTINCT c.name, c.email FROM collaborator c JOIN KRProgress kp ON c.id = kp.collaborator_id WHERE kp.calculated_progress > (SELECT p90_value FROM Percentile90);",
      "executionMatch": false,
      "tableSimilarity": 0.4782608695652174,
      "queryAffinityScore": 0.6490583669387322
    },
    {
      "question": "Como evoluiu o progresso médio dos KRs nos últimos 6 meses?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT TO_CHAR(date_trunc('month', date), 'YYYY-MM') AS month, AVG(CASE WHEN direction = 'up' THEN progress :: NUMERIC / NULLIF(target, 0) WHEN direction = 'down' THEN 1 - (progress :: NUMERIC / NULLIF(target, 0)) ELSE NULL END) AS average_progress FROM kr_history WHERE date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;"
        }
      ],
      "predictedSql": "SELECT TO_CHAR(date_trunc('month', date), 'YYYY-MM') AS month, AVG(CASE WHEN direction = 'up' THEN progress :: NUMERIC / NULLIF(target, 0) WHEN direction = 'down' THEN 1 - (progress :: NUMERIC / NULLIF(target, 0)) ELSE NULL END) AS average_progress FROM kr_history WHERE date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;",
      "executionTimeMs": 3155,
      "goldSql": "SELECT DATE_TRUNC('month', date) AS month_start, AVG(progress / NULLIF(target,0)) AS avg_monthly_progress FROM kr_history WHERE date >= DATE_TRUNC('month', NOW() - INTERVAL '6 month') AND date <= NOW() GROUP BY month_start ORDER BY month_start;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.902664566620194,
      "finalSql": "SELECT TO_CHAR(date_trunc('month', date), 'YYYY-MM') AS month, AVG(CASE WHEN direction = 'up' THEN progress :: NUMERIC / NULLIF(target, 0) WHEN direction = 'down' THEN 1 - (progress :: NUMERIC / NULLIF(target, 0)) ELSE NULL END) AS average_progress FROM kr_history WHERE date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.451332283310097
    },
    {
      "question": "Qual foi a variação de progresso por colaborador no último trimestre?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH MonthlyProgress AS (SELECT c.name AS collaborator_name, kr.title AS kr_title, EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, kh.progress AS current_progress, kh.target AS kr_target, kr.direction AS kr_direction FROM collaborator AS c JOIN kr_history AS kh ON c.id = kh.collaborator_id JOIN kr AS kr ON kh.kr_id = kr.id WHERE kh.date >= NOW() - INTERVAL '3 months' AND kh.date <= NOW()), CalculatedProgress AS (SELECT collaborator_name, kr_title, year, month, CASE WHEN kr_direction = 'up' THEN current_progress::numeric / NULLIF(kr_target, 0) WHEN kr_direction = 'down' THEN (kr_target - current_progress)::numeric / NULLIF(kr_target, 0) ELSE 0 END AS progress_ratio FROM MonthlyProgress), FirstLastProgress AS (SELECT collaborator_name, kr_title, FIRST_VALUE(progress_ratio) OVER (PARTITION BY collaborator_name, kr_title ORDER BY year, month) AS first_progress, LAST_VALUE(progress_ratio) OVER (PARTITION BY collaborator_name, kr_title ORDER BY year, month ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_progress FROM CalculatedProgress) SELECT collaborator_name, kr_title, first_progress, last_progress, (last_progress - first_progress) AS progress_variation FROM FirstLastProgress GROUP BY collaborator_name, kr_title, first_progress, last_progress ORDER BY collaborator_name, kr_title;"
        }
      ],
      "predictedSql": "WITH MonthlyProgress AS (SELECT c.name AS collaborator_name, kr.title AS kr_title, EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, kh.progress AS current_progress, kh.target AS kr_target, kr.direction AS kr_direction FROM collaborator AS c JOIN kr_history AS kh ON c.id = kh.collaborator_id JOIN kr AS kr ON kh.kr_id = kr.id WHERE kh.date >= NOW() - INTERVAL '3 months' AND kh.date <= NOW()), CalculatedProgress AS (SELECT collaborator_name, kr_title, year, month, CASE WHEN kr_direction = 'up' THEN current_progress::numeric / NULLIF(kr_target, 0) WHEN kr_direction = 'down' THEN (kr_target - current_progress)::numeric / NULLIF(kr_target, 0) ELSE 0 END AS progress_ratio FROM MonthlyProgress), FirstLastProgress AS (SELECT collaborator_name, kr_title, FIRST_VALUE(progress_ratio) OVER (PARTITION BY collaborator_name, kr_title ORDER BY year, month) AS first_progress, LAST_VALUE(progress_ratio) OVER (PARTITION BY collaborator_name, kr_title ORDER BY year, month ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_progress FROM CalculatedProgress) SELECT collaborator_name, kr_title, first_progress, last_progress, (last_progress - first_progress) AS progress_variation FROM FirstLastProgress GROUP BY collaborator_name, kr_title, first_progress, last_progress ORDER BY collaborator_name, kr_title;",
      "executionTimeMs": 4106,
      "goldSql": "WITH Hist AS (SELECT kh.collaborator_id, kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '3 month'), Ranked AS (SELECT collaborator_id, kr_id, norm_prog, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date ASC) AS rn_first, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date DESC) AS rn_last FROM Hist), FirstLast AS (SELECT collaborator_id, kr_id, MAX(CASE WHEN rn_first = 1 THEN norm_prog END) AS first_prog, MAX(CASE WHEN rn_last = 1 THEN norm_prog END) AS last_prog FROM Ranked GROUP BY collaborator_id, kr_id) SELECT c.name, AVG(last_prog - first_prog) AS progress_change_qtr FROM collaborator c JOIN FirstLast fl ON c.id = fl.collaborator_id GROUP BY c.id, c.name ORDER BY progress_change_qtr DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8008562482081723,
      "finalSql": "WITH MonthlyProgress AS (SELECT c.name AS collaborator_name, kr.title AS kr_title, EXTRACT(YEAR FROM kh.date) AS year, EXTRACT(MONTH FROM kh.date) AS month, kh.progress AS current_progress, kh.target AS kr_target, kr.direction AS kr_direction FROM collaborator AS c JOIN kr_history AS kh ON c.id = kh.collaborator_id JOIN kr AS kr ON kh.kr_id = kr.id WHERE kh.date >= NOW() - INTERVAL '3 months' AND kh.date <= NOW()), CalculatedProgress AS (SELECT collaborator_name, kr_title, year, month, CASE WHEN kr_direction = 'up' THEN current_progress::numeric / NULLIF(kr_target, 0) WHEN kr_direction = 'down' THEN (kr_target - current_progress)::numeric / NULLIF(kr_target, 0) ELSE 0 END AS progress_ratio FROM MonthlyProgress), FirstLastProgress AS (SELECT collaborator_name, kr_title, FIRST_VALUE(progress_ratio) OVER (PARTITION BY collaborator_name, kr_title ORDER BY year, month) AS first_progress, LAST_VALUE(progress_ratio) OVER (PARTITION BY collaborator_name, kr_title ORDER BY year, month ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_progress FROM CalculatedProgress) SELECT collaborator_name, kr_title, first_progress, last_progress, (last_progress - first_progress) AS progress_variation FROM FirstLastProgress GROUP BY collaborator_name, kr_title, first_progress, last_progress ORDER BY collaborator_name, kr_title;",
      "executionMatch": false,
      "tableSimilarity": 0.04873949579831938,
      "queryAffinityScore": 0.4247978720032458
    },
    {
      "question": "Quantos registros de histórico de KR foram criados no último mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month';"
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month';",
      "executionTimeMs": 2537,
      "goldSql": "SELECT COUNT(id) AS history_count_last_month FROM kr_history WHERE date >= NOW() - INTERVAL '1' MONTH;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9372939992692947,
      "finalSql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month';",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9686469996346474
    },
    {
      "question": "Quais KRs apresentaram regressão de progresso em algum momento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT k.title FROM kr k JOIN kr_history kh1 ON k.id = kh1.kr_id JOIN kr_history kh2 ON k.id = kh2.kr_id WHERE kh1.date < kh2.date AND kh1.progress > kh2.progress AND k.direction = 'up' OR kh1.date < kh2.date AND kh1.progress < kh2.progress AND k.direction = 'down';"
        }
      ],
      "predictedSql": "SELECT DISTINCT k.title FROM kr k JOIN kr_history kh1 ON k.id = kh1.kr_id JOIN kr_history kh2 ON k.id = kh2.kr_id WHERE kh1.date < kh2.date AND kh1.progress > kh2.progress AND k.direction = 'up' OR kh1.date < kh2.date AND kh1.progress < kh2.progress AND k.direction = 'down';",
      "executionTimeMs": 2943,
      "goldSql": "WITH Regressions AS (SELECT kr_id, (progress / NULLIF(target,0)) AS norm_progress, LAG(progress / NULLIF(target,0)) OVER (PARTITION BY kr_id ORDER BY date) AS prev_norm_progress FROM kr_history) SELECT DISTINCT k.title FROM kr k JOIN Regressions r ON k.id = r.kr_id WHERE r.norm_progress < r.prev_norm_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.6475729693149807,
      "finalSql": "SELECT DISTINCT k.title FROM kr k JOIN kr_history kh1 ON k.id = kh1.kr_id JOIN kr_history kh2 ON k.id = kh2.kr_id WHERE kh1.date < kh2.date AND kh1.progress > kh2.progress AND k.direction = 'up' OR kh1.date < kh2.date AND kh1.progress < kh2.progress AND k.direction = 'down';",
      "executionMatch": false,
      "tableSimilarity": 0.9217391304347826,
      "queryAffinityScore": 0.7846560498748816
    },
    {
      "question": "Qual a média de variação percentual de progresso por métrica (PERC, NUMERIC, YES_NO)?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.metric, AVG(CASE WHEN k.direction = 'up' THEN (kh.progress - LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date)) * 100.0 / NULLIF(LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date), 0) WHEN k.direction = 'down' THEN (LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) - kh.progress) * 100.0 / NULLIF(LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date), 0) ELSE 0 END) AS average_percentage_change FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.metric;",
          "error": "aggregate function calls cannot contain window function calls"
        },
        {
          "attempt": 2,
          "sql": "WITH KrProgressChanges AS ( SELECT kh.kr_id, k.metric, kh.progress, kh.date, LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS previous_progress, k.direction FROM kr_history kh JOIN kr k ON kh.kr_id = k.id ) SELECT kpc.metric, AVG(CASE WHEN kpc.direction = 'up' THEN (kpc.progress - kpc.previous_progress) * 100.0 / NULLIF(kpc.previous_progress, 0) WHEN kpc.direction = 'down' THEN (kpc.previous_progress - kpc.progress) * 100.0 / NULLIF(kpc.previous_progress, 0) ELSE 0 END) AS average_percentage_change FROM KrProgressChanges kpc WHERE kpc.progress != kpc.previous_progress -- Excluir casos onde não houve mudança para evitar divisões por zero desnecessárias ou mudanças de 0% GROUP BY kpc.metric;",
          "fixed": true,
          "error": "column \"kpc.metric\" must appear in the GROUP BY clause or be used in an aggregate function"
        },
        {
          "attempt": 3,
          "sql": "WITH KrProgressChanges AS ( SELECT kh.kr_id, k.metric, kh.progress, kh.date, LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS previous_progress, k.direction FROM kr_history kh JOIN kr k ON kh.kr_id = k.id ) SELECT kpc.metric, AVG(CASE WHEN kpc.direction = 'up' THEN (kpc.progress - kpc.previous_progress) * 100.0 / NULLIF(kpc.previous_progress, 0) WHEN kpc.direction = 'down' THEN (kpc.previous_progress - kpc.progress) * 100.0 / NULLIF(kpc.previous_progress, 0) ELSE 0 END) AS average_percentage_change FROM KrProgressChanges kpc WHERE kpc.progress != kpc.previous_progress GROUP BY kpc.metric;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT k.metric, AVG(CASE WHEN k.direction = 'up' THEN (kh.progress - LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date)) * 100.0 / NULLIF(LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date), 0) WHEN k.direction = 'down' THEN (LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) - kh.progress) * 100.0 / NULLIF(LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date), 0) ELSE 0 END) AS average_percentage_change FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY k.metric;",
      "executionTimeMs": 3633,
      "goldSql": "WITH ranked_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog, k.metric, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_norm_prog FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), progress_changes AS (SELECT metric, ABS(norm_prog - prev_norm_prog) / NULLIF(prev_norm_prog, 0) * 100 AS variation_percent FROM ranked_history WHERE prev_norm_prog IS NOT NULL) SELECT metric, AVG(variation_percent) AS avg_variation_percent FROM progress_changes GROUP BY metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8620857826640137,
      "finalSql": "WITH KrProgressChanges AS ( SELECT kh.kr_id, k.metric, kh.progress, kh.date, LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS previous_progress, k.direction FROM kr_history kh JOIN kr k ON kh.kr_id = k.id ) SELECT kpc.metric, AVG(CASE WHEN kpc.direction = 'up' THEN (kpc.progress - kpc.previous_progress) * 100.0 / NULLIF(kpc.previous_progress, 0) WHEN kpc.direction = 'down' THEN (kpc.previous_progress - kpc.progress) * 100.0 / NULLIF(kpc.previous_progress, 0) ELSE 0 END) AS average_percentage_change FROM KrProgressChanges kpc WHERE kpc.progress != kpc.previous_progress GROUP BY kpc.metric;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.6810428913320068
    },
    {
      "question": "Quantos KRs tiveram histórico de progresso acima de 90% antes do prazo final?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(DISTINCT T1.kr_id) FROM kr_history AS T1 JOIN kr AS T2 ON T1.kr_id = T2.id WHERE (CASE WHEN T2.direction = 'up' THEN T1.progress * 1.0 / T1.target WHEN T2.direction = 'down' THEN T1.target * 1.0 / T1.progress ELSE NULL END) > 0.9 AND T1.date < (SELECT deadline FROM okr WHERE id = T2.okr_id)",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT COUNT(DISTINCT kh.kr_id) FROM kr_history AS kh JOIN kr AS k ON kh.kr_id = k.id JOIN okr AS o ON k.okr_id = o.id WHERE ( CASE WHEN k.direction = 'up' AND k.target <> 0 THEN kh.progress * 1.0 / k.target WHEN k.direction = 'down' AND kh.progress <> 0 THEN k.target * 1.0 / kh.progress ELSE NULL END ) > 0.9 AND kh.date < o.deadline;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT COUNT(DISTINCT T1.kr_id) FROM kr_history AS T1 JOIN kr AS T2 ON T1.kr_id = T2.id WHERE (CASE WHEN T2.direction = 'up' THEN T1.progress * 1.0 / T1.target WHEN T2.direction = 'down' THEN T1.target * 1.0 / T1.progress ELSE NULL END) > 0.9 AND T1.date < (SELECT deadline FROM okr WHERE id = T2.okr_id)",
      "executionTimeMs": 2787,
      "goldSql": "SELECT COUNT(DISTINCT kh.kr_id) as krs_acima_90 FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE (kh.progress/k.target)*100 >= 90 AND kh.date < o.deadline;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.7930542626837143,
      "finalSql": "SELECT COUNT(DISTINCT kh.kr_id) FROM kr_history AS kh JOIN kr AS k ON kh.kr_id = k.id JOIN okr AS o ON k.okr_id = o.id WHERE ( CASE WHEN k.direction = 'up' AND k.target <> 0 THEN kh.progress * 1.0 / k.target WHEN k.direction = 'down' AND kh.progress <> 0 THEN k.target * 1.0 / kh.progress ELSE NULL END ) > 0.9 AND kh.date < o.deadline;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.39652713134185713
    },
    {
      "question": "Quais colaboradores atualizaram o maior número de KRs no histórico?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, COUNT(kh.kr_id) AS total_krs_updated FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.name ORDER BY total_krs_updated DESC;"
        }
      ],
      "predictedSql": "SELECT c.name, COUNT(kh.kr_id) AS total_krs_updated FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.name ORDER BY total_krs_updated DESC;",
      "executionTimeMs": 2835,
      "goldSql": "SELECT c.id, c.name, COUNT(kh.id) as total_atualizacoes FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name ORDER BY total_atualizacoes DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8636491545692427,
      "finalSql": "SELECT c.name, COUNT(kh.kr_id) AS total_krs_updated FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.name ORDER BY total_krs_updated DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.10752688172043001,
      "queryAffinityScore": 0.4855880181448364
    },
    {
      "question": "Quantos updates de iniciativa foram registrados por mês neste ano?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(*) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;"
        }
      ],
      "predictedSql": "SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(*) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;",
      "executionTimeMs": 2660,
      "goldSql": "SELECT EXTRACT(YEAR FROM created_date) as ano, EXTRACT(MONTH FROM created_date) as mes, COUNT(*) as total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY ano, mes ORDER BY ano, mes;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9199857985587402,
      "finalSql": "SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(*) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;",
      "executionMatch": false,
      "tableSimilarity": 0.33333333333333337,
      "queryAffinityScore": 0.6266595659460368
    },
    {
      "question": "Quais iniciativas tiveram maior número de updates em um único mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, TO_CHAR(iu.created_date, 'YYYY-MM') AS month, COUNT(iu.id) AS num_updates FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, TO_CHAR(iu.created_date, 'YYYY-MM') AS month, COUNT(iu.id) AS num_updates FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;",
      "executionTimeMs": 2800,
      "goldSql": "SELECT i.id, i.title, EXTRACT(YEAR FROM iu.created_date) as ano, EXTRACT(MONTH FROM iu.created_date) as mes, COUNT(iu.id) as updates_mes FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title, ano, mes ORDER BY updates_mes DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.9226878882673144,
      "finalSql": "SELECT i.title AS initiative_title, TO_CHAR(iu.created_date, 'YYYY-MM') AS month, COUNT(iu.id) AS num_updates FROM initiative_update iu JOIN initiative i ON iu.initiative_id = i.id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.019999999999999907,
      "queryAffinityScore": 0.47134394413365716
    },
    {
      "question": "Qual o tempo médio entre updates consecutivos de uma mesma iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(diff_in_seconds) AS average_time_between_updates FROM (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) AS diff_in_seconds FROM initiative_update) AS subquery;"
        }
      ],
      "predictedSql": "SELECT AVG(diff_in_seconds) AS average_time_between_updates FROM (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) AS diff_in_seconds FROM initiative_update) AS subquery;",
      "executionTimeMs": 2598,
      "goldSql": "WITH update_gaps AS (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) / 86400 as dias_entre_updates FROM initiative_update) SELECT AVG(dias_entre_updates) as tempo_medio_dias FROM update_gaps WHERE dias_entre_updates IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8677181584359157,
      "finalSql": "SELECT AVG(diff_in_seconds) AS average_time_between_updates FROM (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) AS diff_in_seconds FROM initiative_update) AS subquery;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.43385907921795785
    },
    {
      "question": "Para cada iniciativa, qual é o KR mais recente e seu progresso atual?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH LatestKR AS (SELECT kr.initiative_id, kr.id AS kr_id, kr.title AS kr_title, kr.progress, kr.target, kr.direction, kr.created_date, ROW_NUMBER() OVER (PARTITION BY kr.initiative_id ORDER BY kr.created_date DESC) AS rn FROM kr) SELECT i.title AS initiative_title, lk.kr_title, CASE WHEN lk.direction = 'up' THEN lk.progress / NULLIF(lk.target, 0) WHEN lk.direction = 'down' THEN (lk.target - lk.progress) / NULLIF(lk.target, 0) ELSE NULL END AS current_progress FROM initiative i JOIN LatestKR lk ON i.id = lk.initiative_id WHERE lk.rn = 1;",
          "error": "column kr.initiative_id does not exist"
        },
        {
          "attempt": 2,
          "sql": "WITH LatestKR AS ( SELECT k.id AS kr_id, k.title AS kr_title, k.progress, k.target, k.direction, k.created_date, o.initiative_id, ROW_NUMBER() OVER (PARTITION BY o.initiative_id ORDER BY k.created_date DESC) AS rn FROM kr AS k JOIN okr AS o ON k.okr_id = o.id ) SELECT i.title AS initiative_title, lk.kr_title, CASE WHEN lk.direction = 'up' THEN lk.progress / NULLIF(lk.target, 0) WHEN lk.direction = 'down' THEN (lk.target - lk.progress) / NULLIF(lk.target, 0) ELSE NULL END AS current_progress FROM initiative AS i JOIN LatestKR AS lk ON i.id = lk.initiative_id WHERE lk.rn = 1;",
          "fixed": true
        }
      ],
      "predictedSql": "WITH LatestKR AS (SELECT kr.initiative_id, kr.id AS kr_id, kr.title AS kr_title, kr.progress, kr.target, kr.direction, kr.created_date, ROW_NUMBER() OVER (PARTITION BY kr.initiative_id ORDER BY kr.created_date DESC) AS rn FROM kr) SELECT i.title AS initiative_title, lk.kr_title, CASE WHEN lk.direction = 'up' THEN lk.progress / NULLIF(lk.target, 0) WHEN lk.direction = 'down' THEN (lk.target - lk.progress) / NULLIF(lk.target, 0) ELSE NULL END AS current_progress FROM initiative i JOIN LatestKR lk ON i.id = lk.initiative_id WHERE lk.rn = 1;",
      "executionTimeMs": 3180,
      "goldSql": "WITH ranked_krs AS (SELECT i.id as iniciativa_id, i.title as iniciativa, k.id as kr_id, k.title as kr, k.progress, k.last_modified_date, ROW_NUMBER() OVER (PARTITION BY i.id ORDER BY k.last_modified_date DESC) as rn FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT iniciativa_id, iniciativa, kr_id, kr, progress FROM ranked_krs WHERE rn = 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8359907461572492,
      "finalSql": "WITH LatestKR AS ( SELECT k.id AS kr_id, k.title AS kr_title, k.progress, k.target, k.direction, k.created_date, o.initiative_id, ROW_NUMBER() OVER (PARTITION BY o.initiative_id ORDER BY k.created_date DESC) AS rn FROM kr AS k JOIN okr AS o ON k.okr_id = o.id ) SELECT i.title AS initiative_title, lk.kr_title, CASE WHEN lk.direction = 'up' THEN lk.progress / NULLIF(lk.target, 0) WHEN lk.direction = 'down' THEN (lk.target - lk.progress) / NULLIF(lk.target, 0) ELSE NULL END AS current_progress FROM initiative AS i JOIN LatestKR AS lk ON i.id = lk.initiative_id WHERE lk.rn = 1;",
      "executionMatch": false,
      "tableSimilarity": 0.24782608695652175,
      "queryAffinityScore": 0.5419084165568855
    },
    {
      "question": "Analisar a tendência de redução na frequência de updates conforme o deadline dos OKRs se aproxima.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.deadline AS okr_deadline, iu.created_date AS update_date, EXTRACT(DAY FROM (o.deadline - iu.created_date)) AS days_until_deadline, COUNT(iu.id) OVER (PARTITION BY o.id ORDER BY iu.created_date) AS cumulative_updates FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_update iu ON i.id = iu.initiative_id ORDER BY o.deadline, iu.created_date;"
        }
      ],
      "predictedSql": "SELECT o.deadline AS okr_deadline, iu.created_date AS update_date, EXTRACT(DAY FROM (o.deadline - iu.created_date)) AS days_until_deadline, COUNT(iu.id) OVER (PARTITION BY o.id ORDER BY iu.created_date) AS cumulative_updates FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_update iu ON i.id = iu.initiative_id ORDER BY o.deadline, iu.created_date;",
      "executionTimeMs": 3496,
      "goldSql": "SELECT i.id, i.title, o.deadline, COUNT(iu.id) as total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / 86400) as dias_antes_prazo_medio FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.created_date <= o.deadline GROUP BY i.id, i.title, o.deadline ORDER BY dias_antes_prazo_medio;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.800063447747193,
      "finalSql": "SELECT o.deadline AS okr_deadline, iu.created_date AS update_date, EXTRACT(DAY FROM (o.deadline - iu.created_date)) AS days_until_deadline, COUNT(iu.id) OVER (PARTITION BY o.id ORDER BY iu.created_date) AS cumulative_updates FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_update iu ON i.id = iu.initiative_id ORDER BY o.deadline, iu.created_date;",
      "executionMatch": false,
      "tableSimilarity": 0.028525641025641035,
      "queryAffinityScore": 0.414294544386417
    },
    {
      "question": "Listar KRs com lacunas maiores que 30 dias entre atualizações de progresso",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT kr_id, date AS last_update_date FROM kr_history WHERE (date - LAG(date) OVER (PARTITION BY kr_id ORDER BY date)) > INTERVAL '30 days';",
          "error": "window functions are not allowed in WHERE"
        },
        {
          "attempt": 2,
          "sql": "SELECT kh.kr_id, kh.date AS last_update_date FROM ( SELECT kr_id, date, LAG(date) OVER (PARTITION BY kr_id ORDER BY date) AS previous_date FROM kr_history ) AS kh WHERE kh.date - kh.previous_date > INTERVAL '30 days';",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT kr_id, date AS last_update_date FROM kr_history WHERE (date - LAG(date) OVER (PARTITION BY kr_id ORDER BY date)) > INTERVAL '30 days';",
      "executionTimeMs": 2467,
      "goldSql": "WITH kr_update_gaps AS (SELECT kh.kr_id, k.title as kr_title, kh.date as current_date, LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) as previous_date, EXTRACT(EPOCH FROM (kh.date - LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date))) / 86400 as dias_entre_atualizacoes FROM kr_history kh JOIN kr k ON kh.kr_id = k.id) SELECT kr_id, kr_title, previous_date, current_date, dias_entre_atualizacoes FROM kr_update_gaps WHERE dias_entre_atualizacoes > 30 ORDER BY dias_entre_atualizacoes DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.6684003318089278,
      "finalSql": "SELECT kh.kr_id, kh.date AS last_update_date FROM ( SELECT kr_id, date, LAG(date) OVER (PARTITION BY kr_id ORDER BY date) AS previous_date FROM kr_history ) AS kh WHERE kh.date - kh.previous_date > INTERVAL '30 days';",
      "executionMatch": false,
      "tableSimilarity": 0.21995565410199558,
      "queryAffinityScore": 0.4441779929554617
    },
    {
      "question": "Quais OKRs estão com prazo próximo do vencimento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT id, description, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days';"
        }
      ],
      "predictedSql": "SELECT id, description, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days';",
      "executionTimeMs": 2549,
      "goldSql": "SELECT id, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' ORDER BY deadline ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9325487410638645,
      "finalSql": "SELECT id, description, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days';",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9662743705319323
    },
    {
      "question": "Qual é a média de progresso dos KRs em cada OKR?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT okr.id AS okr_id, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::numeric / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN (kr.target::numeric - kr.progress) / NULLIF(kr.target, 0) ELSE 0 END) AS average_kr_progress FROM kr JOIN okr ON kr.okr_id = okr.id GROUP BY okr.id ORDER BY okr.id;"
        }
      ],
      "predictedSql": "SELECT okr.id AS okr_id, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::numeric / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN (kr.target::numeric - kr.progress) / NULLIF(kr.target, 0) ELSE 0 END) AS average_kr_progress FROM kr JOIN okr ON kr.okr_id = okr.id GROUP BY okr.id ORDER BY okr.id;",
      "executionTimeMs": 3400,
      "goldSql": "SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8607554686127209,
      "finalSql": "SELECT okr.id AS okr_id, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::numeric / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN (kr.target::numeric - kr.progress) / NULLIF(kr.target, 0) ELSE 0 END) AS average_kr_progress FROM kr JOIN okr ON kr.okr_id = okr.id GROUP BY okr.id ORDER BY okr.id;",
      "executionMatch": false,
      "tableSimilarity": 0.7723880597014925,
      "queryAffinityScore": 0.8165717641571066
    },
    {
      "question": "Quais OKRs têm menor progresso médio?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id AS okr_id, o.description AS okr_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY average_progress ASC;"
        }
      ],
      "predictedSql": "SELECT o.id AS okr_id, o.description AS okr_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY average_progress ASC;",
      "executionTimeMs": 2970,
      "goldSql": "SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id ORDER BY avg_progress ASC LIMIT 5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8324309279034808,
      "finalSql": "SELECT o.id AS okr_id, o.description AS okr_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY average_progress ASC;",
      "executionMatch": false,
      "tableSimilarity": 0.02487562189054726,
      "queryAffinityScore": 0.42865327489701405
    },
    {
      "question": "Qual é o percentual de KRs concluídos por iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, CAST(SUM(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(k.id) AS percentage_completed_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.title ORDER BY i.title;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, CAST(SUM(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(k.id) AS percentage_completed_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.title ORDER BY i.title;",
      "executionTimeMs": 3171,
      "goldSql": "SELECT i.id AS initiative_id, SUM(CASE WHEN (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8971063042601403,
      "finalSql": "SELECT i.title AS initiative_title, CAST(SUM(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(k.id) AS percentage_completed_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.title ORDER BY i.title;",
      "executionMatch": false,
      "tableSimilarity": 0.0652173913043479,
      "queryAffinityScore": 0.4811618477822441
    },
    {
      "question": "Qual o tempo médio restante até o deadline dos OKRs ativos?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (o.deadline - NOW()))) / (60 * 60 * 24) AS media_dias_restantes FROM okr o WHERE o.deadline IS NOT NULL AND o.deadline > NOW();"
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (o.deadline - NOW()))) / (60 * 60 * 24) AS media_dias_restantes FROM okr o WHERE o.deadline IS NOT NULL AND o.deadline > NOW();",
      "executionTimeMs": 3341,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - NOW())) / 86400) AS avg_days_remaining FROM okr WHERE deadline > NOW();",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.8639805612147118,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (o.deadline - NOW()))) / (60 * 60 * 24) AS media_dias_restantes FROM okr o WHERE o.deadline IS NOT NULL AND o.deadline > NOW();",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4319902806073559
    },
    {
      "question": "Quais OKRs estão vinculados a iniciativas que já encerraram?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT o.id AS okr_id, o.description AS okr_description FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date < NOW();"
        }
      ],
      "predictedSql": "SELECT DISTINCT o.id AS okr_id, o.description AS okr_description FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date < NOW();",
      "executionTimeMs": 2677,
      "goldSql": "SELECT o.id AS okr_id, o.initiative_id, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL AND i.end_date < NOW();",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.8681474871935944,
      "finalSql": "SELECT DISTINCT o.id AS okr_id, o.description AS okr_description FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date < NOW();",
      "executionMatch": false,
      "tableSimilarity": 0.3431372549019608,
      "queryAffinityScore": 0.6056423710477776
    },
    {
      "question": "Quantos KRs estão atrasados em relação à meta planejada?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(k.id) FROM kr k JOIN okr o ON k.okr_id = o.id WHERE k.progress < k.target AND o.deadline < NOW() AND k.direction = 'up' OR k.progress > k.target AND o.deadline < NOW() AND k.direction = 'down';"
        }
      ],
      "predictedSql": "SELECT COUNT(k.id) FROM kr k JOIN okr o ON k.okr_id = o.id WHERE k.progress < k.target AND o.deadline < NOW() AND k.direction = 'up' OR k.progress > k.target AND o.deadline < NOW() AND k.direction = 'down';",
      "executionTimeMs": 2794,
      "goldSql": "SELECT COUNT(*) AS delayed_kr_count FROM kr k JOIN kr_history kh ON kh.kr_id = k.id AND kh.date = (SELECT MAX(h.date) FROM kr_history h WHERE h.kr_id = k.id) WHERE (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) < 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > 1);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8472935151036536,
      "finalSql": "SELECT COUNT(k.id) FROM kr k JOIN okr o ON k.okr_id = o.id WHERE k.progress < k.target AND o.deadline < NOW() AND k.direction = 'up' OR k.progress > k.target AND o.deadline < NOW() AND k.direction = 'down';",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4236467575518268
    },
    {
      "question": "Qual o progresso médio dos KRs de tipo “PERC” em comparação aos de tipo “NUMERIC”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT CASE WHEN kr.metric = 'PERC' THEN 'Percentual' WHEN kr.metric = 'NUMERIC' THEN 'Numérico' ELSE 'Outro' END AS tipo_kr, AVG( CASE WHEN kr.direction = 'up' THEN kr.progress / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN (kr.target - kr.progress) / NULLIF(kr.target, 0) ELSE NULL END ) AS progresso_medio FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC') GROUP BY tipo_kr;"
        }
      ],
      "predictedSql": "SELECT CASE WHEN kr.metric = 'PERC' THEN 'Percentual' WHEN kr.metric = 'NUMERIC' THEN 'Numérico' ELSE 'Outro' END AS tipo_kr, AVG( CASE WHEN kr.direction = 'up' THEN kr.progress / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN (kr.target - kr.progress) / NULLIF(kr.target, 0) ELSE NULL END ) AS progresso_medio FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC') GROUP BY tipo_kr;",
      "executionTimeMs": 3078,
      "goldSql": "SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.7770616903787142,
      "finalSql": "SELECT CASE WHEN kr.metric = 'PERC' THEN 'Percentual' WHEN kr.metric = 'NUMERIC' THEN 'Numérico' ELSE 'Outro' END AS tipo_kr, AVG( CASE WHEN kr.direction = 'up' THEN kr.progress / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN (kr.target - kr.progress) / NULLIF(kr.target, 0) ELSE NULL END ) AS progresso_medio FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC') GROUP BY tipo_kr;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.3885308451893571
    },
    {
      "question": "Quais OKRs têm maior número de KRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id AS okr_id, o.description AS okr_description, COUNT(k.id) AS num_krs FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY num_krs DESC;"
        }
      ],
      "predictedSql": "SELECT o.id AS okr_id, o.description AS okr_description, COUNT(k.id) AS num_krs FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY num_krs DESC;",
      "executionTimeMs": 2589,
      "goldSql": "SELECT okr_id, COUNT(*) AS kr_count FROM kr GROUP BY okr_id ORDER BY kr_count DESC LIMIT 5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7889917879700854,
      "finalSql": "SELECT o.id AS okr_id, o.description AS okr_description, COUNT(k.id) AS num_krs FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY num_krs DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.02487562189054726,
      "queryAffinityScore": 0.40693370493031633
    },
    {
      "question": "Qual o percentual de KRs marcados como “bookmarked” pelos colaboradores?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT CAST(COUNT(CASE WHEN bookmarked = TRUE THEN 1 END) AS DECIMAL) * 100 / COUNT(*) AS percentual_krs_bookmarked FROM kr;"
        }
      ],
      "predictedSql": "SELECT CAST(COUNT(CASE WHEN bookmarked = TRUE THEN 1 END) AS DECIMAL) * 100 / COUNT(*) AS percentual_krs_bookmarked FROM kr;",
      "executionTimeMs": 2568,
      "goldSql": "SELECT COUNT(*) FILTER (WHERE bookmarked) * 100.0 / COUNT(*) AS percent_bookmarked FROM kr;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.8220473953966969,
      "finalSql": "SELECT CAST(COUNT(CASE WHEN bookmarked = TRUE THEN 1 END) AS DECIMAL) * 100 / COUNT(*) AS percentual_krs_bookmarked FROM kr;",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9110236976983485
    },
    {
      "question": "Qual é o percentual médio de progresso dos KRs (Key Results) em relação às metas estabelecidas nos últimos três meses?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress_percentage FROM kr k WHERE k.last_modified_date >= NOW() - INTERVAL '3 months';"
        }
      ],
      "predictedSql": "SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress_percentage FROM kr k WHERE k.last_modified_date >= NOW() - INTERVAL '3 months';",
      "executionTimeMs": 2772,
      "goldSql": "SELECT AVG(kh.progress / NULLIF(k.target, 0)) * 100 AS avg_progress_percent FROM kr k JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 months';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8489269583540864,
      "finalSql": "SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress_percentage FROM kr k WHERE k.last_modified_date >= NOW() - INTERVAL '3 months';",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4244634791770432
    },
    {
      "question": "Quais colaboradores têm mais KRs marcados como “bookmarked” (favoritos) e demonstram maior engajamento com os objetivos da empresa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY bookmarked_krs_count DESC;"
        }
      ],
      "predictedSql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY bookmarked_krs_count DESC;",
      "executionTimeMs": 2688,
      "goldSql": "SELECT c.id, c.name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator c JOIN kr k ON k.bookmarked_by_id = c.id AND k.bookmarked = true GROUP BY c.id, c.name ORDER BY bookmarked_kr_count DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.9581054855316604,
      "finalSql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name ORDER BY bookmarked_krs_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.17543859649122806,
      "queryAffinityScore": 0.5667720410114443
    },
    {
      "question": "Qual é o tempo médio entre a criação de um OKR e a primeira atualização de progresso registrada?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS average_time_to_first_update FROM okr o JOIN kr k ON o.id = k.okr_id JOIN (SELECT kr_id, MIN(date) AS first_update_date FROM kr_history GROUP BY kr_id) AS first_updates ON k.id = first_updates.kr_id JOIN kr_history kh ON first_updates.kr_id = kh.kr_id AND first_updates.first_update_date = kh.date;"
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS average_time_to_first_update FROM okr o JOIN kr k ON o.id = k.okr_id JOIN (SELECT kr_id, MIN(date) AS first_update_date FROM kr_history GROUP BY kr_id) AS first_updates ON k.id = first_updates.kr_id JOIN kr_history kh ON first_updates.kr_id = kh.kr_id AND first_updates.first_update_date = kh.date;",
      "executionTimeMs": 3165,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.first_update - o.created_date)) / 86400) AS avg_days_to_first_update FROM okr o JOIN (SELECT k.okr_id, MIN(kh.date) AS first_update FROM kr k JOIN kr_history kh ON kh.kr_id = k.id GROUP BY k.okr_id) kh ON kh.okr_id = o.id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9308942269784383,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS average_time_to_first_update FROM okr o JOIN kr k ON o.id = k.okr_id JOIN (SELECT kr_id, MIN(date) AS first_update_date FROM kr_history GROUP BY kr_id) AS first_updates ON k.id = first_updates.kr_id JOIN kr_history kh ON first_updates.kr_id = kh.kr_id AND first_updates.first_update_date = kh.date;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.46544711348921913
    },
    {
      "question": "Quantos OKRs estão próximos do prazo final (deadline) e ainda não atingiram 80% de progresso?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(DISTINCT o.id) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.deadline IS NOT NULL AND o.deadline <= NOW() + INTERVAL '7 days' AND (CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target < 0.8 WHEN k.direction = 'down' THEN k.progress::numeric / k.target > 0.2 ELSE FALSE END);"
        }
      ],
      "predictedSql": "SELECT COUNT(DISTINCT o.id) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.deadline IS NOT NULL AND o.deadline <= NOW() + INTERVAL '7 days' AND (CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target < 0.8 WHEN k.direction = 'down' THEN k.progress::numeric / k.target > 0.2 ELSE FALSE END);",
      "executionTimeMs": 2996,
      "goldSql": "SELECT COUNT(*) AS okrs_near_deadline_low_progress FROM ( SELECT o.id FROM okr o JOIN kr k ON k.okr_id = o.id WHERE o.deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' GROUP BY o.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8 ) sub;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8311349390223591,
      "finalSql": "SELECT COUNT(DISTINCT o.id) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.deadline IS NOT NULL AND o.deadline <= NOW() + INTERVAL '7 days' AND (CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target < 0.8 WHEN k.direction = 'down' THEN k.progress::numeric / k.target > 0.2 ELSE FALSE END);",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.41556746951117957
    },
    {
      "question": "Quais iniciativas possuem OKRs cujo progresso médio supera o progresso médio global de todas as iniciativas da mesma categoria?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH InitiativeProgress AS ( SELECT i.id AS initiative_id, i.title AS initiative_title, i.category, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) -- Ajuste para 'down' ELSE 0 END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.title, i.category ), CategoryAvgProgress AS ( SELECT category, AVG(avg_okr_progress) AS global_avg_progress_in_category FROM InitiativeProgress GROUP BY category ) SELECT ip.initiative_title, ip.category, ip.avg_okr_progress, cap.global_avg_progress_in_category FROM InitiativeProgress AS ip JOIN CategoryAvgProgress AS cap ON ip.category = cap.category WHERE ip.avg_okr_progress > cap.global_avg_progress_in_category ORDER BY ip.category, ip.avg_okr_progress DESC;",
          "error": "syntax error at end of input"
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH InitiativeProgress AS (\\n SELECT\\n i.id AS initiative_id,\\n i.title AS initiative_title,\\n i.category,\\n AVG(\\n CASE\\n WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0)\\n WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0)\\n ELSE 0\\n END\\n ) AS avg_okr_progress\\n FROM initiative AS i\\n JOIN okr AS o\\n ON i.id = o.initiative_id\\n JOIN kr AS k\\n ON o.id = k.okr_id\\n GROUP BY\\n i.id,\\n i.title,\\n i.category\\n),\\nCategoryAvgProgress AS (\\n SELECT\\n category,\\n AVG(avg_okr_progress) AS global_avg_progress_in_category\\n FROM InitiativeProgress\\n GROUP BY\\n category\\n)\\nSELECT\\n ip.initiative_title,\\n ip.category,\\n ip.avg_okr_progress,\\n cap.global_avg_progress_in_category\\nFROM InitiativeProgress AS ip\\nJOIN CategoryAvgProgress AS cap\\n ON ip.category = cap.category\\nWHERE\\n ip.avg_okr_progress > cap.global_avg_progress_in_category\\nORDER BY\\n ip.category,\\n ip.avg_okr_progress DESC;\", \"explanation\": \"O erro 'syntax error at end of input' geralmente indica um problema de sintaxe que impede o parser de completar a análise da query. Neste caso, a query original estava sintaticamente correta para o PostgreSQL. O erro pode ter sido um falso positivo ou um problema no ambiente de execução que não está diretamente relacionado à sintaxe SQL apresentada. A query fornecida já estava bem formatada e logicamente correta para o objetivo. A correção consiste em retornar a mesma query, garantindo que não há caracteres ocultos ou problemas de codificação que possam ter causado o erro",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "WITH InitiativeProgress AS ( SELECT i.id AS initiative_id, i.title AS initiative_title, i.category, AVG( CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END ) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.title, i.category ), CategoryAvgProgress AS ( SELECT category, AVG(avg_okr_progress) AS global_avg_progress_in_category FROM InitiativeProgress GROUP BY category ) SELECT ip.initiative_title, ip.category, ip.avg_okr_progress, cap.global_avg_progress_in_category FROM InitiativeProgress AS ip JOIN CategoryAvgProgress AS cap ON ip.category = cap.category WHERE ip.avg_okr_progress > cap.global_avg_progress_in_category ORDER BY ip.category, ip.avg_okr_progress DESC;",
          "fixed": true
        }
      ],
      "predictedSql": "WITH InitiativeProgress AS ( SELECT i.id AS initiative_id, i.title AS initiative_title, i.category, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) -- Ajuste para 'down' ELSE 0 END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.title, i.category ), CategoryAvgProgress AS ( SELECT category, AVG(avg_okr_progress) AS global_avg_progress_in_category FROM InitiativeProgress GROUP BY category ) SELECT ip.initiative_title, ip.category, ip.avg_okr_progress, cap.global_avg_progress_in_category FROM InitiativeProgress AS ip JOIN CategoryAvgProgress AS cap ON ip.category = cap.category WHERE ip.avg_okr_progress > cap.global_avg_progress_in_category ORDER BY ip.category, ip.avg_okr_progress DESC;",
      "executionTimeMs": 4042,
      "goldSql": "WITH initiative_avg AS (SELECT i.id, i.category, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, i.category), category_avg AS (SELECT category, AVG(avg_progress) AS category_avg_progress FROM initiative_avg GROUP BY category) SELECT ia.id, ia.category, ia.avg_progress FROM initiative_avg ia JOIN category_avg ca ON ia.category = ca.category WHERE ia.avg_progress > ca.category_avg_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.9121520529806625,
      "finalSql": "WITH InitiativeProgress AS ( SELECT i.id AS initiative_id, i.title AS initiative_title, i.category, AVG( CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END ) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.title, i.category ), CategoryAvgProgress AS ( SELECT category, AVG(avg_okr_progress) AS global_avg_progress_in_category FROM InitiativeProgress GROUP BY category ) SELECT ip.initiative_title, ip.category, ip.avg_okr_progress, cap.global_avg_progress_in_category FROM InitiativeProgress AS ip JOIN CategoryAvgProgress AS cap ON ip.category = cap.category WHERE ip.avg_okr_progress > cap.global_avg_progress_in_category ORDER BY ip.category, ip.avg_okr_progress DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.25,
      "queryAffinityScore": 0.5810760264903312
    },
    {
      "question": "Qual colaborador teve o maior aumento percentual de progresso médio de KRs entre o último e o penúltimo mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH MonthlyProgress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, TO_CHAR(kh.date, 'YYYY-MM') AS month_year, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name, TO_CHAR(kh.date, 'YYYY-MM')), RankedMonths AS (SELECT collaborator_id, collaborator_name, month_year, avg_progress, RANK() OVER (PARTITION BY collaborator_id ORDER BY month_year DESC) AS rn FROM MonthlyProgress), LastTwoMonths AS (SELECT rm.collaborator_id, rm.collaborator_name, rm.month_year, rm.avg_progress, rm.rn FROM RankedMonths rm WHERE rm.rn <= 2), PivotedMonths AS (SELECT collaborator_id, collaborator_name, MAX(CASE WHEN rn = 1 THEN avg_progress END) AS last_month_progress, MAX(CASE WHEN rn = 2 THEN avg_progress END) AS second_last_month_progress FROM LastTwoMonths GROUP BY collaborator_id, collaborator_name HAVING COUNT(DISTINCT rn) = 2) SELECT collaborator_name, (last_month_progress - second_last_month_progress) / NULLIF(second_last_month_progress, 0) AS progress_increase_percentage FROM PivotedMonths ORDER BY progress_increase_percentage DESC LIMIT 1;"
        }
      ],
      "predictedSql": "WITH MonthlyProgress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, TO_CHAR(kh.date, 'YYYY-MM') AS month_year, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name, TO_CHAR(kh.date, 'YYYY-MM')), RankedMonths AS (SELECT collaborator_id, collaborator_name, month_year, avg_progress, RANK() OVER (PARTITION BY collaborator_id ORDER BY month_year DESC) AS rn FROM MonthlyProgress), LastTwoMonths AS (SELECT rm.collaborator_id, rm.collaborator_name, rm.month_year, rm.avg_progress, rm.rn FROM RankedMonths rm WHERE rm.rn <= 2), PivotedMonths AS (SELECT collaborator_id, collaborator_name, MAX(CASE WHEN rn = 1 THEN avg_progress END) AS last_month_progress, MAX(CASE WHEN rn = 2 THEN avg_progress END) AS second_last_month_progress FROM LastTwoMonths GROUP BY collaborator_id, collaborator_name HAVING COUNT(DISTINCT rn) = 2) SELECT collaborator_name, (last_month_progress - second_last_month_progress) / NULLIF(second_last_month_progress, 0) AS progress_increase_percentage FROM PivotedMonths ORDER BY progress_increase_percentage DESC LIMIT 1;",
      "executionTimeMs": 4007,
      "goldSql": "WITH monthly_progress AS (SELECT collaborator_id, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr_history GROUP BY collaborator_id, month), ranked_progress AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY collaborator_id ORDER BY month DESC) AS rn FROM monthly_progress), last_two_months AS (SELECT p1.collaborator_id, p1.avg_progress AS last_month_progress, p2.avg_progress AS prev_month_progress, CASE WHEN p2.avg_progress = 0 THEN NULL ELSE ((p1.avg_progress - p2.avg_progress) / p2.avg_progress) * 100 END AS pct_increase FROM ranked_progress p1 JOIN ranked_progress p2 ON p1.collaborator_id = p2.collaborator_id WHERE p1.rn = 1 AND p2.rn = 2) SELECT collaborator_id, pct_increase FROM last_two_months ORDER BY pct_increase DESC LIMIT 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.375
      },
      "cosineSimilarity": 0.9038270159129527,
      "finalSql": "WITH MonthlyProgress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, TO_CHAR(kh.date, 'YYYY-MM') AS month_year, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name, TO_CHAR(kh.date, 'YYYY-MM')), RankedMonths AS (SELECT collaborator_id, collaborator_name, month_year, avg_progress, RANK() OVER (PARTITION BY collaborator_id ORDER BY month_year DESC) AS rn FROM MonthlyProgress), LastTwoMonths AS (SELECT rm.collaborator_id, rm.collaborator_name, rm.month_year, rm.avg_progress, rm.rn FROM RankedMonths rm WHERE rm.rn <= 2), PivotedMonths AS (SELECT collaborator_id, collaborator_name, MAX(CASE WHEN rn = 1 THEN avg_progress END) AS last_month_progress, MAX(CASE WHEN rn = 2 THEN avg_progress END) AS second_last_month_progress FROM LastTwoMonths GROUP BY collaborator_id, collaborator_name HAVING COUNT(DISTINCT rn) = 2) SELECT collaborator_name, (last_month_progress - second_last_month_progress) / NULLIF(second_last_month_progress, 0) AS progress_increase_percentage FROM PivotedMonths ORDER BY progress_increase_percentage DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7019135079564763
    },
    {
      "question": "Quais iniciativas tiveram pelo menos um KR com progresso superior a 100% em algum ponto do histórico?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT i.title FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE (k.direction = 'up' AND kh.progress / NULLIF(kh.target, 0) > 1.0) OR (k.direction = 'down' AND kh.progress / NULLIF(kh.target, 0) < 1.0);"
        }
      ],
      "predictedSql": "SELECT DISTINCT i.title FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE (k.direction = 'up' AND kh.progress / NULLIF(kh.target, 0) > 1.0) OR (k.direction = 'down' AND kh.progress / NULLIF(kh.target, 0) < 1.0);",
      "executionTimeMs": 2722,
      "goldSql": "SELECT DISTINCT i.id, i.title FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target, 0) > 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9203443612097699,
      "finalSql": "SELECT DISTINCT i.title FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE (k.direction = 'up' AND kh.progress / NULLIF(kh.target, 0) > 1.0) OR (k.direction = 'down' AND kh.progress / NULLIF(kh.target, 0) < 1.0);",
      "executionMatch": false,
      "tableSimilarity": 0.2407407407407407,
      "queryAffinityScore": 0.5805425509752553
    },
    {
      "question": "Qual é o tempo médio (em dias) entre atualizações consecutivas de um mesmo KR no histórico?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(diff_in_days) FROM (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date, EXTRACT(EPOCH FROM (LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) - date)) / (60 * 60 * 24) AS diff_in_days FROM kr_history) AS subquery WHERE diff_in_days IS NOT NULL;"
        }
      ],
      "predictedSql": "SELECT AVG(diff_in_days) FROM (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date, EXTRACT(EPOCH FROM (LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) - date)) / (60 * 60 * 24) AS diff_in_days FROM kr_history) AS subquery WHERE diff_in_days IS NOT NULL;",
      "executionTimeMs": 2743,
      "goldSql": "WITH diffs AS (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date FROM kr_history) SELECT AVG(EXTRACT(EPOCH FROM (next_date - date)) / 86400) AS avg_days_between_updates FROM diffs WHERE next_date IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8947271059318312,
      "finalSql": "SELECT AVG(diff_in_days) FROM (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date, EXTRACT(EPOCH FROM (LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) - date)) / (60 * 60 * 24) AS diff_in_days FROM kr_history) AS subquery WHERE diff_in_days IS NOT NULL;",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9473635529659157
    },
    {
      "question": "Quais iniciativas têm pelo menos dois OKRs com deadlines no mesmo mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, TO_CHAR(o.deadline, 'YYYY-MM') AS month_year, COUNT(o.id) AS okr_count FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.title, TO_CHAR(o.deadline, 'YYYY-MM') HAVING COUNT(o.id) >= 2 ORDER BY i.title, month_year;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, TO_CHAR(o.deadline, 'YYYY-MM') AS month_year, COUNT(o.id) AS okr_count FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.title, TO_CHAR(o.deadline, 'YYYY-MM') HAVING COUNT(o.id) >= 2 ORDER BY i.title, month_year;",
      "executionTimeMs": 2749,
      "goldSql": "SELECT initiative_id FROM okr GROUP BY initiative_id, DATE_TRUNC('month', deadline) HAVING COUNT(*) >= 2;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7968651789583435,
      "finalSql": "SELECT i.title AS initiative_title, TO_CHAR(o.deadline, 'YYYY-MM') AS month_year, COUNT(o.id) AS okr_count FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.title, TO_CHAR(o.deadline, 'YYYY-MM') HAVING COUNT(o.id) >= 2 ORDER BY i.title, month_year;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.39843258947917176
    },
    {
      "question": "Qual é a distribuição percentual de KRs por tipo de métrica dentro de cada iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, k.metric, COUNT(k.id) AS kr_count, (COUNT(k.id) * 100.0 / SUM(COUNT(k.id)) OVER (PARTITION BY i.id)) AS percentage FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id, i.title, k.metric ORDER BY i.title, k.metric;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, k.metric, COUNT(k.id) AS kr_count, (COUNT(k.id) * 100.0 / SUM(COUNT(k.id)) OVER (PARTITION BY i.id)) AS percentage FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id, i.title, k.metric ORDER BY i.title, k.metric;",
      "executionTimeMs": 2908,
      "goldSql": "WITH kr_counts AS (SELECT i.id AS initiative_id, k.metric, COUNT(*) AS count FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, k.metric), initiative_totals AS (SELECT initiative_id, SUM(count) AS total FROM kr_counts GROUP BY initiative_id) SELECT kc.initiative_id, kc.metric, (kc.count::float / it.total) * 100 AS percent FROM kr_counts kc JOIN initiative_totals it ON kc.initiative_id = it.initiative_id ORDER BY kc.initiative_id, percent DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8733822102410407,
      "finalSql": "SELECT i.title AS initiative_title, k.metric, COUNT(k.id) AS kr_count, (COUNT(k.id) * 100.0 / SUM(COUNT(k.id)) OVER (PARTITION BY i.id)) AS percentage FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id, i.title, k.metric ORDER BY i.title, k.metric;",
      "executionMatch": false,
      "tableSimilarity": 0.2555970149253731,
      "queryAffinityScore": 0.5644896125832068
    },
    {
      "question": "Listar os KRs cujo progresso atual está abaixo da média dos KRs do mesmo tipo e direção.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH KRProgress AS (SELECT id, title, metric, direction, progress, target, CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target::numeric - progress) / NULLIF(target, 0) ELSE NULL END AS calculated_progress FROM kr), KRAverage AS (SELECT metric, direction, AVG(calculated_progress) AS avg_progress FROM KRProgress GROUP BY metric, direction) SELECT kp.title, kp.metric, kp.direction, kp.calculated_progress, ka.avg_progress FROM KRProgress kp JOIN KRAverage ka ON kp.metric = ka.metric AND kp.direction = ka.direction WHERE kp.calculated_progress < ka.avg_progress;"
        }
      ],
      "predictedSql": "WITH KRProgress AS (SELECT id, title, metric, direction, progress, target, CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target::numeric - progress) / NULLIF(target, 0) ELSE NULL END AS calculated_progress FROM kr), KRAverage AS (SELECT metric, direction, AVG(calculated_progress) AS avg_progress FROM KRProgress GROUP BY metric, direction) SELECT kp.title, kp.metric, kp.direction, kp.calculated_progress, ka.avg_progress FROM KRProgress kp JOIN KRAverage ka ON kp.metric = ka.metric AND kp.direction = ka.direction WHERE kp.calculated_progress < ka.avg_progress;",
      "executionTimeMs": 3402,
      "goldSql": "WITH avg_progress AS (SELECT metric, direction, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY metric, direction) SELECT k.* FROM kr k JOIN avg_progress ap ON k.metric = ap.metric AND k.direction = ap.direction WHERE (k.progress / NULLIF(k.target, 0)) < ap.avg_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8729877523909246,
      "finalSql": "WITH KRProgress AS (SELECT id, title, metric, direction, progress, target, CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target::numeric - progress) / NULLIF(target, 0) ELSE NULL END AS calculated_progress FROM kr), KRAverage AS (SELECT metric, direction, AVG(calculated_progress) AS avg_progress FROM KRProgress GROUP BY metric, direction) SELECT kp.title, kp.metric, kp.direction, kp.calculated_progress, ka.avg_progress FROM KRProgress kp JOIN KRAverage ka ON kp.metric = ka.metric AND kp.direction = ka.direction WHERE kp.calculated_progress < ka.avg_progress;",
      "executionMatch": false,
      "tableSimilarity": 0.23792486583184258,
      "queryAffinityScore": 0.5554563091113836
    },
    {
      "question": "Identificar iniciativas que mantêm registros de atualização em meses consecutivos, sem interrupções.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH InitiativeMonths AS ( SELECT initiative_id, DATE_TRUNC('month', year_month) AS month_start FROM initiative_update GROUP BY initiative_id, DATE_TRUNC('month', year_month) ), ConsecutiveMonths AS ( SELECT initiative_id, month_start, LAG(month_start, 1) OVER (PARTITION BY initiative_id ORDER BY month_start) AS prev_month_start FROM InitiativeMonths ) SELECT DISTINCT i.title FROM ConsecutiveMonths cm JOIN initiative i ON cm.initiative_id = i.id WHERE cm.prev_month_start IS NOT NULL AND cm.month_start = (cm.prev_month_start + INTERVAL '1 month');",
          "error": "function date_trunc(unknown, character varying) does not exist"
        },
        {
          "attempt": 2,
          "sql": "WITH InitiativeMonths AS ( SELECT initiative_id, DATE_TRUNC('month', created_date) AS month_start FROM initiative_update GROUP BY initiative_id, DATE_TRUNC('month', created_date) ), ConsecutiveMonths AS ( SELECT initiative_id, month_start, LAG(month_start, 1) OVER (PARTITION BY initiative_id ORDER BY month_start) AS prev_month_start FROM InitiativeMonths ) SELECT DISTINCT i.title FROM ConsecutiveMonths cm JOIN initiative i ON cm.initiative_id = i.id WHERE cm.prev_month_start IS NOT NULL AND cm.month_start = (cm.prev_month_start + INTERVAL '1 month');",
          "fixed": true
        }
      ],
      "predictedSql": "WITH InitiativeMonths AS ( SELECT initiative_id, DATE_TRUNC('month', year_month) AS month_start FROM initiative_update GROUP BY initiative_id, DATE_TRUNC('month', year_month) ), ConsecutiveMonths AS ( SELECT initiative_id, month_start, LAG(month_start, 1) OVER (PARTITION BY initiative_id ORDER BY month_start) AS prev_month_start FROM InitiativeMonths ) SELECT DISTINCT i.title FROM ConsecutiveMonths cm JOIN initiative i ON cm.initiative_id = i.id WHERE cm.prev_month_start IS NOT NULL AND cm.month_start = (cm.prev_month_start + INTERVAL '1 month');",
      "executionTimeMs": 3092,
      "goldSql": "WITH updates_months AS (SELECT initiative_id, DATE_TRUNC('month', created_date) AS month FROM initiative_update GROUP BY initiative_id, month), consecutive AS (SELECT initiative_id, month, LAG(month) OVER (PARTITION BY initiative_id ORDER BY month) AS prev_month FROM updates_months), gaps AS (SELECT initiative_id, COUNT(*) FILTER (WHERE prev_month IS NOT NULL AND month - INTERVAL '1 month' <> prev_month) AS gap_count, COUNT(month) AS total_months FROM consecutive GROUP BY initiative_id) SELECT initiative_id FROM gaps WHERE gap_count = 0 AND total_months > 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 1,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8770177943095003,
      "finalSql": "WITH InitiativeMonths AS ( SELECT initiative_id, DATE_TRUNC('month', created_date) AS month_start FROM initiative_update GROUP BY initiative_id, DATE_TRUNC('month', created_date) ), ConsecutiveMonths AS ( SELECT initiative_id, month_start, LAG(month_start, 1) OVER (PARTITION BY initiative_id ORDER BY month_start) AS prev_month_start FROM InitiativeMonths ) SELECT DISTINCT i.title FROM ConsecutiveMonths cm JOIN initiative i ON cm.initiative_id = i.id WHERE cm.prev_month_start IS NOT NULL AND cm.month_start = (cm.prev_month_start + INTERVAL '1 month');",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.43850889715475017
    },
    {
      "question": "Calcular a taxa média de crescimento mensal do progresso dos KRs, segmentada por tipo de métrica.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH MonthlyProgress AS (SELECT TO_CHAR(date, 'YYYY-MM') AS month, metric, AVG(CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target::numeric - progress) / NULLIF(target, 0) ELSE 0 END) AS avg_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY TO_CHAR(date, 'YYYY-MM'), metric ORDER BY month, metric), LaggedProgress AS (SELECT month, metric, avg_progress, LAG(avg_progress, 1, 0) OVER (PARTITION BY metric ORDER BY month) AS prev_month_progress FROM MonthlyProgress) SELECT month, metric, (avg_progress - prev_month_progress) AS monthly_growth_rate FROM LaggedProgress WHERE prev_month_progress IS NOT NULL AND prev_month_progress != 0 ORDER BY month, metric;",
          "error": "column reference \"metric\" is ambiguous"
        },
        {
          "attempt": 2,
          "sql": "WITH MonthlyProgress AS (SELECT TO_CHAR(kh.date, 'YYYY-MM') AS month, k.metric, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY TO_CHAR(kh.date, 'YYYY-MM'), k.metric ORDER BY month, k.metric), LaggedProgress AS (SELECT month, metric, avg_progress, LAG(avg_progress, 1, 0) OVER (PARTITION BY metric ORDER BY month) AS prev_month_progress FROM MonthlyProgress) SELECT month, metric, (avg_progress - prev_month_progress) AS monthly_growth_rate FROM LaggedProgress WHERE prev_month_progress IS NOT NULL AND prev_month_progress != 0 ORDER BY month, metric;",
          "fixed": true
        }
      ],
      "predictedSql": "WITH MonthlyProgress AS (SELECT TO_CHAR(date, 'YYYY-MM') AS month, metric, AVG(CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target::numeric - progress) / NULLIF(target, 0) ELSE 0 END) AS avg_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY TO_CHAR(date, 'YYYY-MM'), metric ORDER BY month, metric), LaggedProgress AS (SELECT month, metric, avg_progress, LAG(avg_progress, 1, 0) OVER (PARTITION BY metric ORDER BY month) AS prev_month_progress FROM MonthlyProgress) SELECT month, metric, (avg_progress - prev_month_progress) AS monthly_growth_rate FROM LaggedProgress WHERE prev_month_progress IS NOT NULL AND prev_month_progress != 0 ORDER BY month, metric;",
      "executionTimeMs": 3352,
      "goldSql": "WITH monthly_kr_progress AS (SELECT kr_id, metric, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr_history GROUP BY kr_id, metric, month), monthly_growth AS (SELECT kr_id, metric, month, avg_progress, LAG(avg_progress) OVER (PARTITION BY kr_id ORDER BY month) AS prev_avg_progress FROM monthly_kr_progress), growth_rate AS (SELECT metric, AVG(CASE WHEN prev_avg_progress IS NOT NULL THEN (avg_progress - prev_avg_progress) / NULLIF(prev_avg_progress,0) ELSE NULL END) AS avg_monthly_growth_rate FROM monthly_growth GROUP BY metric) SELECT metric, avg_monthly_growth_rate FROM growth_rate;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8703858466463567,
      "finalSql": "WITH MonthlyProgress AS (SELECT TO_CHAR(kh.date, 'YYYY-MM') AS month, k.metric, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id GROUP BY TO_CHAR(kh.date, 'YYYY-MM'), k.metric ORDER BY month, k.metric), LaggedProgress AS (SELECT month, metric, avg_progress, LAG(avg_progress, 1, 0) OVER (PARTITION BY metric ORDER BY month) AS prev_month_progress FROM MonthlyProgress) SELECT month, metric, (avg_progress - prev_month_progress) AS monthly_growth_rate FROM LaggedProgress WHERE prev_month_progress IS NOT NULL AND prev_month_progress != 0 ORDER BY month, metric;",
      "executionMatch": false,
      "tableSimilarity": 0.01388888888888884,
      "queryAffinityScore": 0.44213736776762275
    },
    {
      "question": "Detectar iniciativas que apresentaram regressão média no progresso de seus KRs durante o último ciclo de atualização.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "{ \"sql\": \"WITH latest_kr_updates AS (SELECT kr_id, MAX(date) AS latest_date FROM kr_history GROUP BY kr_id), kr_progress_data AS (SELECT kh.kr_id, kh.progress, kh.target, k.direction, kh.date FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN latest_kr_updates lku ON kh.kr_id = lku.kr_id AND kh.date = lku.latest_date), kr_previous_progress_data AS (SELECT kh.kr_id, kh.progress, kh.target, k.direction, kh.date FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.date < (SELECT MAX(date) FROM kr_history)), kr_current_progress AS (SELECT kr_id, CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress)::numeric / NULLIF(target, 0) ELSE 0 END AS current_progress FROM kr_progress_data), kr_previous_progress AS (SELECT kr_id, CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress)::numeric / NULLIF(target, 0) ELSE 0 END AS previous_progress FROM kr_previous_progress_data), initiative_progress_change AS (SELECT k.okr_id, AVG(kcp.current_progress) - AVG(kpp.previous_progress) AS avg_progress_change FROM kr k JOIN kr_current_progress kcp ON k.id = kcp.kr_id JOIN kr_previous_progress kpp ON k.id = kpp.kr_id GROUP BY k.okr_id) SELECT i.title AS initiative_title, ipc.avg_progress_change FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_progress_change ipc ON o.id = ipc.okr_id WHERE ipc.avg_progress_change < 0 ORDER BY ipc.avg_progress_change ASC;\", \"complementaryText\": \"Esta",
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS latest_date\\n FROM\\n kr_history kh\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_data AS (\\n SELECT\\n kh.kr_id,\\n kh.progress,\\n kh.target,\\n k.direction,\\n kh.date\\n FROM\\n kr_history kh\\n JOIN\\n kr k ON kh.kr_id = k.id\\n JOIN\\n latest_kr_updates lku ON kh.kr_id = lku.kr_id AND kh.date = lku.latest_date\\n),\\nkr_previous_progress_data AS (\\n SELECT\\n kh1.kr_id,\\n kh1.progress,\\n kh1.target,\\n k.direction,\\n kh1.date\\n FROM\\n kr_history kh1\\n JOIN\\n kr k ON kh1.kr_id = k.id\\n WHERE\\n kh1.date = (\\n SELECT\\n MAX(kh2.date)\\n FROM\\n kr_history kh2\\n WHERE\\n kh2.kr_id = kh1.kr_id\\n AND kh2.date < (SELECT MAX(date) FROM kr_history)\\n )\\n),\\nkr_current_progress AS (\\n SELECT\\n kr_id,\\n CASE\\n WHEN direction = 'PERC' THEN progress / 100.0\\n WHEN direction = 'NUMERIC' AND target != 0 THEN progress / target\\n WHEN direction = 'YES_NO' THEN CASE WHEN progress > 0 THEN 1.0 ELSE 0.0 END\\n ELSE 0.0\\n END AS current_progress_ratio\\n FROM\\n kr_progress_data\\n),\\nkr_previous_progress AS (\\n SELECT\\n kr_id,\\n CASE\\n WHEN direction = 'PERC' THEN progress",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS latest_date\\n FROM\\n kr_history kh\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_data AS (\\n SELECT\\n kh.kr_id,\\n kh.progress,\\n kh.target,\\n k.direction,\\n kh.date\\n FROM\\n kr_history kh\\n JOIN\\n kr k ON kh.kr_id = k.id\\n JOIN\\n latest_kr_updates lku ON kh.kr_id = lku.kr_id AND kh.date = lku.latest_date\\n),\\nkr_previous_progress_data AS (\\n SELECT\\n kh1.kr_id,\\n kh1.progress,\\n kh1.target,\\n k.direction,\\n kh1.date\\n FROM\\n kr_history kh1\\n JOIN\\n kr k ON kh1.kr_id = k.id\\n WHERE\\n kh1.date = (\\n SELECT\\n MAX(kh2.date)\\n FROM\\n kr_history kh2\\n WHERE\\n kh2.kr_id = kh1.kr_id\\n AND kh2.date < (SELECT MAX(date) FROM kr_history WHERE kr_id = kh1.kr_id)\\n )\\n),\\nkr_current_progress AS (\\n SELECT\\n kr_id,\\n CASE\\n WHEN direction = 'PERC' THEN progress / 100.0\\n WHEN direction = 'NUMERIC' AND target != 0 THEN progress / target\\n WHEN direction = 'YES_NO' THEN CASE WHEN progress > 0 THEN 1.0 ELSE 0.0 END\\n ELSE 0.0\\n END AS current_progress_ratio\\n FROM\\n kr_progress_data\\n),\\nkr_previous_progress AS (\\n SELECT\\n kr_id,\\n CASE\\",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "{ \"sql\": \"WITH latest_kr_updates AS (SELECT kr_id, MAX(date) AS latest_date FROM kr_history GROUP BY kr_id), kr_progress_data AS (SELECT kh.kr_id, kh.progress, kh.target, k.direction, kh.date FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN latest_kr_updates lku ON kh.kr_id = lku.kr_id AND kh.date = lku.latest_date), kr_previous_progress_data AS (SELECT kh.kr_id, kh.progress, kh.target, k.direction, kh.date FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.date < (SELECT MAX(date) FROM kr_history)), kr_current_progress AS (SELECT kr_id, CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress)::numeric / NULLIF(target, 0) ELSE 0 END AS current_progress FROM kr_progress_data), kr_previous_progress AS (SELECT kr_id, CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress)::numeric / NULLIF(target, 0) ELSE 0 END AS previous_progress FROM kr_previous_progress_data), initiative_progress_change AS (SELECT k.okr_id, AVG(kcp.current_progress) - AVG(kpp.previous_progress) AS avg_progress_change FROM kr k JOIN kr_current_progress kcp ON k.id = kcp.kr_id JOIN kr_previous_progress kpp ON k.id = kpp.kr_id GROUP BY k.okr_id) SELECT i.title AS initiative_title, ipc.avg_progress_change FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_progress_change ipc ON o.id = ipc.okr_id WHERE ipc.avg_progress_change < 0 ORDER BY ipc.avg_progress_change ASC;\", \"complementaryText\": \"Esta",
      "executionTimeMs": 4105,
      "goldSql": "WITH last_two_updates AS (SELECT kh.kr_id, i.id AS initiative_id, kh.date, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn, kh.progress / NULLIF(k.target, 0) AS relative_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id), progress_diff AS (SELECT a.initiative_id, AVG(a.relative_progress - b.relative_progress) AS avg_progress_change FROM last_two_updates a JOIN last_two_updates b ON a.kr_id = b.kr_id AND a.rn = 1 AND b.rn = 2 GROUP BY a.initiative_id) SELECT initiative_id FROM progress_diff WHERE avg_progress_change < 0;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8212701308891667,
      "finalSql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS latest_date\\n FROM\\n kr_history kh\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_data AS (\\n SELECT\\n kh.kr_id,\\n kh.progress,\\n kh.target,\\n k.direction,\\n kh.date\\n FROM\\n kr_history kh\\n JOIN\\n kr k ON kh.kr_id = k.id\\n JOIN\\n latest_kr_updates lku ON kh.kr_id = lku.kr_id AND kh.date = lku.latest_date\\n),\\nkr_previous_progress_data AS (\\n SELECT\\n kh1.kr_id,\\n kh1.progress,\\n kh1.target,\\n k.direction,\\n kh1.date\\n FROM\\n kr_history kh1\\n JOIN\\n kr k ON kh1.kr_id = k.id\\n WHERE\\n kh1.date = (\\n SELECT\\n MAX(kh2.date)\\n FROM\\n kr_history kh2\\n WHERE\\n kh2.kr_id = kh1.kr_id\\n AND kh2.date < (SELECT MAX(date) FROM kr_history WHERE kr_id = kh1.kr_id)\\n )\\n),\\nkr_current_progress AS (\\n SELECT\\n kr_id,\\n CASE\\n WHEN direction = 'PERC' THEN progress / 100.0\\n WHEN direction = 'NUMERIC' AND target != 0 THEN progress / target\\n WHEN direction = 'YES_NO' THEN CASE WHEN progress > 0 THEN 1.0 ELSE 0.0 END\\n ELSE 0.0\\n END AS current_progress_ratio\\n FROM\\n kr_progress_data\\n),\\nkr_previous_progress AS (\\n SELECT\\n kr_id,\\n CASE\\",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Apontar iniciativas cujos OKRs estão vencidos, mas cujo progresso médio permanece abaixo de 80%.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_kr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.end_date < NOW() GROUP BY i.id, i.title, i.end_date HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) < 0.8;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_kr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.end_date < NOW() GROUP BY i.id, i.title, i.end_date HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) < 0.8;",
      "executionTimeMs": 3354,
      "goldSql": "SELECT i.id AS initiative_id FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id WHERE o.deadline < NOW() GROUP BY i.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8134569945073061,
      "finalSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_kr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.end_date < NOW() GROUP BY i.id, i.title, i.end_date HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) < 0.8;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.40672849725365307
    },
    {
      "question": "Identificar KRs com direção “NEGATIVA” que mantêm melhora contínua e atingem o target definido.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT k.title, k.metric, k.progress, k.target, k.direction FROM kr k WHERE k.direction = 'down' AND k.progress <= k.target;"
        }
      ],
      "predictedSql": "SELECT k.title, k.metric, k.progress, k.target, k.direction FROM kr k WHERE k.direction = 'down' AND k.progress <= k.target;",
      "executionTimeMs": 2826,
      "goldSql": "WITH kr_direction AS (SELECT k.id AS kr_id, k.target, k.direction FROM kr k WHERE k.direction = 'down'), history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kd.target, 0)) AS relative_progress, LAG(kh.progress / NULLIF(kd.target, 0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_progress FROM kr_history kh JOIN kr_direction kd ON kd.kr_id = kh.kr_id), fully_improving AS (SELECT kr_id FROM history GROUP BY kr_id HAVING COUNT(*) FILTER (WHERE prev_progress IS NOT NULL AND relative_progress >= prev_progress) = COUNT(*) - 1), achieved AS (SELECT kr_id FROM (SELECT kh.kr_id, (kh.progress / NULLIF(k.target,0)) AS relative_progress, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn FROM kr_history kh JOIN kr k ON k.id = kh.kr_id WHERE k.direction = 'down') last_value WHERE rn = 1 AND relative_progress <= 1) SELECT DISTINCT kr_id FROM fully_improving JOIN achieved USING(kr_id);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 1,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.4375
      },
      "cosineSimilarity": 0.7078528969848638,
      "finalSql": "SELECT k.title, k.metric, k.progress, k.target, k.direction FROM kr k WHERE k.direction = 'down' AND k.progress <= k.target;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.3539264484924319
    }
  ]
}