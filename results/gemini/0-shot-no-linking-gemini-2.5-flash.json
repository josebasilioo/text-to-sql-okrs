{
  "timestamp": "2025-11-28T00:59:34.319Z",
  "totalQuestions": 76,
  "successful": 70,
  "errors": 6,
  "retries": {
    "totalWithRetries": 26,
    "totalRetryAttempts": 35,
    "averageRetriesPerQuestion": 1.35,
    "maxRetries": 2,
    "successfulAfterRetry": 20,
    "failedAfterRetry": 6
  },
  "metrics": {
    "exactMatch": {
      "total": 70,
      "matches": 1,
      "accuracy": 0.014285714285714285
    },
    "componentMatch": {
      "total": 70,
      "averageCM": 0.7429
    },
    "executionMatch": {
      "total": 70,
      "matches": 6,
      "accuracy": 0.08571428571428572
    },
    "cosineSimilarity": {
      "total": 70,
      "average": 0.8431
    },
    "tableSimilarity": {
      "total": 70,
      "average": 0.3072
    },
    "queryAffinityScore": {
      "total": 70,
      "average": 0.5751
    }
  },
  "results": [
    {
      "question": "Existe correlação entre a prioridade da iniciativa e o progresso médio de seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.priority, AVG( CASE WHEN k.direction = 'up' THEN CASE WHEN k.target = 0 THEN NULL ELSE k.progress::numeric / k.target END WHEN k.direction = 'down' THEN CASE WHEN k.progress = 0 THEN NULL ELSE k.target::numeric / k.progress END ELSE NULL END ) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 6320,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9027601947992403,
      "finalSql": "SELECT i.priority, AVG( CASE WHEN k.direction = 'up' THEN CASE WHEN k.target = 0 THEN NULL ELSE k.progress::numeric / k.target END WHEN k.direction = 'down' THEN CASE WHEN k.progress = 0 THEN NULL ELSE k.target::numeric / k.progress END ELSE NULL END ) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7013800973996202
    },
    {
      "question": "Iniciativas com maior prioridade tendem a ter maior progresso médio nos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.priority, AVG( CASE WHEN k.direction = 'up' THEN CASE WHEN k.target = 0 THEN NULL ELSE k.progress::numeric / k.target END WHEN k.direction = 'down' THEN CASE WHEN k.progress = 0 THEN NULL ELSE k.target::numeric / k.progress END ELSE NULL END ) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 3115,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9027601947992403,
      "finalSql": "SELECT i.priority, AVG( CASE WHEN k.direction = 'up' THEN CASE WHEN k.target = 0 THEN NULL ELSE k.progress::numeric / k.target END WHEN k.direction = 'down' THEN CASE WHEN k.progress = 0 THEN NULL ELSE k.target::numeric / k.progress END ELSE NULL END ) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.7013800973996202
    },
    {
      "question": "Qual é a relação entre prioridade da iniciativa e o desempenho médio dos seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_performance FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) AS average_okr_performance FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_performance FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionTimeMs": 3201,
      "goldSql": "SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.8985333520460363,
      "finalSql": "SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) AS average_okr_performance FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.6992666760230182
    },
    {
      "question": "Iniciativas de qual categoria têm maior taxa de conclusão de KRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, AVG(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1.0 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1.0 ELSE 0.0 END) AS completion_rate FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT i.category, AVG(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1.0 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1.0 ELSE 0.0 END) AS completion_rate FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC LIMIT 1;",
      "executionTimeMs": 2802,
      "goldSql": "SELECT i.category, CAST(SUM(CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) AS FLOAT) / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.861869265359272,
      "finalSql": "SELECT i.category, AVG(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1.0 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1.0 ELSE 0.0 END) AS completion_rate FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.125,
      "queryAffinityScore": 0.493434632679636
    },
    {
      "question": "Qual categoria de iniciativa apresenta menor frequência de updates?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY COUNT(iu.id) ASC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT i.category FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY COUNT(iu.id) ASC LIMIT 1;",
      "executionTimeMs": 2543,
      "goldSql": "SELECT i.category, CAST(COUNT(iu.id) AS FLOAT) / COUNT(DISTINCT i.id) AS avg_updates_per_initiative FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY avg_updates_per_initiative ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8226394118909153,
      "finalSql": "SELECT i.category FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY COUNT(iu.id) ASC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.125,
      "queryAffinityScore": 0.47381970594545764
    },
    {
      "question": "Colaboradores com mais KRs favoritos têm desempenho melhor nos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name AS collaborator_name, COUNT(DISTINCT k.id) AS favorited_krs_count, AVG(CASE WHEN k.direction = 'up' THEN k.progress * 1.0 / k.target WHEN k.direction = 'down' THEN k.target * 1.0 / k.progress ELSE NULL END) AS avg_kr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY favorited_krs_count DESC;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT c.name AS collaborator_name, COUNT(DISTINCT k.id) AS favorited_krs_count, AVG( CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress * 1.0 / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target * 1.0 / k.progress ELSE NULL END ) AS avg_kr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY favorited_krs_count DESC;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT c.name AS collaborator_name, COUNT(DISTINCT k.id) AS favorited_krs_count, AVG(CASE WHEN k.direction = 'up' THEN k.progress * 1.0 / k.target WHEN k.direction = 'down' THEN k.target * 1.0 / k.progress ELSE NULL END) AS avg_kr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY favorited_krs_count DESC;",
      "executionTimeMs": 3124,
      "goldSql": "SELECT c.name, COUNT(k.id) AS total_bookmarked_krs, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress_of_bookmarked_krs FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ORDER BY total_bookmarked_krs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8962823185043789,
      "finalSql": "SELECT c.name AS collaborator_name, COUNT(DISTINCT k.id) AS favorited_krs_count, AVG( CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress * 1.0 / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target * 1.0 / k.progress ELSE NULL END ) AS avg_kr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY favorited_krs_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.3466666666666667,
      "queryAffinityScore": 0.6214744925855228
    },
    {
      "question": "Há diferença de progresso médio entre KRs do tipo “YES_NO” e “NUMERIC”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT CASE WHEN T1.metric = 'YES_NO' THEN 'YES_NO' WHEN T1.metric = 'NUMERIC' THEN 'NUMERIC' ELSE 'Other' END AS metric_type, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target ELSE T1.target :: NUMERIC / T1.progress END) AS average_progress FROM kr AS T1 WHERE T1.metric IN ('YES_NO', 'NUMERIC') GROUP BY metric_type;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT CASE WHEN T1.metric = 'YES_NO' THEN 'YES_NO' WHEN T1.metric = 'NUMERIC' THEN 'NUMERIC' ELSE 'Other' END AS metric_type, AVG( CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / NULLIF(T1.target, 0) ELSE T1.target :: NUMERIC / NULLIF(T1.progress, 0) END ) AS average_progress FROM kr AS T1 WHERE T1.metric IN ('YES_NO', 'NUMERIC') GROUP BY metric_type;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT CASE WHEN T1.metric = 'YES_NO' THEN 'YES_NO' WHEN T1.metric = 'NUMERIC' THEN 'NUMERIC' ELSE 'Other' END AS metric_type, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target ELSE T1.target :: NUMERIC / T1.progress END) AS average_progress FROM kr AS T1 WHERE T1.metric IN ('YES_NO', 'NUMERIC') GROUP BY metric_type;",
      "executionTimeMs": 2938,
      "goldSql": "SELECT k.metric, AVG(k.progress / NULLIF(k.target, 0)) AS average_progress FROM kr k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.8260624392874115,
      "finalSql": "SELECT CASE WHEN T1.metric = 'YES_NO' THEN 'YES_NO' WHEN T1.metric = 'NUMERIC' THEN 'NUMERIC' ELSE 'Other' END AS metric_type, AVG( CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / NULLIF(T1.target, 0) ELSE T1.target :: NUMERIC / NULLIF(T1.progress, 0) END ) AS average_progress FROM kr AS T1 WHERE T1.metric IN ('YES_NO', 'NUMERIC') GROUP BY metric_type;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.6630312196437058
    },
    {
      "question": "Quais iniciativas concentram mais KRs com métrica percentual?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, COUNT(k.id) AS percentage_kr_count FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY percentage_kr_count DESC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, COUNT(k.id) AS percentage_kr_count FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY percentage_kr_count DESC;",
      "executionTimeMs": 2817,
      "goldSql": "SELECT i.title, COUNT(k.id) AS total_percentage_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.id, i.title ORDER BY total_percentage_krs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9686669071821911,
      "finalSql": "SELECT i.title AS initiative_title, COUNT(k.id) AS percentage_kr_count FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY percentage_kr_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.33720930232558133,
      "queryAffinityScore": 0.6529381047538863
    },
    {
      "question": "Qual a média de progresso dos OKRs de iniciativas de alta prioridade?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(T2.progress * 100.0 / T2.target) FROM initiative AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id WHERE T1.priority = 'HIGH'",
          "error": "invalid input syntax for type integer: \"HIGH\""
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(T2.progress * 100.0 / T2.target) FROM initiative AS T1 JOIN okr AS T3 ON T1.id = T3.initiative_id JOIN kr AS T2 ON T3.id = T2.okr_id WHERE T1.priority = 1",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT AVG(T2.progress * 100.0 / T2.target) FROM initiative AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id WHERE T1.priority = 'HIGH'",
      "executionTimeMs": 3054,
      "goldSql": "SELECT AVG(k.progress / NULLIF(k.target, 0)) AS average_okr_progress_high_priority FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8994437802089745,
      "finalSql": "SELECT AVG(T2.progress * 100.0 / T2.target) FROM initiative AS T1 JOIN okr AS T3 ON T1.id = T3.initiative_id JOIN kr AS T2 ON T3.id = T2.okr_id WHERE T1.priority = 1",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.44972189010448727
    },
    {
      "question": "Qual o impacto dos updates de iniciativa no progresso dos KRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT iu.id AS initiative_update_id, iu.year_month, iu.highlights, iu.brutal_facts, iu.next_steps, k.title AS kr_title, k.metric AS kr_metric, k.direction AS kr_direction, k.target AS kr_target, kh.progress AS kr_progress_at_update_time, CASE WHEN k.direction = 'up' THEN (kh.progress * 1.0 / k.target) WHEN k.direction = 'down' THEN (k.target * 1.0 / kh.progress) ELSE NULL END AS kr_progress_percentage FROM initiative_update AS iu JOIN initiative AS i ON iu.initiative_id = i.id JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE iu.created_date <= kh.date AND iu.created_date >= (kh.date - INTERVAL '1 month') ORDER BY iu.created_date DESC, k.title;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT iu.id AS initiative_update_id, iu.year_month, iu.highlights, iu.brutal_facts, iu.next_steps, k.title AS kr_title, k.metric AS kr_metric, k.direction AS kr_direction, k.target AS kr_target, kh.progress AS kr_progress_at_update_time, CASE WHEN k.direction = 'up' AND k.target <> 0 THEN (kh.progress * 1.0 / k.target) WHEN k.direction = 'down' AND kh.progress <> 0 THEN (k.target * 1.0 / kh.progress) ELSE NULL END AS kr_progress_percentage FROM initiative_update AS iu JOIN initiative AS i ON iu.initiative_id = i.id JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE iu.created_date <= kh.date AND iu.created_date >= (kh.date - INTERVAL '1 month') ORDER BY iu.created_date DESC, k.title;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT iu.id AS initiative_update_id, iu.year_month, iu.highlights, iu.brutal_facts, iu.next_steps, k.title AS kr_title, k.metric AS kr_metric, k.direction AS kr_direction, k.target AS kr_target, kh.progress AS kr_progress_at_update_time, CASE WHEN k.direction = 'up' THEN (kh.progress * 1.0 / k.target) WHEN k.direction = 'down' THEN (k.target * 1.0 / kh.progress) ELSE NULL END AS kr_progress_percentage FROM initiative_update AS iu JOIN initiative AS i ON iu.initiative_id = i.id JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE iu.created_date <= kh.date AND iu.created_date >= (kh.date - INTERVAL '1 month') ORDER BY iu.created_date DESC, k.title;",
      "executionTimeMs": 3954,
      "goldSql": "WITH normalized_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(k.target,0)) AS rel_progress, LAG(kh.progress / NULLIF(k.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS rel_before FROM kr_history kh JOIN kr k ON k.id = kh.kr_id), updates AS (SELECT initiative_id, created_date FROM initiative_update), link AS (SELECT nh.kr_id, nh.rel_progress, nh.rel_before, nh.date AS progress_date, (SELECT iu.created_date FROM initiative_update iu JOIN kr k ON iu.initiative_id = k.okr_id JOIN okr o ON k.okr_id = o.id WHERE iu.initiative_id = o.initiative_id AND iu.created_date < nh.date ORDER BY iu.created_date DESC LIMIT 1) AS last_update FROM normalized_history nh JOIN kr k ON nh.kr_id = k.id JOIN okr o ON k.okr_id = o.id) SELECT AVG(rel_progress - rel_before) AS avg_progress_change_after_update FROM link WHERE rel_before IS NOT NULL AND last_update IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 0,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8168168170656449,
      "finalSql": "SELECT iu.id AS initiative_update_id, iu.year_month, iu.highlights, iu.brutal_facts, iu.next_steps, k.title AS kr_title, k.metric AS kr_metric, k.direction AS kr_direction, k.target AS kr_target, kh.progress AS kr_progress_at_update_time, CASE WHEN k.direction = 'up' AND k.target <> 0 THEN (kh.progress * 1.0 / k.target) WHEN k.direction = 'down' AND kh.progress <> 0 THEN (k.target * 1.0 / kh.progress) ELSE NULL END AS kr_progress_percentage FROM initiative_update AS iu JOIN initiative AS i ON iu.initiative_id = i.id JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE iu.created_date <= kh.date AND iu.created_date >= (kh.date - INTERVAL '1 month') ORDER BY iu.created_date DESC, k.title;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.40840840853282245
    },
    {
      "question": "Há aumento no ritmo de updates próximo aos deadlines dos OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id AS okr_id, o.deadline AS okr_deadline, COUNT(iu.id) AS total_updates, SUM(CASE WHEN iu.created_date >= (o.deadline - INTERVAL '7 days') THEN 1 ELSE 0 END) AS updates_near_deadline FROM okr AS o LEFT JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline HAVING COUNT(iu.id) > 0;"
        }
      ],
      "predictedSql": "SELECT o.id AS okr_id, o.deadline AS okr_deadline, COUNT(iu.id) AS total_updates, SUM(CASE WHEN iu.created_date >= (o.deadline - INTERVAL '7 days') THEN 1 ELSE 0 END) AS updates_near_deadline FROM okr AS o LEFT JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline HAVING COUNT(iu.id) > 0;",
      "executionTimeMs": 2977,
      "goldSql": "SELECT o.id AS okr_id, o.deadline, SUM(CASE WHEN iu.created_date BETWEEN o.deadline - INTERVAL '30 days' AND o.deadline THEN 1 ELSE 0 END) AS updates_last_30_days, SUM(CASE WHEN iu.created_date < o.deadline - INTERVAL '30 days' THEN 1 ELSE 0 END) AS updates_before_30_days FROM okr o LEFT JOIN initiative_update iu ON iu.initiative_id = o.initiative_id AND iu.created_date <= o.deadline GROUP BY o.id, o.deadline ORDER BY o.deadline;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8992268671102095,
      "finalSql": "SELECT o.id AS okr_id, o.deadline AS okr_deadline, COUNT(iu.id) AS total_updates, SUM(CASE WHEN iu.created_date >= (o.deadline - INTERVAL '7 days') THEN 1 ELSE 0 END) AS updates_near_deadline FROM okr AS o LEFT JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline HAVING COUNT(iu.id) > 0;",
      "executionMatch": false,
      "tableSimilarity": 0.6231343283582089,
      "queryAffinityScore": 0.7611805977342092
    },
    {
      "question": "Qual é o alinhamento entre as datas de fim de iniciativa e deadlines de OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id;",
      "executionTimeMs": 2566,
      "goldSql": "SELECT CASE WHEN o.deadline < i.end_date THEN 'OKR ANTES da Iniciativa' WHEN o.deadline = i.end_date THEN 'OKR e Iniciativa na MESMA DATA' WHEN o.deadline > i.end_date THEN 'OKR DEPOIS da Iniciativa' ELSE 'Sem data de fim para Iniciativa' END AS alinhamento, COUNT(o.id) AS total_okrs FROM okr o JOIN initiative i ON o.initiative_id = i.id GROUP BY alinhamento;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.6686682162031773,
      "finalSql": "SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.33433410810158865
    },
    {
      "question": "Quantos OKRs estão diretamente vinculados a iniciativas prioritárias (por categoria) e quantos ainda não possuem ligação clara com uma iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT CASE WHEN i.category IS NOT NULL THEN i.category ELSE 'Sem Iniciativa Vinculada' END AS categoria_iniciativa, COUNT(DISTINCT o.id) AS total_okrs FROM okr AS o LEFT JOIN kr AS k ON o.id = k.okr_id LEFT JOIN initiative AS i ON o.initiative_id = i.id GROUP BY categoria_iniciativa ORDER BY total_okrs DESC;"
        }
      ],
      "predictedSql": "SELECT CASE WHEN i.category IS NOT NULL THEN i.category ELSE 'Sem Iniciativa Vinculada' END AS categoria_iniciativa, COUNT(DISTINCT o.id) AS total_okrs FROM okr AS o LEFT JOIN kr AS k ON o.id = k.okr_id LEFT JOIN initiative AS i ON o.initiative_id = i.id GROUP BY categoria_iniciativa ORDER BY total_okrs DESC;",
      "executionTimeMs": 3174,
      "goldSql": "SELECT COALESCE(i.category, 'SEM INICIATIVA') AS category, COALESCE(i.priority, -1) AS priority, COUNT(o.id) AS okrs_count FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id GROUP BY category, priority ORDER BY category, priority;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8093036360549892,
      "finalSql": "SELECT CASE WHEN i.category IS NOT NULL THEN i.category ELSE 'Sem Iniciativa Vinculada' END AS categoria_iniciativa, COUNT(DISTINCT o.id) AS total_okrs FROM okr AS o LEFT JOIN kr AS k ON o.id = k.okr_id LEFT JOIN initiative AS i ON o.initiative_id = i.id GROUP BY categoria_iniciativa ORDER BY total_okrs DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.05555555555555547,
      "queryAffinityScore": 0.43242959580527235
    },
    {
      "question": "Quantas atualizações de iniciativas foram registradas neste trimestre e quais são os principais temas dos “highlights” e “brutal facts”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(iu.id) AS total_updates, SUBSTRING(iu.highlights FROM 1 FOR 50) AS highlight_snippet, SUBSTRING(iu.brutal_facts FROM 1 FOR 50) AS brutal_facts_snippet FROM initiative_update AS iu WHERE iu.created_date >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 month') AND iu.created_date < DATE_TRUNC('quarter', CURRENT_DATE) GROUP BY highlight_snippet, brutal_facts_snippet ORDER BY total_updates DESC;"
        }
      ],
      "predictedSql": "SELECT COUNT(iu.id) AS total_updates, SUBSTRING(iu.highlights FROM 1 FOR 50) AS highlight_snippet, SUBSTRING(iu.brutal_facts FROM 1 FOR 50) AS brutal_facts_snippet FROM initiative_update AS iu WHERE iu.created_date >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 month') AND iu.created_date < DATE_TRUNC('quarter', CURRENT_DATE) GROUP BY highlight_snippet, brutal_facts_snippet ORDER BY total_updates DESC;",
      "executionTimeMs": 3349,
      "goldSql": "SELECT COUNT(iu.id) AS total_updates_trimestre, STRING_AGG(iu.highlights, ' | ') AS todos_highlights, STRING_AGG(iu.brutal_facts, ' | ') AS todos_brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', CURRENT_DATE) AND iu.created_date < date_trunc('quarter', CURRENT_DATE) + interval '3 month';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8976700116938551,
      "finalSql": "SELECT COUNT(iu.id) AS total_updates, SUBSTRING(iu.highlights FROM 1 FOR 50) AS highlight_snippet, SUBSTRING(iu.brutal_facts FROM 1 FOR 50) AS brutal_facts_snippet FROM initiative_update AS iu WHERE iu.created_date >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 month') AND iu.created_date < DATE_TRUNC('quarter', CURRENT_DATE) GROUP BY highlight_snippet, brutal_facts_snippet ORDER BY total_updates DESC;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.44883500584692754
    },
    {
      "question": "Apresentar os KRs com maior desvio padrão de progresso ao longo do histórico, indicando instabilidade.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.title, STDDEV(CAST(T2.progress AS NUMERIC) / T2.target) AS progress_stddev FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id GROUP BY T1.title ORDER BY progress_stddev DESC;"
        }
      ],
      "predictedSql": "SELECT T1.title, STDDEV(CAST(T2.progress AS NUMERIC) / T2.target) AS progress_stddev FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id GROUP BY T1.title ORDER BY progress_stddev DESC;",
      "executionTimeMs": 3028,
      "goldSql": "SELECT k.title, o.description AS okr_description, STDDEV(kh.progress / NULLIF(kh.target, 0)) AS desvio_padrao_progresso FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id GROUP BY kh.kr_id, k.title, o.description HAVING COUNT(kh.id) > 1 ORDER BY desvio_padrao_progresso DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8038124419417453,
      "finalSql": "SELECT T1.title, STDDEV(CAST(T2.progress AS NUMERIC) / T2.target) AS progress_stddev FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id GROUP BY T1.title ORDER BY progress_stddev DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.1908333333333334,
      "queryAffinityScore": 0.49732288763753935
    },
    {
      "question": "Comparar o progresso médio dos KRs com o progresso médio das iniciativas às quais estão vinculados, destacando as maiores variações.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "{ \"sql\": \"WITH kr_progress_calc AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n CASE\\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\\n ELSE NULL\\n END AS kr_progress\\n FROM kr\\n),\\ninitiative_progress_calc AS (\\n SELECT\\n i.id AS initiative_id,\\n AVG(CASE\\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\\n ELSE NULL\\n END) AS initiative_avg_progress\\n FROM initiative AS i\\n JOIN okr AS o\\n ON i.okr_id = o.id\\n JOIN kr\\n ON o.id = kr.okr_id\\n GROUP BY\\n i.id\\n)\\nSELECT\\n krc.kr_id,\\n krc.kr_progress,\\n ipc.initiative_avg_progress,\\n ABS(krc.kr_progress - ipc.initiative_avg_progress) AS progress_difference\\nFROM kr_progress_calc AS krc\\nJOIN kr\\n ON krc.kr_id = kr.id\\nJOIN okr\\n ON kr.okr_id = okr.id\\nJOIN initiative_progress_calc AS ipc\\n ON okr.initiative_id = ipc.initiative_id\\nORDER BY\\n progress_difference DESC;\", \"complementaryText\": \"Esta query calcula o progresso individual de cada KR, considerando a direção ('up' ou 'down'), e o progresso médio de cada iniciativa. Em seguida, compara o progresso de cada KR com o progresso médio da iniciativa à qual ele pertence, destacando as maiores variações. As colunas retornadas são o ID do KR, o progresso do KR, o progresso médio da",
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH kr_progress_calc AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n CASE\\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\\n ELSE NULL\\n END AS kr_progress\\n FROM kr\\n),\\ninitiative_progress_calc AS (\\n SELECT\\n i.id AS initiative_id,\\n AVG(CASE\\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\\n ELSE NULL\\n END) AS initiative_avg_progress\\n FROM initiative AS i\\n JOIN okr AS o\\n ON i.id = o.initiative_id -- Corrected join condition\\n JOIN kr\\n ON o.id = kr.okr_id\\n GROUP BY\\n i.id\\n)\\nSELECT\\n krc.kr_id,\\n krc.kr_progress,\\n ipc.initiative_avg_progress,\\n ABS(krc.kr_progress - ipc.initiative_avg_progress) AS progress_difference\\nFROM kr_progress_calc AS krc\\nJOIN kr\\n ON krc.kr_id = kr.id\\nJOIN okr\\n ON kr.okr_id = okr.id\\nJOIN initiative_progress_calc AS ipc\\n ON okr.initiative_id = ipc.initiative_id\\nORDER BY\\n progress_difference DESC;\", \"explanation\": \"O erro 'syntax error at or near \\\"{\\\"' não estava relacionado ao SQL em si, mas sim ao formato da entrada JSON que continha o SQL. O SQL fornecido estava dentro de um objeto JSON com uma chave 'sql', o que não é um SQL válido por si só. Assumindo que o SQL dentro da string era o que deveria ser executado, o problema",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "WITH kr_progress_calc AS ( SELECT k.okr_id, k.id AS kr_id, CASE WHEN k.direction = 'up' THEN k.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::NUMERIC / k.target ELSE NULL END AS kr_progress FROM kr AS k ), initiative_progress_calc AS ( SELECT i.id AS initiative_id, AVG(CASE WHEN k.direction = 'up' THEN k.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::NUMERIC / k.target ELSE NULL END) AS initiative_avg_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id ) SELECT krc.kr_id, krc.kr_progress, ipc.initiative_avg_progress, ABS(krc.kr_progress - ipc.initiative_avg_progress) AS progress_difference FROM kr_progress_calc AS krc JOIN kr AS k ON krc.kr_id = k.id JOIN okr AS o ON k.okr_id = o.id JOIN initiative_progress_calc AS ipc ON o.initiative_id = ipc.initiative_id ORDER BY progress_difference DESC;",
          "fixed": true
        }
      ],
      "predictedSql": "{ \"sql\": \"WITH kr_progress_calc AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n CASE\\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\\n ELSE NULL\\n END AS kr_progress\\n FROM kr\\n),\\ninitiative_progress_calc AS (\\n SELECT\\n i.id AS initiative_id,\\n AVG(CASE\\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\\n ELSE NULL\\n END) AS initiative_avg_progress\\n FROM initiative AS i\\n JOIN okr AS o\\n ON i.okr_id = o.id\\n JOIN kr\\n ON o.id = kr.okr_id\\n GROUP BY\\n i.id\\n)\\nSELECT\\n krc.kr_id,\\n krc.kr_progress,\\n ipc.initiative_avg_progress,\\n ABS(krc.kr_progress - ipc.initiative_avg_progress) AS progress_difference\\nFROM kr_progress_calc AS krc\\nJOIN kr\\n ON krc.kr_id = kr.id\\nJOIN okr\\n ON kr.okr_id = okr.id\\nJOIN initiative_progress_calc AS ipc\\n ON okr.initiative_id = ipc.initiative_id\\nORDER BY\\n progress_difference DESC;\", \"complementaryText\": \"Esta query calcula o progresso individual de cada KR, considerando a direção ('up' ou 'down'), e o progresso médio de cada iniciativa. Em seguida, compara o progresso de cada KR com o progresso médio da iniciativa à qual ele pertence, destacando as maiores variações. As colunas retornadas são o ID do KR, o progresso do KR, o progresso médio da",
      "executionTimeMs": 4262,
      "goldSql": "WITH InitiativeProgress AS (SELECT i.id AS initiative_id, AVG(k.progress / NULLIF(k.target, 0)) AS avg_initiative_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id), CalculatedVariance AS (SELECT k.title AS kr_title, (k.progress / NULLIF(k.target, 0)) AS kr_current_progress, ip.avg_initiative_progress, (k.progress / NULLIF(k.target, 0)) - ip.avg_initiative_progress AS progress_variance FROM kr k JOIN okr o ON k.okr_id = o.id JOIN InitiativeProgress ip ON o.initiative_id = ip.initiative_id) SELECT kr_title, kr_current_progress, avg_initiative_progress, progress_variance FROM CalculatedVariance ORDER BY ABS(progress_variance) DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.6144869363377847,
      "finalSql": "WITH kr_progress_calc AS ( SELECT k.okr_id, k.id AS kr_id, CASE WHEN k.direction = 'up' THEN k.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::NUMERIC / k.target ELSE NULL END AS kr_progress FROM kr AS k ), initiative_progress_calc AS ( SELECT i.id AS initiative_id, AVG(CASE WHEN k.direction = 'up' THEN k.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::NUMERIC / k.target ELSE NULL END) AS initiative_avg_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id ) SELECT krc.kr_id, krc.kr_progress, ipc.initiative_avg_progress, ABS(krc.kr_progress - ipc.initiative_avg_progress) AS progress_difference FROM kr_progress_calc AS krc JOIN kr AS k ON krc.kr_id = k.id JOIN okr AS o ON k.okr_id = o.id JOIN initiative_progress_calc AS ipc ON o.initiative_id = ipc.initiative_id ORDER BY progress_difference DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.25670731707317074,
      "queryAffinityScore": 0.43559712670547773
    },
    {
      "question": "Construir o ranking das categorias de iniciativa com base no progresso médio ponderado pelo número de KRs associados.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END * (SELECT COUNT(*) FROM kr WHERE okr_id = o.id)) / SUM((SELECT COUNT(*) FROM kr WHERE okr_id = o.id)) AS weighted_average_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.category, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric WHEN k.direction = 'down' THEN (k.target - k.progress)::numeric ELSE 0 END) / COUNT(k.id) AS average_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category HAVING COUNT(k.id) > 0 ORDER BY average_progress DESC;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.category, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END * (SELECT COUNT(*) FROM kr WHERE okr_id = o.id)) / SUM((SELECT COUNT(*) FROM kr WHERE okr_id = o.id)) AS weighted_average_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;",
      "executionTimeMs": 3217,
      "goldSql": "SELECT i.category, AVG(k.progress / NULLIF(k.target, 0)) AS weighted_average_progress, COUNT(k.id) AS total_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8807122768216357,
      "finalSql": "SELECT i.category, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric WHEN k.direction = 'down' THEN (k.target - k.progress)::numeric ELSE 0 END) / COUNT(k.id) AS average_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category HAVING COUNT(k.id) > 0 ORDER BY average_progress DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.33333333333333337,
      "queryAffinityScore": 0.6070228050774845
    },
    {
      "question": "Avaliar a correlação entre o número de updates registrados em cada iniciativa e o progresso médio de seus KRs.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target ELSE NULL END) AS avg_kr_progress FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id LEFT JOIN okr AS o ON i.id = o.initiative_id LEFT JOIN kr ON o.id = kr.okr_id GROUP BY i.id, i.title ORDER BY num_updates DESC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target ELSE NULL END) AS avg_kr_progress FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id LEFT JOIN okr AS o ON i.id = o.initiative_id LEFT JOIN kr ON o.id = kr.okr_id GROUP BY i.id, i.title ORDER BY num_updates DESC;",
      "executionTimeMs": 3349,
      "goldSql": "WITH InitiativeMetrics AS (SELECT i.id AS initiative_id, COUNT(iu.id) AS total_updates, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id) SELECT CORR(im.total_updates, im.average_kr_progress) AS correlation_updates_vs_progress FROM InitiativeMetrics im;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.7787540164155996,
      "finalSql": "SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target ELSE NULL END) AS avg_kr_progress FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id LEFT JOIN okr AS o ON i.id = o.initiative_id LEFT JOIN kr ON o.id = kr.okr_id GROUP BY i.id, i.title ORDER BY num_updates DESC;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.3893770082077998
    },
    {
      "question": "Detectar iniciativas que apresentaram regressão média no progresso de KRs durante o último ciclo.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date) AS year,\\n EXTRACT(MONTH FROM kr_history.date) AS month,\\n MAX(kr_history.progress) AS latest_progress\\n FROM kr\\n JOIN kr_history ON kr.id = kr_history.kr_id\\n GROUP BY\\n kr.okr_id,\\n kr.id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date),\\n EXTRACT(MONTH FROM kr_history.date)\\n),\\nCalculatedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n CASE\\n WHEN direction = 'up' THEN latest_progress::NUMERIC / target\\n WHEN direction = 'down' THEN target::NUMERIC / latest_progress\\n ELSE NULL\\n END AS calculated_progress\\n FROM MonthlyProgress\\n),\\nLaggedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n calculated_progress,\\n LAG(calculated_progress, 1, calculated_progress) OVER (PARTITION BY kr_id ORDER BY year, month) AS previous_month_progress\\n FROM CalculatedProgress\\n),\\nInitiativeKRProgress AS (\\n SELECT\\n o.initiative_id,\\n l.kr_id,\\n l.year,\\n l.month,\\n l.calculated_progress,\\n l.previous_month_progress,\\n (l.calculated_progress - l.previous_month_progress) AS progress_change\\n FROM LaggedProgress AS l\\n JOIN okr AS o ON l.okr_id = o.id\\n),\\nAverageInitiativeProgressChange AS (\\n SELECT\\n initiative_id,\\n year,\\n month,\\n AVG(progress_change) AS average_",
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date) AS year,\\n EXTRACT(MONTH FROM kr_history.date) AS month,\\n MAX(kr_history.progress) AS latest_progress\\n FROM kr\\n JOIN kr_history ON kr.id = kr_history.kr_id\\n GROUP BY\\n kr.okr_id,\\n kr.id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date),\\n EXTRACT(MONTH FROM kr_history.date)\\n),\\nCalculatedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n CASE\\n WHEN direction = 'up' THEN latest_progress::NUMERIC / target\\n WHEN direction = 'down' THEN target::NUMERIC / latest_progress\\n ELSE NULL\\n END AS calculated_progress\\n FROM MonthlyProgress\\n),\\nLaggedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n calculated_progress,\\n LAG(calculated_progress, 1, calculated_progress) OVER (PARTITION BY kr_id ORDER BY year, month) AS previous_month_progress\\n FROM CalculatedProgress\\n),\\nInitiativeKRProgress AS (\\n SELECT\\n o.initiative_id,\\n l.kr_id,\\n l.year,\\n l.month,\\n l.calculated_progress,\\n l.previous_month_progress,\\n (l.calculated_progress - l.previous_month_progress) AS progress_change\\n FROM LaggedProgress AS l\\n JOIN okr AS o ON l.okr_id = o.id\\n),\\nAverageInitiativeProgressChange AS (\\n SELECT\\n initiative_id,\\n year,\\n month,\\n AVG(progress_change) AS average_",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date) AS year,\\n EXTRACT(MONTH FROM kr_history.date) AS month,\\n MAX(kr_history.progress) AS latest_progress\\n FROM kr\\n JOIN kr_history ON kr.id = kr_history.kr_id\\n GROUP BY\\n kr.okr_id,\\n kr.id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date),\\n EXTRACT(MONTH FROM kr_history.date)\\n),\\nCalculatedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n CASE\\n WHEN direction = 'up' THEN latest_progress::NUMERIC / target\\n WHEN direction = 'down' THEN target::NUMERIC / latest_progress\\n ELSE NULL\\n END AS calculated_progress\\n FROM MonthlyProgress\\n),\\nLaggedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n calculated_progress,\\n LAG(calculated_progress, 1, calculated_progress) OVER (PARTITION BY kr_id ORDER BY year, month) AS previous_month_progress\\n FROM CalculatedProgress\\n),\\nInitiativeKRProgress AS (\\n SELECT\\n o.initiative_id,\\n l.kr_id,\\n l.year,\\n l.month,\\n l.calculated_progress,\\n l.previous_month_progress,\\n (l.calculated_progress - l.previous_month_progress) AS progress_change\\n FROM LaggedProgress AS l\\n JOIN okr AS o ON l.okr_id = o.id\\n),\\nAverageInitiativeProgressChange AS (\\n SELECT\\n initiative_id,\\n year,\\n month,\\n AVG(progress_change) AS average_",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date) AS year,\\n EXTRACT(MONTH FROM kr_history.date) AS month,\\n MAX(kr_history.progress) AS latest_progress\\n FROM kr\\n JOIN kr_history ON kr.id = kr_history.kr_id\\n GROUP BY\\n kr.okr_id,\\n kr.id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date),\\n EXTRACT(MONTH FROM kr_history.date)\\n),\\nCalculatedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n CASE\\n WHEN direction = 'up' THEN latest_progress::NUMERIC / target\\n WHEN direction = 'down' THEN target::NUMERIC / latest_progress\\n ELSE NULL\\n END AS calculated_progress\\n FROM MonthlyProgress\\n),\\nLaggedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n calculated_progress,\\n LAG(calculated_progress, 1, calculated_progress) OVER (PARTITION BY kr_id ORDER BY year, month) AS previous_month_progress\\n FROM CalculatedProgress\\n),\\nInitiativeKRProgress AS (\\n SELECT\\n o.initiative_id,\\n l.kr_id,\\n l.year,\\n l.month,\\n l.calculated_progress,\\n l.previous_month_progress,\\n (l.calculated_progress - l.previous_month_progress) AS progress_change\\n FROM LaggedProgress AS l\\n JOIN okr AS o ON l.okr_id = o.id\\n),\\nAverageInitiativeProgressChange AS (\\n SELECT\\n initiative_id,\\n year,\\n month,\\n AVG(progress_change) AS average_",
      "executionTimeMs": 3720,
      "goldSql": "WITH hist AS (SELECT kh.kr_id, (kh.progress / NULLIF(kh.target,0)) AS rel, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev, o.initiative_id FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id), diffs AS (SELECT initiative_id, rel - prev AS diff FROM hist WHERE prev IS NOT NULL) SELECT i.title, AVG(diff) AS avg_regression_change FROM diffs d JOIN initiative i ON d.initiative_id = i.id GROUP BY i.id, i.title HAVING AVG(diff) < 0 ORDER BY avg_regression_change ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.4375
      },
      "cosineSimilarity": 0.6023579036768734,
      "finalSql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kr.okr_id,\\n kr.id AS kr_id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date) AS year,\\n EXTRACT(MONTH FROM kr_history.date) AS month,\\n MAX(kr_history.progress) AS latest_progress\\n FROM kr\\n JOIN kr_history ON kr.id = kr_history.kr_id\\n GROUP BY\\n kr.okr_id,\\n kr.id,\\n kr.direction,\\n kr.target,\\n EXTRACT(YEAR FROM kr_history.date),\\n EXTRACT(MONTH FROM kr_history.date)\\n),\\nCalculatedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n CASE\\n WHEN direction = 'up' THEN latest_progress::NUMERIC / target\\n WHEN direction = 'down' THEN target::NUMERIC / latest_progress\\n ELSE NULL\\n END AS calculated_progress\\n FROM MonthlyProgress\\n),\\nLaggedProgress AS (\\n SELECT\\n okr_id,\\n kr_id,\\n year,\\n month,\\n calculated_progress,\\n LAG(calculated_progress, 1, calculated_progress) OVER (PARTITION BY kr_id ORDER BY year, month) AS previous_month_progress\\n FROM CalculatedProgress\\n),\\nInitiativeKRProgress AS (\\n SELECT\\n o.initiative_id,\\n l.kr_id,\\n l.year,\\n l.month,\\n l.calculated_progress,\\n l.previous_month_progress,\\n (l.calculated_progress - l.previous_month_progress) AS progress_change\\n FROM LaggedProgress AS l\\n JOIN okr AS o ON l.okr_id = o.id\\n),\\nAverageInitiativeProgressChange AS (\\n SELECT\\n initiative_id,\\n year,\\n month,\\n AVG(progress_change) AS average_",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Qual a distribuição de iniciativas por categoria?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY initiative_count DESC;"
        }
      ],
      "predictedSql": "SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY initiative_count DESC;",
      "executionTimeMs": 2368,
      "goldSql": "SELECT category, COUNT(id) AS total_initiatives, CAST(COUNT(id) AS FLOAT) * 100 / (SELECT COUNT(*) FROM initiative) AS percentage FROM initiative GROUP BY category ORDER BY total_initiatives DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.7314931748323773,
      "finalSql": "SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY initiative_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.6666666666666667,
      "queryAffinityScore": 0.699079920749522
    },
    {
      "question": "Quais iniciativas têm mais OKRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;",
      "executionTimeMs": 2470,
      "goldSql": "SELECT i.title, COUNT(o.id) AS total_okrs FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY total_okrs DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.958102329590698,
      "finalSql": "SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.17391304347826086,
      "queryAffinityScore": 0.5660076865344794
    },
    {
      "question": "Quantas iniciativas estão em andamento neste trimestre?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();"
        }
      ],
      "predictedSql": "SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();",
      "executionTimeMs": 2480,
      "goldSql": "SELECT COUNT(id) FROM initiative WHERE start_date <= date_trunc('quarter', CURRENT_DATE) + INTERVAL '3 month' - INTERVAL '1 second' AND (end_date IS NULL OR end_date >= date_trunc('quarter', CURRENT_DATE));",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 1
      },
      "cosineSimilarity": 0.7218548000196441,
      "finalSql": "SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.860927400009822
    },
    {
      "question": "Quais iniciativas estão sem updates há mais de 30 dias?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.description AS initiative_description, iu.last_modified_date AS last_update_date FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id WHERE iu.last_modified_date IS NULL OR iu.last_modified_date < NOW() - INTERVAL '30 days';"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.description AS initiative_description, iu.last_modified_date AS last_update_date FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id WHERE iu.last_modified_date IS NULL OR iu.last_modified_date < NOW() - INTERVAL '30 days';",
      "executionTimeMs": 3171,
      "goldSql": "SELECT i.title, MAX(iu.created_date) AS last_update FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title HAVING MAX(iu.created_date) IS NULL OR MAX(iu.created_date) < NOW() - INTERVAL '30' DAY ORDER BY last_update ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8540547399493418,
      "finalSql": "SELECT i.title AS initiative_title, i.description AS initiative_description, iu.last_modified_date AS last_update_date FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id WHERE iu.last_modified_date IS NULL OR iu.last_modified_date < NOW() - INTERVAL '30 days';",
      "executionMatch": false,
      "tableSimilarity": 0.027042915931804856,
      "queryAffinityScore": 0.4405488279405733
    },
    {
      "question": "Quais iniciativas têm prioridade máxima, mas baixo progresso de OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.description AS initiative_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.description HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.5 ORDER BY avg_okr_progress ASC;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title AS initiative_title, i.description AS initiative_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.description HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) < 0.5 ORDER BY avg_okr_progress ASC;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.description AS initiative_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.description HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.5 ORDER BY avg_okr_progress ASC;",
      "executionTimeMs": 3457,
      "goldSql": "SELECT i.title, i.priority, AVG(k.progress / NULLIF(k.target, 0)) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.5 ORDER BY avg_okr_progress ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8824248105785323,
      "finalSql": "SELECT i.title AS initiative_title, i.description AS initiative_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.description HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) < 0.5 ORDER BY avg_okr_progress ASC;",
      "executionMatch": false,
      "tableSimilarity": 0.33333333333333337,
      "queryAffinityScore": 0.6078790719559328
    },
    {
      "question": "Quantas iniciativas estão planejadas para começar no próximo mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(id) FROM initiative WHERE start_date BETWEEN date_trunc('month', NOW() + INTERVAL '1 month') AND date_trunc('month', NOW() + INTERVAL '2 months') - INTERVAL '1 day'"
        }
      ],
      "predictedSql": "SELECT COUNT(id) FROM initiative WHERE start_date BETWEEN date_trunc('month', NOW() + INTERVAL '1 month') AND date_trunc('month', NOW() + INTERVAL '2 months') - INTERVAL '1 day'",
      "executionTimeMs": 2441,
      "goldSql": "SELECT COUNT(id) FROM initiative WHERE start_date >= date_trunc('month', CURRENT_DATE) + INTERVAL '1 month' AND start_date < date_trunc('month', CURRENT_DATE) + INTERVAL '2 month';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 1
      },
      "cosineSimilarity": 0.931119951417737,
      "finalSql": "SELECT COUNT(id) FROM initiative WHERE start_date BETWEEN date_trunc('month', NOW() + INTERVAL '1 month') AND date_trunc('month', NOW() + INTERVAL '2 months') - INTERVAL '1 day'",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9655599757088684
    },
    {
      "question": "Quais iniciativas têm fim previsto antes do término de seus OKRs?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT i.title AS initiative_title FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;"
        }
      ],
      "predictedSql": "SELECT DISTINCT i.title AS initiative_title FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;",
      "executionTimeMs": 2506,
      "goldSql": "SELECT i.title, i.end_date, MAX(o.deadline) AS latest_okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date IS NOT NULL GROUP BY i.id, i.title, i.end_date HAVING i.end_date < MAX(o.deadline);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8724519832763113,
      "finalSql": "SELECT DISTINCT i.title AS initiative_title FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9362259916381557
    },
    {
      "question": "Quais iniciativas têm mais de três pessoas no time?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.title FROM initiative AS T1 JOIN initiative_managers AS T2 ON T1.id = T2.initiative_id GROUP BY T1.id HAVING count(T2.managers_id) > 3"
        }
      ],
      "predictedSql": "SELECT T1.title FROM initiative AS T1 JOIN initiative_managers AS T2 ON T1.id = T2.initiative_id GROUP BY T1.id HAVING count(T2.managers_id) > 3",
      "executionTimeMs": 2824,
      "goldSql": "SELECT i.id, i.title, COUNT(im.managers_id) AS team_size FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id HAVING COUNT(im.managers_id) > 3",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8875311176296112,
      "finalSql": "SELECT T1.title FROM initiative AS T1 JOIN initiative_managers AS T2 ON T1.id = T2.initiative_id GROUP BY T1.id HAVING count(T2.managers_id) > 3",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9437655588148056
    },
    {
      "question": "Qual é a média de duração (em dias) das iniciativas concluídas?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;"
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;",
      "executionTimeMs": 2645,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;",
      "exactMatch": true,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 1
      },
      "cosineSimilarity": 1,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 1
    },
    {
      "question": "Qual percentual de iniciativas por categoria está concluído?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.category, SUM(CASE WHEN k.progress >= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'up' GROUP BY i.category UNION ALL SELECT i.category, SUM(CASE WHEN k.progress <= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'down' GROUP BY i.category;"
        }
      ],
      "predictedSql": "SELECT i.category, SUM(CASE WHEN k.progress >= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'up' GROUP BY i.category UNION ALL SELECT i.category, SUM(CASE WHEN k.progress <= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'down' GROUP BY i.category;",
      "executionTimeMs": 3191,
      "goldSql": "WITH InitiativeKRStatus AS (SELECT i.id AS initiative_id, i.category, CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END AS kr_is_concluded FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT category, CAST(SUM(kr_is_concluded) AS FLOAT) * 100 / COUNT(*) AS percent_krs_concluded FROM InitiativeKRStatus GROUP BY category ORDER BY percent_krs_concluded DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 0,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.9113234059457176,
      "finalSql": "SELECT i.category, SUM(CASE WHEN k.progress >= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'up' GROUP BY i.category UNION ALL SELECT i.category, SUM(CASE WHEN k.progress <= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'down' GROUP BY i.category;",
      "executionMatch": false,
      "tableSimilarity": 0.25,
      "queryAffinityScore": 0.5806617029728588
    },
    {
      "question": "Quais iniciativas estão com maior prioridade, mas apresentam baixo progresso ou atualizações atrasadas?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, i.priority, i.end_date, iu.year_month AS last_update_month FROM initiative AS i LEFT JOIN ( SELECT initiative_id, MAX(year_month) AS year_month FROM initiative_update GROUP BY initiative_id ) AS iu ON i.id = iu.initiative_id WHERE i.priority = 1 -- Assumindo que 1 é a maior prioridade AND ( NOT EXISTS ( SELECT 1 FROM kr WHERE kr.okr_id = i.id -- Assumindo que initiative.id é o okr_id para krs relacionados AND ( (kr.direction = 'up' AND kr.progress / kr.target >= 0.5) OR (kr.direction = 'down' AND kr.progress / kr.target <= 0.5) ) ) OR iu.year_month < TO_CHAR(NOW() - INTERVAL '1 month', 'YYYY-MM') -- Atualizações atrasadas (ex: mais de um mês) ) ORDER BY i.priority DESC, i.end_date ASC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, i.priority, i.end_date, iu.year_month AS last_update_month FROM initiative AS i LEFT JOIN ( SELECT initiative_id, MAX(year_month) AS year_month FROM initiative_update GROUP BY initiative_id ) AS iu ON i.id = iu.initiative_id WHERE i.priority = 1 -- Assumindo que 1 é a maior prioridade AND ( NOT EXISTS ( SELECT 1 FROM kr WHERE kr.okr_id = i.id -- Assumindo que initiative.id é o okr_id para krs relacionados AND ( (kr.direction = 'up' AND kr.progress / kr.target >= 0.5) OR (kr.direction = 'down' AND kr.progress / kr.target <= 0.5) ) ) OR iu.year_month < TO_CHAR(NOW() - INTERVAL '1 month', 'YYYY-MM') -- Atualizações atrasadas (ex: mais de um mês) ) ORDER BY i.priority DESC, i.end_date ASC;",
      "executionTimeMs": 3704,
      "goldSql": "WITH InitiativePerformance AS (SELECT i.id AS initiative_id, i.title, i.priority, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS avg_okr_progress, (SELECT MAX(created_date) FROM initiative_update iu WHERE iu.initiative_id = i.id) AS last_update_date FROM initiative i) SELECT title, priority, avg_okr_progress, last_update_date FROM InitiativePerformance WHERE priority = 1 AND (avg_okr_progress < 0.5 OR last_update_date < NOW() - INTERVAL '30 days' OR last_update_date IS NULL) ORDER BY avg_okr_progress ASC NULLS FIRST, last_update_date ASC NULLS FIRST;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.7950516324354031,
      "finalSql": "SELECT i.title AS initiative_title, i.priority, i.end_date, iu.year_month AS last_update_month FROM initiative AS i LEFT JOIN ( SELECT initiative_id, MAX(year_month) AS year_month FROM initiative_update GROUP BY initiative_id ) AS iu ON i.id = iu.initiative_id WHERE i.priority = 1 -- Assumindo que 1 é a maior prioridade AND ( NOT EXISTS ( SELECT 1 FROM kr WHERE kr.okr_id = i.id -- Assumindo que initiative.id é o okr_id para krs relacionados AND ( (kr.direction = 'up' AND kr.progress / kr.target >= 0.5) OR (kr.direction = 'down' AND kr.progress / kr.target <= 0.5) ) ) OR iu.year_month < TO_CHAR(NOW() - INTERVAL '1 month', 'YYYY-MM') -- Atualizações atrasadas (ex: mais de um mês) ) ORDER BY i.priority DESC, i.end_date ASC;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.6475258162177016
    },
    {
      "question": "Quais KRs estão com direção “NEGATIVA” (indicando desempenho decrescente) e estão abaixo de 50% do target?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT id, title, metric, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / target) < 0.5;"
        }
      ],
      "predictedSql": "SELECT id, title, metric, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / target) < 0.5;",
      "executionTimeMs": 2583,
      "goldSql": "SELECT title, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / NULLIF(target,0)) < 0.5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9402252877907419,
      "finalSql": "SELECT id, title, metric, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / target) < 0.5;",
      "executionMatch": false,
      "tableSimilarity": 0.6666666666666667,
      "queryAffinityScore": 0.8034459772287044
    },
    {
      "question": "Quais iniciativas apresentaram maior variação positiva de progresso nos últimos ciclos de atualização?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, MAX(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) - MIN(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) AS progress_variation FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date >= (NOW() - INTERVAL '3 months') GROUP BY i.title ORDER BY progress_variation DESC;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, MAX(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) - MIN(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) AS progress_variation FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date >= (NOW() - INTERVAL '3 months') GROUP BY i.title ORDER BY progress_variation DESC;",
      "executionTimeMs": 3275,
      "goldSql": "WITH NormHist AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh), Changes AS (SELECT nh.kr_id, nh.date, nh.norm_prog, nh.norm_prog - LAG(nh.norm_prog) OVER (PARTITION BY nh.kr_id ORDER BY nh.date) AS delta FROM NormHist nh), PosChanges AS (SELECT o.initiative_id, CASE WHEN k.direction = 'up'   AND delta > 0 THEN delta WHEN k.direction = 'down' AND delta < 0 THEN -delta END AS norm_delta FROM Changes c JOIN kr k ON c.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE delta IS NOT NULL AND c.date >= NOW() - INTERVAL '6 month' AND ((k.direction='up' AND delta > 0) OR (k.direction='down' AND delta < 0))) SELECT i.title, AVG(pc.norm_delta) AS avg_positive_change FROM initiative i JOIN PosChanges pc ON i.id = pc.initiative_id GROUP BY i.id, i.title ORDER BY avg_positive_change DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.7430650688205309,
      "finalSql": "SELECT i.title AS initiative_title, MAX(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) - MIN(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) AS progress_variation FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date >= (NOW() - INTERVAL '3 months') GROUP BY i.title ORDER BY progress_variation DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.09999999999999998,
      "queryAffinityScore": 0.42153253441026545
    },
    {
      "question": "Quais colaboradores foram responsáveis pelos KRs com melhor taxa de atingimento?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_achievement_rate FROM collaborator AS c JOIN kr AS k ON c.id = k.created_by GROUP BY c.name ORDER BY average_achievement_rate DESC;",
          "error": "operator does not exist: bigint = character varying"
        },
        {
          "attempt": 2,
          "sql": "SELECT c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_achievement_rate FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY average_achievement_rate DESC;",
          "fixed": true,
          "error": "division by zero"
        },
        {
          "attempt": 3,
          "sql": "SELECT c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress::numeric / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target::numeric / k.progress ELSE 0 -- Handle cases where target or progress is zero to avoid division by zero END) AS average_achievement_rate FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY average_achievement_rate DESC;",
          "fixed": true,
          "error": "syntax error at end of input"
        }
      ],
      "predictedSql": "SELECT c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_achievement_rate FROM collaborator AS c JOIN kr AS k ON c.id = k.created_by GROUP BY c.name ORDER BY average_achievement_rate DESC;",
      "executionTimeMs": 2747,
      "goldSql": "SELECT c.name, AVG(k.progress / k.target) AS avg_achievement_rate FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name HAVING COUNT(DISTINCT k.id) > 1 ORDER BY avg_achievement_rate DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8780315722239288,
      "finalSql": "SELECT c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress::numeric / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target::numeric / k.progress ELSE 0 -- Handle cases where target or progress is zero to avoid division by zero END) AS average_achievement_rate FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY average_achievement_rate DESC;",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at end of input",
      "executionMatch": false
    },
    {
      "question": "Quais colaboradores têm progresso médio de KRs acima da média geral dos colaboradores?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH CollaboratorKRProgress AS ( SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target WHEN k.direction = 'down' THEN k.target::numeric / k.progress ELSE NULL END) AS avg_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ), OverallAverage AS ( SELECT AVG(avg_kr_progress) AS overall_avg_progress FROM CollaboratorKRProgress ) SELECT ckp.collaborator_name, ckp.avg_kr_progress FROM CollaboratorKRProgress AS ckp, OverallAverage AS oa WHERE ckp.avg_kr_progress > oa.overall_avg_progress ORDER BY ckp.avg_kr_progress DESC;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "WITH CollaboratorKRProgress AS ( SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress::numeric / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target::numeric / k.progress ELSE NULL END) AS avg_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ), OverallAverage AS ( SELECT AVG(avg_kr_progress) AS overall_avg_progress FROM CollaboratorKRProgress ) SELECT ckp.collaborator_name, ckp.avg_kr_progress FROM CollaboratorKRProgress AS ckp, OverallAverage AS oa WHERE ckp.avg_kr_progress > oa.overall_avg_progress ORDER BY ckp.avg_kr_progress DESC;",
          "fixed": true
        }
      ],
      "predictedSql": "WITH CollaboratorKRProgress AS ( SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target WHEN k.direction = 'down' THEN k.target::numeric / k.progress ELSE NULL END) AS avg_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ), OverallAverage AS ( SELECT AVG(avg_kr_progress) AS overall_avg_progress FROM CollaboratorKRProgress ) SELECT ckp.collaborator_name, ckp.avg_kr_progress FROM CollaboratorKRProgress AS ckp, OverallAverage AS oa WHERE ckp.avg_kr_progress > oa.overall_avg_progress ORDER BY ckp.avg_kr_progress DESC;",
      "executionTimeMs": 3478,
      "goldSql": "WITH CollaboratorAvg AS (SELECT kh.collaborator_id, AVG(kh.progress / NULLIF(kh.target,0)) AS collaborator_progress FROM kr_history kh GROUP BY kh.collaborator_id), GlobalAvg AS (SELECT AVG(progress / NULLIF(target,0)) AS global_progress FROM kr_history) SELECT c.name, ca.collaborator_progress FROM collaborator c JOIN CollaboratorAvg ca ON c.id = ca.collaborator_id CROSS JOIN GlobalAvg ga WHERE ca.collaborator_progress > ga.global_progress ORDER BY ca.collaborator_progress DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8146596376155614,
      "finalSql": "WITH CollaboratorKRProgress AS ( SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress::numeric / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target::numeric / k.progress ELSE NULL END) AS avg_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ), OverallAverage AS ( SELECT AVG(avg_kr_progress) AS overall_avg_progress FROM CollaboratorKRProgress ) SELECT ckp.collaborator_name, ckp.avg_kr_progress FROM CollaboratorKRProgress AS ckp, OverallAverage AS oa WHERE ckp.avg_kr_progress > oa.overall_avg_progress ORDER BY ckp.avg_kr_progress DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.13043478260869568,
      "queryAffinityScore": 0.4725472101121285
    },
    {
      "question": "Quais colaboradores possuem mais KRs “bookmarked” do que a média geral de bookmarks por colaborador?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name HAVING COUNT(k.id) > (SELECT AVG(bookmarked_count) FROM (SELECT COUNT(id) AS bookmarked_count FROM kr WHERE bookmarked = TRUE GROUP BY bookmarked_by_id) AS avg_bookmarks);"
        }
      ],
      "predictedSql": "SELECT c.name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name HAVING COUNT(k.id) > (SELECT AVG(bookmarked_count) FROM (SELECT COUNT(id) AS bookmarked_count FROM kr WHERE bookmarked = TRUE GROUP BY bookmarked_by_id) AS avg_bookmarks);",
      "executionTimeMs": 2683,
      "goldSql": "WITH BookmarkCount AS ( SELECT bookmarked_by_id, COUNT(id) AS total_bookmarks FROM kr WHERE bookmarked_by_id IS NOT NULL GROUP BY bookmarked_by_id ), AvgBookmarks AS ( SELECT AVG(total_bookmarks) AS global_avg FROM BookmarkCount ) SELECT c.name, bc.total_bookmarks FROM collaborator c JOIN BookmarkCount bc ON c.id = bc.bookmarked_by_id CROSS JOIN AvgBookmarks ab WHERE bc.total_bookmarks > ab.global_avg ORDER BY bc.total_bookmarks DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8927205308178214,
      "finalSql": "SELECT c.name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name HAVING COUNT(k.id) > (SELECT AVG(bookmarked_count) FROM (SELECT COUNT(id) AS bookmarked_count FROM kr WHERE bookmarked = TRUE GROUP BY bookmarked_by_id) AS avg_bookmarks);",
      "executionMatch": false,
      "tableSimilarity": 0.2941176470588236,
      "queryAffinityScore": 0.5934190889383225
    },
    {
      "question": "Gerar o ranking de colaboradores com maior média de progresso em KRs dentro de cada categoria de iniciativa.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name AS collaborator_name, i.category AS initiative_category, AVG(CASE WHEN k.direction = 'up' THEN k.progress / k.target WHEN k.direction = 'down' THEN (k.target - k.progress) / k.target ELSE NULL END) AS average_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id JOIN okr AS o ON k.okr_id = o.id JOIN initiative AS i ON o.initiative_id = i.id GROUP BY c.name, i.category ORDER BY i.category, average_kr_progress DESC;"
        }
      ],
      "predictedSql": "SELECT c.name AS collaborator_name, i.category AS initiative_category, AVG(CASE WHEN k.direction = 'up' THEN k.progress / k.target WHEN k.direction = 'down' THEN (k.target - k.progress) / k.target ELSE NULL END) AS average_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id JOIN okr AS o ON k.okr_id = o.id JOIN initiative AS i ON o.initiative_id = i.id GROUP BY c.name, i.category ORDER BY i.category, average_kr_progress DESC;",
      "executionTimeMs": 3267,
      "goldSql": "SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8643779028399383,
      "finalSql": "SELECT c.name AS collaborator_name, i.category AS initiative_category, AVG(CASE WHEN k.direction = 'up' THEN k.progress / k.target WHEN k.direction = 'down' THEN (k.target - k.progress) / k.target ELSE NULL END) AS average_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id JOIN okr AS o ON k.okr_id = o.id JOIN initiative AS i ON o.initiative_id = i.id GROUP BY c.name, i.category ORDER BY i.category, average_kr_progress DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.3008849557522124,
      "queryAffinityScore": 0.5826314292960754
    },
    {
      "question": "Selecionar colaboradores que contribuíram para KRs com progresso superior ao percentil 90 global.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH KRProgress AS ( SELECT kh.collaborator_id, kh.kr_id, CASE WHEN k.direction = 'up' THEN kh.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN k.target::NUMERIC / kh.progress ELSE NULL END AS calculated_progress FROM kr_history AS kh JOIN kr AS k ON kh.kr_id = k.id WHERE kh.progress IS NOT NULL AND k.target IS NOT NULL AND k.target <> 0 AND kh.progress <> 0 ), Percentile90 AS ( SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM KRProgress ) SELECT DISTINCT c.name AS collaborator_name, c.email FROM collaborator AS c JOIN KRProgress AS kp ON c.id = kp.collaborator_id WHERE kp.calculated_progress > ( SELECT p90_value FROM Percentile90 );"
        }
      ],
      "predictedSql": "WITH KRProgress AS ( SELECT kh.collaborator_id, kh.kr_id, CASE WHEN k.direction = 'up' THEN kh.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN k.target::NUMERIC / kh.progress ELSE NULL END AS calculated_progress FROM kr_history AS kh JOIN kr AS k ON kh.kr_id = k.id WHERE kh.progress IS NOT NULL AND k.target IS NOT NULL AND k.target <> 0 AND kh.progress <> 0 ), Percentile90 AS ( SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM KRProgress ) SELECT DISTINCT c.name AS collaborator_name, c.email FROM collaborator AS c JOIN KRProgress AS kp ON c.id = kp.collaborator_id WHERE kp.calculated_progress > ( SELECT p90_value FROM Percentile90 );",
      "executionTimeMs": 4340,
      "goldSql": "WITH GlobalPercentile AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (progress / NULLIF(target,0))) AS p90_progress FROM kr_history) SELECT DISTINCT c.name FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id CROSS JOIN GlobalPercentile gp WHERE (kh.progress / NULLIF(kh.target,0)) > gp.p90_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.828214604161767,
      "finalSql": "WITH KRProgress AS ( SELECT kh.collaborator_id, kh.kr_id, CASE WHEN k.direction = 'up' THEN kh.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN k.target::NUMERIC / kh.progress ELSE NULL END AS calculated_progress FROM kr_history AS kh JOIN kr AS k ON kh.kr_id = k.id WHERE kh.progress IS NOT NULL AND k.target IS NOT NULL AND k.target <> 0 AND kh.progress <> 0 ), Percentile90 AS ( SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM KRProgress ) SELECT DISTINCT c.name AS collaborator_name, c.email FROM collaborator AS c JOIN KRProgress AS kp ON c.id = kp.collaborator_id WHERE kp.calculated_progress > ( SELECT p90_value FROM Percentile90 );",
      "executionMatch": false,
      "tableSimilarity": 0.35416666666666663,
      "queryAffinityScore": 0.5911906354142168
    },
    {
      "question": "Como evoluiu o progresso médio dos KRs nos últimos 6 meses?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT TO_CHAR(date_trunc('month', date), 'YYYY-MM') AS month, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target WHEN T1.direction = 'down' THEN T1.target :: NUMERIC / T1.progress ELSE NULL END) AS average_progress FROM kr_history AS T1 WHERE date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT TO_CHAR(date_trunc('month', kh.date), 'YYYY-MM') AS month, AVG( CASE WHEN kh.direction = 'up' AND kh.target != 0 THEN kh.progress :: NUMERIC / kh.target WHEN kh.direction = 'down' AND kh.progress != 0 THEN kh.target :: NUMERIC / kh.progress ELSE NULL END ) AS average_progress FROM kr_history AS kh WHERE kh.date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT TO_CHAR(date_trunc('month', date), 'YYYY-MM') AS month, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target WHEN T1.direction = 'down' THEN T1.target :: NUMERIC / T1.progress ELSE NULL END) AS average_progress FROM kr_history AS T1 WHERE date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;",
      "executionTimeMs": 3321,
      "goldSql": "SELECT DATE_TRUNC('month', date) AS month_start, AVG(progress / NULLIF(target,0)) AS avg_monthly_progress FROM kr_history WHERE date >= DATE_TRUNC('month', NOW() - INTERVAL '6 month') AND date <= NOW() GROUP BY month_start ORDER BY month_start;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8984050720398005,
      "finalSql": "SELECT TO_CHAR(date_trunc('month', kh.date), 'YYYY-MM') AS month, AVG( CASE WHEN kh.direction = 'up' AND kh.target != 0 THEN kh.progress :: NUMERIC / kh.target WHEN kh.direction = 'down' AND kh.progress != 0 THEN kh.target :: NUMERIC / kh.progress ELSE NULL END ) AS average_progress FROM kr_history AS kh WHERE kh.date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.44920253601990023
    },
    {
      "question": "Qual foi a variação de progresso por colaborador no último trimestre?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name AS collaborator_name, kh.kr_id, kh.metric, kh.direction, (kh_end.progress - kh_start.progress) AS progress_variation FROM collaborator AS c JOIN kr_history AS kh ON c.id = kh.collaborator_id JOIN kr_history AS kh_start ON kh.kr_id = kh_start.kr_id AND kh.collaborator_id = kh_start.collaborator_id JOIN kr_history AS kh_end ON kh.kr_id = kh_end.kr_id AND kh.collaborator_id = kh_end.collaborator_id WHERE kh.date >= NOW() - INTERVAL '3 months' AND kh.date <= NOW() AND kh_start.date = ( SELECT MIN(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date >= NOW() - INTERVAL '3 months' ) AND kh_end.date = ( SELECT MAX(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date <= NOW() ) GROUP BY c.name, kh.kr_id, kh.metric, kh.direction, progress_variation ORDER BY c.name, kh.kr_id;"
        }
      ],
      "predictedSql": "SELECT c.name AS collaborator_name, kh.kr_id, kh.metric, kh.direction, (kh_end.progress - kh_start.progress) AS progress_variation FROM collaborator AS c JOIN kr_history AS kh ON c.id = kh.collaborator_id JOIN kr_history AS kh_start ON kh.kr_id = kh_start.kr_id AND kh.collaborator_id = kh_start.collaborator_id JOIN kr_history AS kh_end ON kh.kr_id = kh_end.kr_id AND kh.collaborator_id = kh_end.collaborator_id WHERE kh.date >= NOW() - INTERVAL '3 months' AND kh.date <= NOW() AND kh_start.date = ( SELECT MIN(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date >= NOW() - INTERVAL '3 months' ) AND kh_end.date = ( SELECT MAX(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date <= NOW() ) GROUP BY c.name, kh.kr_id, kh.metric, kh.direction, progress_variation ORDER BY c.name, kh.kr_id;",
      "executionTimeMs": 4100,
      "goldSql": "WITH Hist AS (SELECT kh.collaborator_id, kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '3 month'), Ranked AS (SELECT collaborator_id, kr_id, norm_prog, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date ASC) AS rn_first, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date DESC) AS rn_last FROM Hist), FirstLast AS (SELECT collaborator_id, kr_id, MAX(CASE WHEN rn_first = 1 THEN norm_prog END) AS first_prog, MAX(CASE WHEN rn_last = 1 THEN norm_prog END) AS last_prog FROM Ranked GROUP BY collaborator_id, kr_id) SELECT c.name, AVG(last_prog - first_prog) AS progress_change_qtr FROM collaborator c JOIN FirstLast fl ON c.id = fl.collaborator_id GROUP BY c.id, c.name ORDER BY progress_change_qtr DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.8260243457549846,
      "finalSql": "SELECT c.name AS collaborator_name, kh.kr_id, kh.metric, kh.direction, (kh_end.progress - kh_start.progress) AS progress_variation FROM collaborator AS c JOIN kr_history AS kh ON c.id = kh.collaborator_id JOIN kr_history AS kh_start ON kh.kr_id = kh_start.kr_id AND kh.collaborator_id = kh_start.collaborator_id JOIN kr_history AS kh_end ON kh.kr_id = kh_end.kr_id AND kh.collaborator_id = kh_end.collaborator_id WHERE kh.date >= NOW() - INTERVAL '3 months' AND kh.date <= NOW() AND kh_start.date = ( SELECT MIN(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date >= NOW() - INTERVAL '3 months' ) AND kh_end.date = ( SELECT MAX(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date <= NOW() ) GROUP BY c.name, kh.kr_id, kh.metric, kh.direction, progress_variation ORDER BY c.name, kh.kr_id;",
      "executionMatch": false,
      "tableSimilarity": 0.04677419354838719,
      "queryAffinityScore": 0.4363992696516859
    },
    {
      "question": "Quantos registros de histórico de KR foram criados no último mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month'"
        }
      ],
      "predictedSql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month'",
      "executionTimeMs": 3033,
      "goldSql": "SELECT COUNT(id) AS history_count_last_month FROM kr_history WHERE date >= NOW() - INTERVAL '1' MONTH;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.9375
      },
      "cosineSimilarity": 0.9246993450045371,
      "finalSql": "SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month'",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9623496725022685
    },
    {
      "question": "Quais KRs apresentaram regressão de progresso em algum momento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT T1.title FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress < (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1)) OR (T1.direction = 'down' AND T2.progress > (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1));"
        }
      ],
      "predictedSql": "SELECT DISTINCT T1.title FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress < (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1)) OR (T1.direction = 'down' AND T2.progress > (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1));",
      "executionTimeMs": 2940,
      "goldSql": "WITH Regressions AS (SELECT kr_id, (progress / NULLIF(target,0)) AS norm_progress, LAG(progress / NULLIF(target,0)) OVER (PARTITION BY kr_id ORDER BY date) AS prev_norm_progress FROM kr_history) SELECT DISTINCT k.title FROM kr k JOIN Regressions r ON k.id = r.kr_id WHERE r.norm_progress < r.prev_norm_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 0,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.633455644224028,
      "finalSql": "SELECT DISTINCT T1.title FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress < (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1)) OR (T1.direction = 'down' AND T2.progress > (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1));",
      "executionMatch": false,
      "tableSimilarity": 0.9217391304347826,
      "queryAffinityScore": 0.7775973873294053
    },
    {
      "question": "Qual a média de variação percentual de progresso por métrica (PERC, NUMERIC, YES_NO)?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT kr.metric, AVG( CASE WHEN kr.direction = 'up' THEN kr.progress / kr.target WHEN kr.direction = 'down' THEN kr.target / kr.progress ELSE NULL END ) AS average_progress_percentage FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC', 'YES_NO') GROUP BY kr.metric;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT kr.metric, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN kr.target / NULLIF(kr.progress, 0) ELSE NULL END) AS average_progress_percentage FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC', 'YES_NO') GROUP BY kr.metric;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT kr.metric, AVG( CASE WHEN kr.direction = 'up' THEN kr.progress / kr.target WHEN kr.direction = 'down' THEN kr.target / kr.progress ELSE NULL END ) AS average_progress_percentage FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC', 'YES_NO') GROUP BY kr.metric;",
      "executionTimeMs": 3390,
      "goldSql": "WITH ranked_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog, k.metric, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_norm_prog FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), progress_changes AS (SELECT metric, ABS(norm_prog - prev_norm_prog) / NULLIF(prev_norm_prog, 0) * 100 AS variation_percent FROM ranked_history WHERE prev_norm_prog IS NOT NULL) SELECT metric, AVG(variation_percent) AS avg_variation_percent FROM progress_changes GROUP BY metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.7547381810080775,
      "finalSql": "SELECT kr.metric, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN kr.target / NULLIF(kr.progress, 0) ELSE NULL END) AS average_progress_percentage FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC', 'YES_NO') GROUP BY kr.metric;",
      "executionMatch": false,
      "tableSimilarity": 0.5,
      "queryAffinityScore": 0.6273690905040388
    },
    {
      "question": "Quantos KRs tiveram histórico de progresso acima de 90% antes do prazo final?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(DISTINCT T1.id) FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress * 1.0 / T1.target >= 0.9) OR (T1.direction = 'down' AND T2.progress * 1.0 / T1.target <= 0.1)"
        }
      ],
      "predictedSql": "SELECT COUNT(DISTINCT T1.id) FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress * 1.0 / T1.target >= 0.9) OR (T1.direction = 'down' AND T2.progress * 1.0 / T1.target <= 0.1)",
      "executionTimeMs": 3171,
      "goldSql": "SELECT COUNT(DISTINCT kh.kr_id) as krs_acima_90 FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE (kh.progress/k.target)*100 >= 90 AND kh.date < o.deadline;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8032927519465963,
      "finalSql": "SELECT COUNT(DISTINCT T1.id) FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress * 1.0 / T1.target >= 0.9) OR (T1.direction = 'down' AND T2.progress * 1.0 / T1.target <= 0.1)",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.40164637597329816
    },
    {
      "question": "Quais colaboradores atualizaram o maior número de KRs no histórico?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.name, COUNT(T2.kr_id) AS num_updates FROM collaborator AS T1 JOIN kr_history AS T2 ON T1.id = T2.collaborator_id GROUP BY T1.name ORDER BY num_updates DESC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT T1.name, COUNT(T2.kr_id) AS num_updates FROM collaborator AS T1 JOIN kr_history AS T2 ON T1.id = T2.collaborator_id GROUP BY T1.name ORDER BY num_updates DESC LIMIT 1;",
      "executionTimeMs": 2452,
      "goldSql": "SELECT c.id, c.name, COUNT(kh.id) as total_atualizacoes FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name ORDER BY total_atualizacoes DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8383807601940865,
      "finalSql": "SELECT T1.name, COUNT(T2.kr_id) AS num_updates FROM collaborator AS T1 JOIN kr_history AS T2 ON T1.id = T2.collaborator_id GROUP BY T1.name ORDER BY num_updates DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.033333333333333326,
      "queryAffinityScore": 0.4358570467637099
    },
    {
      "question": "Quantos updates de iniciativa foram registrados por mês neste ano?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(id) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;"
        }
      ],
      "predictedSql": "SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(id) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;",
      "executionTimeMs": 2821,
      "goldSql": "SELECT EXTRACT(YEAR FROM created_date) as ano, EXTRACT(MONTH FROM created_date) as mes, COUNT(*) as total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY ano, mes ORDER BY ano, mes;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.9118382895603839,
      "finalSql": "SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(id) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;",
      "executionMatch": false,
      "tableSimilarity": 0.33333333333333337,
      "queryAffinityScore": 0.6225858114468587
    },
    {
      "question": "Quais iniciativas tiveram maior número de updates em um único mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, TO_CHAR(iu.created_date, 'YYYY-MM') AS month FROM initiative AS i JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, TO_CHAR(iu.created_date, 'YYYY-MM') AS month FROM initiative AS i JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;",
      "executionTimeMs": 2649,
      "goldSql": "SELECT i.id, i.title, EXTRACT(YEAR FROM iu.created_date) as ano, EXTRACT(MONTH FROM iu.created_date) as mes, COUNT(iu.id) as updates_mes FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title, ano, mes ORDER BY updates_mes DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.9165250523091665,
      "finalSql": "SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, TO_CHAR(iu.created_date, 'YYYY-MM') AS month FROM initiative AS i JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.019999999999999907,
      "queryAffinityScore": 0.4682625261545832
    },
    {
      "question": "Qual o tempo médio entre updates consecutivos de uma mesma iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(diff_in_seconds) AS average_time_between_updates FROM ( SELECT initiative_id, created_date, LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date) AS previous_created_date, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) AS diff_in_seconds FROM initiative_update ) AS subquery WHERE previous_created_date IS NOT NULL;"
        }
      ],
      "predictedSql": "SELECT AVG(diff_in_seconds) AS average_time_between_updates FROM ( SELECT initiative_id, created_date, LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date) AS previous_created_date, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) AS diff_in_seconds FROM initiative_update ) AS subquery WHERE previous_created_date IS NOT NULL;",
      "executionTimeMs": 2813,
      "goldSql": "WITH update_gaps AS (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) / 86400 as dias_entre_updates FROM initiative_update) SELECT AVG(dias_entre_updates) as tempo_medio_dias FROM update_gaps WHERE dias_entre_updates IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8647430336732435,
      "finalSql": "SELECT AVG(diff_in_seconds) AS average_time_between_updates FROM ( SELECT initiative_id, created_date, LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date) AS previous_created_date, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) AS diff_in_seconds FROM initiative_update ) AS subquery WHERE previous_created_date IS NOT NULL;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4323715168366217
    },
    {
      "question": "Para cada iniciativa, qual é o KR mais recente e seu progresso atual?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, kr.title AS kr_title, kr.progress AS kr_current_progress, kr.target AS kr_target, kr.direction AS kr_direction, CASE WHEN kr.direction = 'up' THEN kr.progress :: NUMERIC / kr.target WHEN kr.direction = 'down' THEN CASE WHEN kr.progress <= kr.target THEN 1.0 ELSE kr.target :: NUMERIC / kr.progress END ELSE NULL END AS kr_calculated_progress FROM initiative AS i JOIN kr ON i.id = kr.okr_id WHERE kr.id IN ( SELECT MAX(kr_inner.id) FROM kr AS kr_inner GROUP BY kr_inner.okr_id ) ORDER BY i.title;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, kr.title AS kr_title, kr.progress AS kr_current_progress, kr.target AS kr_target, kr.direction AS kr_direction, CASE WHEN kr.direction = 'up' THEN kr.progress :: NUMERIC / kr.target WHEN kr.direction = 'down' THEN CASE WHEN kr.progress <= kr.target THEN 1.0 ELSE kr.target :: NUMERIC / kr.progress END ELSE NULL END AS kr_calculated_progress FROM initiative AS i JOIN kr ON i.id = kr.okr_id WHERE kr.id IN ( SELECT MAX(kr_inner.id) FROM kr AS kr_inner GROUP BY kr_inner.okr_id ) ORDER BY i.title;",
      "executionTimeMs": 3807,
      "goldSql": "WITH ranked_krs AS (SELECT i.id as iniciativa_id, i.title as iniciativa, k.id as kr_id, k.title as kr, k.progress, k.last_modified_date, ROW_NUMBER() OVER (PARTITION BY i.id ORDER BY k.last_modified_date DESC) as rn FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT iniciativa_id, iniciativa, kr_id, kr, progress FROM ranked_krs WHERE rn = 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.770869883142968,
      "finalSql": "SELECT i.title AS initiative_title, kr.title AS kr_title, kr.progress AS kr_current_progress, kr.target AS kr_target, kr.direction AS kr_direction, CASE WHEN kr.direction = 'up' THEN kr.progress :: NUMERIC / kr.target WHEN kr.direction = 'down' THEN CASE WHEN kr.progress <= kr.target THEN 1.0 ELSE kr.target :: NUMERIC / kr.progress END ELSE NULL END AS kr_calculated_progress FROM initiative AS i JOIN kr ON i.id = kr.okr_id WHERE kr.id IN ( SELECT MAX(kr_inner.id) FROM kr AS kr_inner GROUP BY kr_inner.okr_id ) ORDER BY i.title;",
      "executionMatch": false,
      "tableSimilarity": 0.26449275362318847,
      "queryAffinityScore": 0.5176813183830782
    },
    {
      "question": "Analisar a tendência de redução na frequência de updates conforme o deadline dos OKRs se aproxima.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT o.id AS okr_id, o.deadline, COUNT(iu.id) AS total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / (60 * 60 * 24)) AS avg_days_to_deadline_at_update FROM okr AS o JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline ORDER BY o.deadline;"
        }
      ],
      "predictedSql": "SELECT o.id AS okr_id, o.deadline, COUNT(iu.id) AS total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / (60 * 60 * 24)) AS avg_days_to_deadline_at_update FROM okr AS o JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline ORDER BY o.deadline;",
      "executionTimeMs": 3479,
      "goldSql": "SELECT i.id, i.title, o.deadline, COUNT(iu.id) as total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / 86400) as dias_antes_prazo_medio FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.created_date <= o.deadline GROUP BY i.id, i.title, o.deadline ORDER BY dias_antes_prazo_medio;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.9383830980284619,
      "finalSql": "SELECT o.id AS okr_id, o.deadline, COUNT(iu.id) AS total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / (60 * 60 * 24)) AS avg_days_to_deadline_at_update FROM okr AS o JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline ORDER BY o.deadline;",
      "executionMatch": false,
      "tableSimilarity": 0.19402985074626855,
      "queryAffinityScore": 0.5662064743873652
    },
    {
      "question": "Listar KRs com lacunas maiores que 30 dias entre atualizações de progresso",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.title AS kr_title, T1.metric, T1.direction, T1.target, T1.progress, T2.date AS update_date, LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date) AS previous_update_date, (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) AS time_difference FROM kr AS T1 INNER JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) > INTERVAL '30 days' ORDER BY T1.title, T2.date;",
          "error": "window functions are not allowed in WHERE"
        },
        {
          "attempt": 2,
          "sql": "WITH KrUpdateDifferences AS ( SELECT T1.title AS kr_title, T1.metric, T1.direction, T1.target, T1.progress, T2.date AS update_date, LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date) AS previous_update_date, (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) AS time_difference FROM kr AS T1 INNER JOIN kr_history AS T2 ON T1.id = T2.kr_id ) SELECT kr_title, metric, direction, target, progress, update_date, previous_update_date, time_difference FROM KrUpdateDifferences WHERE time_difference > INTERVAL '30 days' ORDER BY kr_title, update_date;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT T1.title AS kr_title, T1.metric, T1.direction, T1.target, T1.progress, T2.date AS update_date, LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date) AS previous_update_date, (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) AS time_difference FROM kr AS T1 INNER JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) > INTERVAL '30 days' ORDER BY T1.title, T2.date;",
      "executionTimeMs": 3557,
      "goldSql": "WITH kr_update_gaps AS (SELECT kh.kr_id, k.title as kr_title, kh.date as current_date, LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) as previous_date, EXTRACT(EPOCH FROM (kh.date - LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date))) / 86400 as dias_entre_atualizacoes FROM kr_history kh JOIN kr k ON kh.kr_id = k.id) SELECT kr_id, kr_title, previous_date, current_date, dias_entre_atualizacoes FROM kr_update_gaps WHERE dias_entre_atualizacoes > 30 ORDER BY dias_entre_atualizacoes DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.7709231776109192,
      "finalSql": "WITH KrUpdateDifferences AS ( SELECT T1.title AS kr_title, T1.metric, T1.direction, T1.target, T1.progress, T2.date AS update_date, LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date) AS previous_update_date, (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) AS time_difference FROM kr AS T1 INNER JOIN kr_history AS T2 ON T1.id = T2.kr_id ) SELECT kr_title, metric, direction, target, progress, update_date, previous_update_date, time_difference FROM KrUpdateDifferences WHERE time_difference > INTERVAL '30 days' ORDER BY kr_title, update_date;",
      "executionMatch": false,
      "tableSimilarity": 0.25083148558758317,
      "queryAffinityScore": 0.5108773315992512
    },
    {
      "question": "Quais OKRs estão com prazo próximo do vencimento?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT id, description, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days'"
        }
      ],
      "predictedSql": "SELECT id, description, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days'",
      "executionTimeMs": 2520,
      "goldSql": "SELECT id, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' ORDER BY deadline ASC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.9131065804149074,
      "finalSql": "SELECT id, description, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days'",
      "executionMatch": true,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9565532902074537
    },
    {
      "question": "Qual é a média de progresso dos KRs em cada OKR?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.title AS okr_title, AVG(CASE WHEN T2.direction = 'up' THEN T2.progress / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) / T2.target ELSE 0 END) AS average_kr_progress FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title;",
          "error": "column t1.title does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT T1.description AS okr_description, AVG(CASE WHEN T2.direction = 'up' THEN T2.progress / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) / T2.target ELSE 0 END) AS average_kr_progress FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT T1.title AS okr_title, AVG(CASE WHEN T2.direction = 'up' THEN T2.progress / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) / T2.target ELSE 0 END) AS average_kr_progress FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title;",
      "executionTimeMs": 3247,
      "goldSql": "SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.767340669490158,
      "finalSql": "SELECT T1.description AS okr_description, AVG(CASE WHEN T2.direction = 'up' THEN T2.progress / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) / T2.target ELSE 0 END) AS average_kr_progress FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description;",
      "executionMatch": false,
      "tableSimilarity": 0.02238805970149249,
      "queryAffinityScore": 0.39486436459582525
    },
    {
      "question": "Quais OKRs têm menor progresso médio?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.title AS okr_title, AVG( CASE WHEN T2.direction = 'up' THEN T2.progress :: NUMERIC / T2.target WHEN T2.direction = 'down' THEN T2.target :: NUMERIC / T2.progress ELSE NULL END ) AS average_progress FROM okr AS T1 INNER JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title ORDER BY average_progress LIMIT 1;",
          "error": "column t1.title does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT T1.description AS okr_description, AVG(CASE WHEN T2.direction = 'up' THEN T2.progress :: NUMERIC / T2.target WHEN T2.direction = 'down' THEN T2.target :: NUMERIC / T2.progress ELSE NULL END) AS average_progress FROM okr AS T1 INNER JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description ORDER BY average_progress LIMIT 1;",
          "fixed": true,
          "error": "division by zero"
        },
        {
          "attempt": 3,
          "sql": "SELECT T1.description AS okr_description, AVG( CASE WHEN T2.direction = 'up' AND T2.target <> 0 THEN T2.progress :: NUMERIC / T2.target WHEN T2.direction = 'down' AND T2.progress <> 0 THEN T2.target :: NUMERIC / T2.progress ELSE NULL END ) AS average_progress FROM okr AS T1 INNER JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description ORDER BY average_progress LIMIT 1;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT T1.title AS okr_title, AVG( CASE WHEN T2.direction = 'up' THEN T2.progress :: NUMERIC / T2.target WHEN T2.direction = 'down' THEN T2.target :: NUMERIC / T2.progress ELSE NULL END ) AS average_progress FROM okr AS T1 INNER JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title ORDER BY average_progress LIMIT 1;",
      "executionTimeMs": 3151,
      "goldSql": "SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id ORDER BY avg_progress ASC LIMIT 5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7760399138441033,
      "finalSql": "SELECT T1.description AS okr_description, AVG( CASE WHEN T2.direction = 'up' AND T2.target <> 0 THEN T2.progress :: NUMERIC / T2.target WHEN T2.direction = 'down' AND T2.progress <> 0 THEN T2.target :: NUMERIC / T2.progress ELSE NULL END ) AS average_progress FROM okr AS T1 INNER JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description ORDER BY average_progress LIMIT 1;",
      "executionMatch": false,
      "tableSimilarity": 0.09999999999999998,
      "queryAffinityScore": 0.43801995692205165
    },
    {
      "question": "Qual é o percentual de KRs concluídos por iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, CAST(SUM(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(k.id) AS completed_kr_percentage FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id GROUP BY i.title ORDER BY i.title;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, CAST(SUM(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(k.id) AS completed_kr_percentage FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id GROUP BY i.title ORDER BY i.title;",
      "executionTimeMs": 2893,
      "goldSql": "SELECT i.id AS initiative_id, SUM(CASE WHEN (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.9001926127905165,
      "finalSql": "SELECT i.title AS initiative_title, CAST(SUM(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(k.id) AS completed_kr_percentage FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id GROUP BY i.title ORDER BY i.title;",
      "executionMatch": false,
      "tableSimilarity": 0.10869565217391308,
      "queryAffinityScore": 0.5044441324822149
    },
    {
      "question": "Qual o tempo médio restante até o deadline dos OKRs ativos?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (T1.deadline - NOW()))) AS media_tempo_restante_segundos FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T2.active = TRUE AND T1.deadline IS NOT NULL AND T1.deadline > NOW();",
          "error": "column t2.active does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (T1.deadline - NOW()))) AS media_tempo_restante_segundos FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T1.deadline IS NOT NULL AND T1.deadline > NOW();",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (T1.deadline - NOW()))) AS media_tempo_restante_segundos FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T2.active = TRUE AND T1.deadline IS NOT NULL AND T1.deadline > NOW();",
      "executionTimeMs": 2896,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (deadline - NOW())) / 86400) AS avg_days_remaining FROM okr WHERE deadline > NOW();",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.7489243463567336,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (T1.deadline - NOW()))) AS media_tempo_restante_segundos FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T1.deadline IS NOT NULL AND T1.deadline > NOW();",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.3744621731783668
    },
    {
      "question": "Quais OKRs estão vinculados a iniciativas que já encerraram?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT T1.title FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id JOIN initiative AS T3 ON T1.initiative_id = T3.id WHERE T3.end_date < NOW();",
          "error": "column t1.title does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT T1.description FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T2.end_date < NOW();",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT DISTINCT T1.title FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id JOIN initiative AS T3 ON T1.initiative_id = T3.id WHERE T3.end_date < NOW();",
      "executionTimeMs": 2726,
      "goldSql": "SELECT o.id AS okr_id, o.initiative_id, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL AND i.end_date < NOW();",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8219556846047019,
      "finalSql": "SELECT T1.description FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T2.end_date < NOW();",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.41097784230235096
    },
    {
      "question": "Quantos KRs estão atrasados em relação à meta planejada?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(T1.id) FROM kr AS T1 JOIN okr AS T2 ON T1.okr_id = T2.id WHERE (T1.direction = 'up' AND T1.progress < T1.target AND T2.deadline < NOW()) OR (T1.direction = 'down' AND T1.progress > T1.target AND T2.deadline < NOW())"
        }
      ],
      "predictedSql": "SELECT COUNT(T1.id) FROM kr AS T1 JOIN okr AS T2 ON T1.okr_id = T2.id WHERE (T1.direction = 'up' AND T1.progress < T1.target AND T2.deadline < NOW()) OR (T1.direction = 'down' AND T1.progress > T1.target AND T2.deadline < NOW())",
      "executionTimeMs": 3414,
      "goldSql": "SELECT COUNT(*) AS delayed_kr_count FROM kr k JOIN kr_history kh ON kh.kr_id = k.id AND kh.date = (SELECT MAX(h.date) FROM kr_history h WHERE h.kr_id = k.id) WHERE (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) < 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > 1);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8430168607012538,
      "finalSql": "SELECT COUNT(T1.id) FROM kr AS T1 JOIN okr AS T2 ON T1.okr_id = T2.id WHERE (T1.direction = 'up' AND T1.progress < T1.target AND T2.deadline < NOW()) OR (T1.direction = 'down' AND T1.progress > T1.target AND T2.deadline < NOW())",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4215084303506269
    },
    {
      "question": "Qual o progresso médio dos KRs de tipo “PERC” em comparação aos de tipo “NUMERIC”?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_perc, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_numeric FROM kr AS T1 WHERE T1.metric = 'PERC' OR T1.metric = 'NUMERIC';"
        }
      ],
      "predictedSql": "SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_perc, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_numeric FROM kr AS T1 WHERE T1.metric = 'PERC' OR T1.metric = 'NUMERIC';",
      "executionTimeMs": 2796,
      "goldSql": "SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.805256988248903,
      "finalSql": "SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_perc, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_numeric FROM kr AS T1 WHERE T1.metric = 'PERC' OR T1.metric = 'NUMERIC';",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.4026284941244515
    },
    {
      "question": "Quais OKRs têm maior número de KRs associados?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.title, COUNT(T2.id) AS num_krs FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title ORDER BY num_krs DESC;",
          "error": "column t1.title does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT T1.description, COUNT(T2.id) AS num_krs FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description ORDER BY num_krs DESC;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT T1.title, COUNT(T2.id) AS num_krs FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title ORDER BY num_krs DESC;",
      "executionTimeMs": 2438,
      "goldSql": "SELECT okr_id, COUNT(*) AS kr_count FROM kr GROUP BY okr_id ORDER BY kr_count DESC LIMIT 5;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7309197212590386,
      "finalSql": "SELECT T1.description, COUNT(T2.id) AS num_krs FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description ORDER BY num_krs DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.038461538461538436,
      "queryAffinityScore": 0.3846906298602885
    },
    {
      "question": "Qual o percentual de KRs marcados como “bookmarked” pelos colaboradores?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT CAST(SUM(CASE WHEN T1.bookmarked = TRUE THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(T1.id) FROM kr AS T1"
        }
      ],
      "predictedSql": "SELECT CAST(SUM(CASE WHEN T1.bookmarked = TRUE THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(T1.id) FROM kr AS T1",
      "executionTimeMs": 2629,
      "goldSql": "SELECT COUNT(*) FILTER (WHERE bookmarked) * 100.0 / COUNT(*) AS percent_bookmarked FROM kr;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 1,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.875
      },
      "cosineSimilarity": 0.7512589969049918,
      "finalSql": "SELECT CAST(SUM(CASE WHEN T1.bookmarked = TRUE THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(T1.id) FROM kr AS T1",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.8756294984524959
    },
    {
      "question": "Qual é o percentual médio de progresso dos KRs (Key Results) em relação às metas estabelecidas nos últimos três meses?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target WHEN T1.direction = 'down' THEN T1.target :: NUMERIC / T1.progress ELSE NULL END) AS average_progress_percentage FROM kr AS T1 WHERE T1.created_date >= NOW() - INTERVAL '3 months';"
        }
      ],
      "predictedSql": "SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target WHEN T1.direction = 'down' THEN T1.target :: NUMERIC / T1.progress ELSE NULL END) AS average_progress_percentage FROM kr AS T1 WHERE T1.created_date >= NOW() - INTERVAL '3 months';",
      "executionTimeMs": 3193,
      "goldSql": "SELECT AVG(kh.progress / NULLIF(k.target, 0)) * 100 AS avg_progress_percent FROM kr k JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 months';",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.858718225628958,
      "finalSql": "SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target WHEN T1.direction = 'down' THEN T1.target :: NUMERIC / T1.progress ELSE NULL END) AS average_progress_percentage FROM kr AS T1 WHERE T1.created_date >= NOW() - INTERVAL '3 months';",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.429359112814479
    },
    {
      "question": "Quais colaboradores têm mais KRs marcados como “bookmarked” (favoritos) e demonstram maior engajamento com os objetivos da empresa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name ORDER BY bookmarked_kr_count DESC;"
        }
      ],
      "predictedSql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name ORDER BY bookmarked_kr_count DESC;",
      "executionTimeMs": 2607,
      "goldSql": "SELECT c.id, c.name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator c JOIN kr k ON k.bookmarked_by_id = c.id AND k.bookmarked = true GROUP BY c.id, c.name ORDER BY bookmarked_kr_count DESC LIMIT 10;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.9516723731875788,
      "finalSql": "SELECT c.name AS collaborator_name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name ORDER BY bookmarked_kr_count DESC;",
      "executionMatch": false,
      "tableSimilarity": 0.23188405797101452,
      "queryAffinityScore": 0.5917782155792967
    },
    {
      "question": "Qual é o tempo médio entre a criação de um OKR e a primeira atualização de progresso registrada?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS average_time_seconds FROM okr AS o JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date = (SELECT MIN(kh2.date) FROM kr_history AS kh2 WHERE kh2.kr_id = k.id);"
        }
      ],
      "predictedSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS average_time_seconds FROM okr AS o JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date = (SELECT MIN(kh2.date) FROM kr_history AS kh2 WHERE kh2.kr_id = k.id);",
      "executionTimeMs": 2926,
      "goldSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.first_update - o.created_date)) / 86400) AS avg_days_to_first_update FROM okr o JOIN (SELECT k.okr_id, MIN(kh.date) AS first_update FROM kr k JOIN kr_history kh ON kh.kr_id = k.id GROUP BY k.okr_id) kh ON kh.okr_id = o.id;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 1,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8648191465706683,
      "finalSql": "SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS average_time_seconds FROM okr AS o JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date = (SELECT MIN(kh2.date) FROM kr_history AS kh2 WHERE kh2.kr_id = k.id);",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.43240957328533414
    },
    {
      "question": "Quantos OKRs estão próximos do prazo final (deadline) e ainda não atingiram 80% de progresso?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT COUNT(DISTINCT T1.id) FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id WHERE T1.deadline IS NOT NULL AND T1.deadline <= NOW() + INTERVAL '7 days' AND (CASE WHEN T2.direction = 'up' THEN T2.progress * 1.0 / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) * 1.0 / T2.target ELSE 0 END) < 0.8;"
        }
      ],
      "predictedSql": "SELECT COUNT(DISTINCT T1.id) FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id WHERE T1.deadline IS NOT NULL AND T1.deadline <= NOW() + INTERVAL '7 days' AND (CASE WHEN T2.direction = 'up' THEN T2.progress * 1.0 / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) * 1.0 / T2.target ELSE 0 END) < 0.8;",
      "executionTimeMs": 3407,
      "goldSql": "SELECT COUNT(*) AS okrs_near_deadline_low_progress FROM ( SELECT o.id FROM okr o JOIN kr k ON k.okr_id = o.id WHERE o.deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' GROUP BY o.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8 ) sub;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.7983415635683815,
      "finalSql": "SELECT COUNT(DISTINCT T1.id) FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id WHERE T1.deadline IS NOT NULL AND T1.deadline <= NOW() + INTERVAL '7 days' AND (CASE WHEN T2.direction = 'up' THEN T2.progress * 1.0 / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) * 1.0 / T2.target ELSE 0 END) < 0.8;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.39917078178419074
    },
    {
      "question": "Quais iniciativas possuem OKRs cujo progresso médio supera o progresso médio global de todas as iniciativas da mesma categoria?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH InitiativeAvgProgress AS ( SELECT i.id AS initiative_id, i.category, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::numeric / k.target ELSE 0 END) AS avg_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.category ), CategoryGlobalAvgProgress AS ( SELECT category, AVG(avg_kr_progress) AS global_avg_progress FROM InitiativeAvgProgress GROUP BY category ) SELECT iap.initiative_id, iap.category, iap.avg_kr_progress FROM InitiativeAvgProgress AS iap JOIN CategoryGlobalAvgProgress AS cgap ON iap.category = cgap.category WHERE iap.avg_kr_progress > cgap.global_avg_progress;"
        }
      ],
      "predictedSql": "WITH InitiativeAvgProgress AS ( SELECT i.id AS initiative_id, i.category, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::numeric / k.target ELSE 0 END) AS avg_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.category ), CategoryGlobalAvgProgress AS ( SELECT category, AVG(avg_kr_progress) AS global_avg_progress FROM InitiativeAvgProgress GROUP BY category ) SELECT iap.initiative_id, iap.category, iap.avg_kr_progress FROM InitiativeAvgProgress AS iap JOIN CategoryGlobalAvgProgress AS cgap ON iap.category = cgap.category WHERE iap.avg_kr_progress > cgap.global_avg_progress;",
      "executionTimeMs": 3608,
      "goldSql": "WITH initiative_avg AS (SELECT i.id, i.category, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, i.category), category_avg AS (SELECT category, AVG(avg_progress) AS category_avg_progress FROM initiative_avg GROUP BY category) SELECT ia.id, ia.category, ia.avg_progress FROM initiative_avg ia JOIN category_avg ca ON ia.category = ca.category WHERE ia.avg_progress > ca.category_avg_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8991262950662456,
      "finalSql": "WITH InitiativeAvgProgress AS ( SELECT i.id AS initiative_id, i.category, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::numeric / k.target ELSE 0 END) AS avg_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.category ), CategoryGlobalAvgProgress AS ( SELECT category, AVG(avg_kr_progress) AS global_avg_progress FROM InitiativeAvgProgress GROUP BY category ) SELECT iap.initiative_id, iap.category, iap.avg_kr_progress FROM InitiativeAvgProgress AS iap JOIN CategoryGlobalAvgProgress AS cgap ON iap.category = cgap.category WHERE iap.avg_kr_progress > cgap.global_avg_progress;",
      "executionMatch": false,
      "tableSimilarity": 0.5416666666666667,
      "queryAffinityScore": 0.7203964808664562
    },
    {
      "question": "Qual colaborador teve o maior aumento percentual de progresso médio de KRs entre o último e o penúltimo mês?",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kh.collaborator_id,\\n c.name AS collaborator_name,\\n DATE_TRUNC('month', kh.date) AS month_start,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN kh.progress::numeric / kh.target\\n WHEN k.direction = 'down' THEN kh.target::numeric / kh.progress\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr_history AS kh\\n JOIN kr AS k\\n ON kh.kr_id = k.id\\n JOIN collaborator AS c\\n ON kh.collaborator_id = c.id\\n GROUP BY\\n kh.collaborator_id,\\n c.name,\\n DATE_TRUNC('month', kh.date)\\n),\\nRankedProgress AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n RANK() OVER (PARTITION BY collaborator_id ORDER BY month_start DESC) AS rn\\n FROM MonthlyProgress\\n),\\nLastTwoMonths AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress\\n FROM RankedProgress\\n WHERE\\n rn <= 2\\n)\\nSELECT\\n l2.collaborator_name,\\n (\\n (l2.avg_kr_progress - l1.avg_kr_progress) / l1.avg_kr_progress\\n ) * 100 AS percentage_increase\\nFROM LastTwoMonths AS l1\\nJOIN LastTwoMonths AS l2\\n ON l1.collaborator_id = l2.collaborator_id\\nWHERE\\n l1.rn = 2 AND l2.rn = 1 AND l1.avg_kr_progress IS NOT NULL AND l1.avg_kr_progress <> 0\\nORDER BY\\n percentage_increase DESC\\nLIMIT 1;\", \"complementaryText\": \"Esta query identifica",
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kh.collaborator_id,\\n c.name AS collaborator_name,\\n DATE_TRUNC('month', kh.date) AS month_start,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN kh.progress::numeric / kh.target\\n WHEN k.direction = 'down' THEN kh.target::numeric / kh.progress\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr_history AS kh\\n JOIN kr AS k\\n ON kh.kr_id = k.id\\n JOIN collaborator AS c\\n ON kh.collaborator_id = c.id\\n GROUP BY\\n kh.collaborator_id,\\n c.name,\\n DATE_TRUNC('month', kh.date)\\n),\\nRankedProgress AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n RANK() OVER (PARTITION BY collaborator_id ORDER BY month_start DESC) AS rn\\n FROM MonthlyProgress\\n),\\nLastTwoMonths AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n rn\\n FROM RankedProgress\\n WHERE\\n rn <= 2\\n)\\nSELECT\\n l2.collaborator_name,\\n (\\n (l2.avg_kr_progress - l1.avg_kr_progress) / l1.avg_kr_progress\\n ) * 100 AS percentage_increase\\nFROM LastTwoMonths AS l1\\nJOIN LastTwoMonths AS l2\\n ON l1.collaborator_id = l2.collaborator_id\\nWHERE\\n l1.rn = 2 AND l2.rn = 1 AND l1.avg_kr_progress IS NOT NULL AND l1.avg_kr_progress <> 0\\nORDER BY\\n percentage_increase DESC\\nLIMIT 1;\", \"explanation\": \"O",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kh.collaborator_id,\\n c.name AS collaborator_name,\\n DATE_TRUNC('month', kh.date) AS month_start,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN kh.progress::numeric / kh.target\\n WHEN k.direction = 'down' THEN kh.target::numeric / kh.progress\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr_history AS kh\\n JOIN kr AS k\\n ON kh.kr_id = k.id\\n JOIN collaborator AS c\\n ON kh.collaborator_id = c.id\\n GROUP BY\\n kh.collaborator_id,\\n c.name,\\n DATE_TRUNC('month', kh.date)\\n),\\nRankedProgress AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n RANK() OVER (PARTITION BY collaborator_id ORDER BY month_start DESC) AS rn\\n FROM MonthlyProgress\\n),\\nLastTwoMonths AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n rn\\n FROM RankedProgress\\n WHERE\\n rn <= 2\\n)\\nSELECT\\n l2.collaborator_name,\\n (\\n (l2.avg_kr_progress - l1.avg_kr_progress) / l1.avg_kr_progress\\n ) * 100 AS percentage_increase\\nFROM LastTwoMonths AS l1\\nJOIN LastTwoMonths AS l2\\n ON l1.collaborator_id = l2.collaborator_id\\nWHERE\\n l1.rn = 2 AND l2.rn = 1 AND l1.avg_kr_progress IS NOT NULL AND l1.avg_kr_progress <> 0\\nORDER BY\\n percentage_increase DESC\\nLIMIT 1;\", \"explanation\": \"O",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kh.collaborator_id,\\n c.name AS collaborator_name,\\n DATE_TRUNC('month', kh.date) AS month_start,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN kh.progress::numeric / kh.target\\n WHEN k.direction = 'down' THEN kh.target::numeric / kh.progress\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr_history AS kh\\n JOIN kr AS k\\n ON kh.kr_id = k.id\\n JOIN collaborator AS c\\n ON kh.collaborator_id = c.id\\n GROUP BY\\n kh.collaborator_id,\\n c.name,\\n DATE_TRUNC('month', kh.date)\\n),\\nRankedProgress AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n RANK() OVER (PARTITION BY collaborator_id ORDER BY month_start DESC) AS rn\\n FROM MonthlyProgress\\n),\\nLastTwoMonths AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress\\n FROM RankedProgress\\n WHERE\\n rn <= 2\\n)\\nSELECT\\n l2.collaborator_name,\\n (\\n (l2.avg_kr_progress - l1.avg_kr_progress) / l1.avg_kr_progress\\n ) * 100 AS percentage_increase\\nFROM LastTwoMonths AS l1\\nJOIN LastTwoMonths AS l2\\n ON l1.collaborator_id = l2.collaborator_id\\nWHERE\\n l1.rn = 2 AND l2.rn = 1 AND l1.avg_kr_progress IS NOT NULL AND l1.avg_kr_progress <> 0\\nORDER BY\\n percentage_increase DESC\\nLIMIT 1;\", \"complementaryText\": \"Esta query identifica",
      "executionTimeMs": 3938,
      "goldSql": "WITH monthly_progress AS (SELECT collaborator_id, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr_history GROUP BY collaborator_id, month), ranked_progress AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY collaborator_id ORDER BY month DESC) AS rn FROM monthly_progress), last_two_months AS (SELECT p1.collaborator_id, p1.avg_progress AS last_month_progress, p2.avg_progress AS prev_month_progress, CASE WHEN p2.avg_progress = 0 THEN NULL ELSE ((p1.avg_progress - p2.avg_progress) / p2.avg_progress) * 100 END AS pct_increase FROM ranked_progress p1 JOIN ranked_progress p2 ON p1.collaborator_id = p2.collaborator_id WHERE p1.rn = 1 AND p2.rn = 2) SELECT collaborator_id, pct_increase FROM last_two_months ORDER BY pct_increase DESC LIMIT 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.7483482076627865,
      "finalSql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n kh.collaborator_id,\\n c.name AS collaborator_name,\\n DATE_TRUNC('month', kh.date) AS month_start,\\n AVG(CASE\\n WHEN k.direction = 'up' THEN kh.progress::numeric / kh.target\\n WHEN k.direction = 'down' THEN kh.target::numeric / kh.progress\\n ELSE 0\\n END) AS avg_kr_progress\\n FROM kr_history AS kh\\n JOIN kr AS k\\n ON kh.kr_id = k.id\\n JOIN collaborator AS c\\n ON kh.collaborator_id = c.id\\n GROUP BY\\n kh.collaborator_id,\\n c.name,\\n DATE_TRUNC('month', kh.date)\\n),\\nRankedProgress AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n RANK() OVER (PARTITION BY collaborator_id ORDER BY month_start DESC) AS rn\\n FROM MonthlyProgress\\n),\\nLastTwoMonths AS (\\n SELECT\\n collaborator_id,\\n collaborator_name,\\n month_start,\\n avg_kr_progress,\\n rn\\n FROM RankedProgress\\n WHERE\\n rn <= 2\\n)\\nSELECT\\n l2.collaborator_name,\\n (\\n (l2.avg_kr_progress - l1.avg_kr_progress) / l1.avg_kr_progress\\n ) * 100 AS percentage_increase\\nFROM LastTwoMonths AS l1\\nJOIN LastTwoMonths AS l2\\n ON l1.collaborator_id = l2.collaborator_id\\nWHERE\\n l1.rn = 2 AND l2.rn = 1 AND l1.avg_kr_progress IS NOT NULL AND l1.avg_kr_progress <> 0\\nORDER BY\\n percentage_increase DESC\\nLIMIT 1;\", \"explanation\": \"O",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Quais iniciativas tiveram pelo menos um KR com progresso superior a 100% em algum ponto do histórico?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT i.title FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE (k.direction = 'up' AND kh.progress > kh.target) OR (k.direction = 'down' AND kh.progress < kh.target)"
        }
      ],
      "predictedSql": "SELECT DISTINCT i.title FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE (k.direction = 'up' AND kh.progress > kh.target) OR (k.direction = 'down' AND kh.progress < kh.target)",
      "executionTimeMs": 3125,
      "goldSql": "SELECT DISTINCT i.id, i.title FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target, 0) > 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8713197058485143,
      "finalSql": "SELECT DISTINCT i.title FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE (k.direction = 'up' AND kh.progress > kh.target) OR (k.direction = 'down' AND kh.progress < kh.target)",
      "executionMatch": false,
      "tableSimilarity": 0.18518518518518512,
      "queryAffinityScore": 0.5282524455168497
    },
    {
      "question": "Qual é o tempo médio (em dias) entre atualizações consecutivas de um mesmo KR no histórico?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT AVG(diff_days) FROM (SELECT kr_id, date, LAG(date) OVER (PARTITION BY kr_id ORDER BY date) AS prev_date, EXTRACT(EPOCH FROM (date - LAG(date) OVER (PARTITION BY kr_id ORDER BY date))) / 86400 AS diff_days FROM kr_history) AS subquery WHERE diff_days IS NOT NULL;"
        }
      ],
      "predictedSql": "SELECT AVG(diff_days) FROM (SELECT kr_id, date, LAG(date) OVER (PARTITION BY kr_id ORDER BY date) AS prev_date, EXTRACT(EPOCH FROM (date - LAG(date) OVER (PARTITION BY kr_id ORDER BY date))) / 86400 AS diff_days FROM kr_history) AS subquery WHERE diff_days IS NOT NULL;",
      "executionTimeMs": 2735,
      "goldSql": "WITH diffs AS (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date FROM kr_history) SELECT AVG(EXTRACT(EPOCH FROM (next_date - date)) / 86400) AS avg_days_between_updates FROM diffs WHERE next_date IS NOT NULL;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 1,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8722250098827731,
      "finalSql": "SELECT AVG(diff_days) FROM (SELECT kr_id, date, LAG(date) OVER (PARTITION BY kr_id ORDER BY date) AS prev_date, EXTRACT(EPOCH FROM (date - LAG(date) OVER (PARTITION BY kr_id ORDER BY date))) / 86400 AS diff_days FROM kr_history) AS subquery WHERE diff_days IS NOT NULL;",
      "executionMatch": false,
      "tableSimilarity": 1,
      "queryAffinityScore": 0.9361125049413865
    },
    {
      "question": "Quais iniciativas têm pelo menos dois OKRs com deadlines no mesmo mês?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title, EXTRACT(MONTH FROM o.deadline), EXTRACT(YEAR FROM o.deadline) HAVING COUNT(o.id) >= 2;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title, EXTRACT(MONTH FROM o.deadline), EXTRACT(YEAR FROM o.deadline) HAVING COUNT(o.id) >= 2;",
      "executionTimeMs": 2714,
      "goldSql": "SELECT initiative_id FROM okr GROUP BY initiative_id, DATE_TRUNC('month', deadline) HAVING COUNT(*) >= 2;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.75
      },
      "cosineSimilarity": 0.8394963186389475,
      "finalSql": "SELECT i.title AS initiative_title FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title, EXTRACT(MONTH FROM o.deadline), EXTRACT(YEAR FROM o.deadline) HAVING COUNT(o.id) >= 2;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.41974815931947373
    },
    {
      "question": "Qual é a distribuição percentual de KRs por tipo de métrica dentro de cada iniciativa?",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, kr.metric, COUNT(kr.id) AS kr_count, (COUNT(kr.id) * 100.0 / SUM(COUNT(kr.id)) OVER (PARTITION BY i.id)) AS percentage FROM initiative AS i JOIN kr ON i.id = kr.okr_id GROUP BY i.id, i.title, kr.metric ORDER BY i.title, kr.metric;"
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, kr.metric, COUNT(kr.id) AS kr_count, (COUNT(kr.id) * 100.0 / SUM(COUNT(kr.id)) OVER (PARTITION BY i.id)) AS percentage FROM initiative AS i JOIN kr ON i.id = kr.okr_id GROUP BY i.id, i.title, kr.metric ORDER BY i.title, kr.metric;",
      "executionTimeMs": 3122,
      "goldSql": "WITH kr_counts AS (SELECT i.id AS initiative_id, k.metric, COUNT(*) AS count FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, k.metric), initiative_totals AS (SELECT initiative_id, SUM(count) AS total FROM kr_counts GROUP BY initiative_id) SELECT kc.initiative_id, kc.metric, (kc.count::float / it.total) * 100 AS percent FROM kr_counts kc JOIN initiative_totals it ON kc.initiative_id = it.initiative_id ORDER BY kc.initiative_id, percent DESC;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.625
      },
      "cosineSimilarity": 0.8575678722325109,
      "finalSql": "SELECT i.title AS initiative_title, kr.metric, COUNT(kr.id) AS kr_count, (COUNT(kr.id) * 100.0 / SUM(COUNT(kr.id)) OVER (PARTITION BY i.id)) AS percentage FROM initiative AS i JOIN kr ON i.id = kr.okr_id GROUP BY i.id, i.title, kr.metric ORDER BY i.title, kr.metric;",
      "executionMatch": false,
      "tableSimilarity": 0.18097014925373134,
      "queryAffinityScore": 0.519269010743121
    },
    {
      "question": "Listar os KRs cujo progresso atual está abaixo da média dos KRs do mesmo tipo e direção.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "WITH KRProgress AS ( SELECT id, metric, direction, progress, target, CASE WHEN direction = 'up' THEN progress::NUMERIC / target WHEN direction = 'down' THEN (target - progress)::NUMERIC / target ELSE NULL END AS calculated_progress FROM kr ), AverageProgress AS ( SELECT metric, direction, AVG(calculated_progress) AS avg_progress FROM KRProgress GROUP BY metric, direction ) SELECT kp.id, kp.metric, kp.direction, kp.progress, kp.target, kp.calculated_progress FROM KRProgress AS kp JOIN AverageProgress AS ap ON kp.metric = ap.metric AND kp.direction = ap.direction WHERE kp.calculated_progress < ap.avg_progress;"
        }
      ],
      "predictedSql": "WITH KRProgress AS ( SELECT id, metric, direction, progress, target, CASE WHEN direction = 'up' THEN progress::NUMERIC / target WHEN direction = 'down' THEN (target - progress)::NUMERIC / target ELSE NULL END AS calculated_progress FROM kr ), AverageProgress AS ( SELECT metric, direction, AVG(calculated_progress) AS avg_progress FROM KRProgress GROUP BY metric, direction ) SELECT kp.id, kp.metric, kp.direction, kp.progress, kp.target, kp.calculated_progress FROM KRProgress AS kp JOIN AverageProgress AS ap ON kp.metric = ap.metric AND kp.direction = ap.direction WHERE kp.calculated_progress < ap.avg_progress;",
      "executionTimeMs": 3692,
      "goldSql": "WITH avg_progress AS (SELECT metric, direction, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY metric, direction) SELECT k.* FROM kr k JOIN avg_progress ap ON k.metric = ap.metric AND k.direction = ap.direction WHERE (k.progress / NULLIF(k.target, 0)) < ap.avg_progress;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.6875
      },
      "cosineSimilarity": 0.8709520389944955,
      "finalSql": "WITH KRProgress AS ( SELECT id, metric, direction, progress, target, CASE WHEN direction = 'up' THEN progress::NUMERIC / target WHEN direction = 'down' THEN (target - progress)::NUMERIC / target ELSE NULL END AS calculated_progress FROM kr ), AverageProgress AS ( SELECT metric, direction, AVG(calculated_progress) AS avg_progress FROM KRProgress GROUP BY metric, direction ) SELECT kp.id, kp.metric, kp.direction, kp.progress, kp.target, kp.calculated_progress FROM KRProgress AS kp JOIN AverageProgress AS ap ON kp.metric = ap.metric AND kp.direction = ap.direction WHERE kp.calculated_progress < ap.avg_progress;",
      "executionMatch": false,
      "tableSimilarity": 0.33765652951699465,
      "queryAffinityScore": 0.6043042842557451
    },
    {
      "question": "Identificar iniciativas que mantêm registros de atualização em meses consecutivos, sem interrupções.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT DISTINCT i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE EXISTS ( SELECT 1 FROM initiative_update iu2 WHERE iu2.initiative_id = i.id AND TO_CHAR(iu2.year_month, 'YYYY-MM') = TO_CHAR(iu.year_month + INTERVAL '1 month', 'YYYY-MM') ) ORDER BY i.title;",
          "error": "function to_char(character varying, unknown) does not exist"
        },
        {
          "attempt": 2,
          "sql": "SELECT DISTINCT i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE EXISTS ( SELECT 1 FROM initiative_update iu2 WHERE iu2.initiative_id = i.id AND iu2.year_month = (iu.year_month + INTERVAL '1 month') ) ORDER BY i.title;",
          "fixed": true,
          "error": "operator does not exist: character varying + interval"
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"SELECT DISTINCT i.title\\nFROM initiative i\\nJOIN initiative_update iu ON i.id = iu.initiative_id\\nWHERE EXISTS (\\n SELECT 1\\n FROM initiative_update iu2\\n WHERE iu2.initiative_id = i.id\\n AND iu2.year_month = (iu.year_month + INTERVAL '1 month')\\n)\\nORDER BY i.title;\", \"explanation\": \"O erro 'operator does not exist: character varying + interval' indica que a coluna 'year_month' é do tipo 'bytea' (conforme o schema) ou 'character varying' (conforme a mensagem de erro inferiu) e não pode ser usada diretamente com operações de data/intervalo como '+ INTERVAL '1 month''. Para resolver isso, é necessário converter 'year_month' para um tipo de dado de data/hora antes de adicionar o intervalo. Assumindo que 'year_month' armazena o ano e o mês em um formato que pode ser convertido para 'DATE' ou 'TIMESTAMP', a correção seria converter 'year_month' para um tipo de data. No entanto, o schema define 'year_month' como 'bytea', o que é um tipo de dado inadequado para representar ano/mês para operações de data. A solução mais robusta seria alterar o tipo da coluna 'year_month' no schema para 'DATE' ou 'TIMESTAMP'. Como não posso alterar o schema, e a pergunta original implica uma comparação de meses consecutivos, a query original já estava conceitualmente correta para o que se esperava de uma coluna de data. A query fornecida na resposta é a mesma da tentativa 2, pois o erro não é de sintaxe SQL, mas sim de tipo de dado da coluna 'year_month' que não permite a operação de adição de intervalo. Se 'year_month' fosse um tipo de data/timestamp, a query funcionaria. Sem a capacidade de alterar o schema ou saber o formato exato do 'bytea' para conversão, a query original é a mais próxima da intenção, mas falhará devido ao tipo de dado. Se 'year_month' fosse um VARCHAR no formato 'YYYY-MM', a correção seria `TO_DATE(iu.year_month, 'YYYY-MM') + INTERVAL",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "SELECT DISTINCT i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE EXISTS ( SELECT 1 FROM initiative_update iu2 WHERE iu2.initiative_id = i.id AND TO_CHAR(iu2.year_month, 'YYYY-MM') = TO_CHAR(iu.year_month + INTERVAL '1 month', 'YYYY-MM') ) ORDER BY i.title;",
      "executionTimeMs": 2703,
      "goldSql": "WITH updates_months AS (SELECT initiative_id, DATE_TRUNC('month', created_date) AS month FROM initiative_update GROUP BY initiative_id, month), consecutive AS (SELECT initiative_id, month, LAG(month) OVER (PARTITION BY initiative_id ORDER BY month) AS prev_month FROM updates_months), gaps AS (SELECT initiative_id, COUNT(*) FILTER (WHERE prev_month IS NOT NULL AND month - INTERVAL '1 month' <> prev_month) AS gap_count, COUNT(month) AS total_months FROM consecutive GROUP BY initiative_id) SELECT initiative_id FROM gaps WHERE gap_count = 0 AND total_months > 1;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.4375
      },
      "cosineSimilarity": 0.6515198320131137,
      "finalSql": "{ \"sql\": \"SELECT DISTINCT i.title\\nFROM initiative i\\nJOIN initiative_update iu ON i.id = iu.initiative_id\\nWHERE EXISTS (\\n SELECT 1\\n FROM initiative_update iu2\\n WHERE iu2.initiative_id = i.id\\n AND iu2.year_month = (iu.year_month + INTERVAL '1 month')\\n)\\nORDER BY i.title;\", \"explanation\": \"O erro 'operator does not exist: character varying + interval' indica que a coluna 'year_month' é do tipo 'bytea' (conforme o schema) ou 'character varying' (conforme a mensagem de erro inferiu) e não pode ser usada diretamente com operações de data/intervalo como '+ INTERVAL '1 month''. Para resolver isso, é necessário converter 'year_month' para um tipo de dado de data/hora antes de adicionar o intervalo. Assumindo que 'year_month' armazena o ano e o mês em um formato que pode ser convertido para 'DATE' ou 'TIMESTAMP', a correção seria converter 'year_month' para um tipo de data. No entanto, o schema define 'year_month' como 'bytea', o que é um tipo de dado inadequado para representar ano/mês para operações de data. A solução mais robusta seria alterar o tipo da coluna 'year_month' no schema para 'DATE' ou 'TIMESTAMP'. Como não posso alterar o schema, e a pergunta original implica uma comparação de meses consecutivos, a query original já estava conceitualmente correta para o que se esperava de uma coluna de data. A query fornecida na resposta é a mesma da tentativa 2, pois o erro não é de sintaxe SQL, mas sim de tipo de dado da coluna 'year_month' que não permite a operação de adição de intervalo. Se 'year_month' fosse um tipo de data/timestamp, a query funcionaria. Sem a capacidade de alterar o schema ou saber o formato exato do 'bytea' para conversão, a query original é a mais próxima da intenção, mas falhará devido ao tipo de dado. Se 'year_month' fosse um VARCHAR no formato 'YYYY-MM', a correção seria `TO_DATE(iu.year_month, 'YYYY-MM') + INTERVAL",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Calcular a taxa média de crescimento mensal do progresso dos KRs, segmentada por tipo de métrica.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT kr.metric, AVG(CASE WHEN kr.direction = 'up' THEN (krh.progress - LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date)) / LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date) WHEN kr.direction = 'down' THEN (LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date) - krh.progress) / LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.progress) ELSE 0 END) AS average_monthly_growth_rate FROM kr_history AS krh JOIN kr ON krh.kr_id = kr.id GROUP BY kr.metric;",
          "error": "aggregate function calls cannot contain window function calls"
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH MonthlyProgress AS (\\n SELECT\\n krh.kr_id,\\n krh.date,\\n krh.progress,\\n kr.metric,\\n kr.direction,\\n LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY krh.kr_id ORDER BY krh.date) AS previous_progress\\n FROM\\n kr_history AS krh\\n JOIN\\n kr ON krh.kr_id = kr.id\\n),\\nGrowthRates AS (\\n SELECT\\n kr_id,\\n metric,\\n direction,\\n CASE\\n WHEN previous_progress = 0 AND progress = 0 THEN 0.0\\n WHEN previous_progress = 0 AND progress != 0 THEN 1.0 -- Consider infinite growth as 100% for practical purposes\\n WHEN direction = 'up' THEN (progress - previous_progress) / previous_progress\\n WHEN direction = 'down' THEN (previous_progress - progress) / previous_progress\\n ELSE 0.0\\n END AS monthly_growth_rate\\n FROM\\n MonthlyProgress\\n WHERE\\n progress IS NOT NULL AND previous_progress IS NOT NULL\\n)\\nSELECT\\n metric,\\n AVG(monthly_growth_rate) AS average_monthly_growth_rate\\nFROM\\n GrowthRates\\nWHERE\\n monthly_growth_rate IS NOT NULL\\nGROUP BY\\n metric;\", \"explanation\": \"O erro 'aggregate function calls cannot contain window function calls' ocorre porque você não pode aninhar uma função de janela (LAG) diretamente dentro de uma função de agregação (AVG). Para corrigir isso, a query foi reestruturada usando Common Table Expressions (CTEs).\\n\\n1. `MonthlyProgress` CTE: Calcula o progresso anterior para cada KR usando `LAG` e junta com a tabela `kr` para obter a métrica e a direção.\\n2. `GrowthRates` CTE: Calcula a taxa de crescimento mensal com base na direção do KR. Foi adicionada uma lógica para lidar com `previous_progress` igual a zero para evitar divisão por zero",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "WITH MonthlyProgress AS ( SELECT krh.kr_id, krh.date, krh.progress, krh.target, kr.metric, kr.direction, LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY krh.kr_id ORDER BY krh.date) AS previous_progress FROM kr_history AS krh JOIN kr ON krh.kr_id = kr.id ), GrowthRates AS ( SELECT kr_id, metric, direction, CASE WHEN previous_progress = 0 AND progress = 0 THEN 0.0 WHEN previous_progress = 0 AND progress != 0 THEN 1.0 -- Consider infinite growth as 100% for practical purposes WHEN direction = 'up' THEN (progress - previous_progress) / previous_progress WHEN direction = 'down' THEN (previous_progress - progress) / previous_progress ELSE 0.0 END AS monthly_growth_rate FROM MonthlyProgress WHERE progress IS NOT NULL AND previous_progress IS NOT NULL ) SELECT metric, AVG(monthly_growth_rate) AS average_monthly_growth_rate FROM GrowthRates WHERE monthly_growth_rate IS NOT NULL GROUP BY metric;",
          "fixed": true,
          "error": "syntax error at end of input"
        }
      ],
      "predictedSql": "SELECT kr.metric, AVG(CASE WHEN kr.direction = 'up' THEN (krh.progress - LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date)) / LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date) WHEN kr.direction = 'down' THEN (LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date) - krh.progress) / LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.progress) ELSE 0 END) AS average_monthly_growth_rate FROM kr_history AS krh JOIN kr ON krh.kr_id = kr.id GROUP BY kr.metric;",
      "executionTimeMs": 3369,
      "goldSql": "WITH monthly_kr_progress AS (SELECT kr_id, metric, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr_history GROUP BY kr_id, metric, month), monthly_growth AS (SELECT kr_id, metric, month, avg_progress, LAG(avg_progress) OVER (PARTITION BY kr_id ORDER BY month) AS prev_avg_progress FROM monthly_kr_progress), growth_rate AS (SELECT metric, AVG(CASE WHEN prev_avg_progress IS NOT NULL THEN (avg_progress - prev_avg_progress) / NULLIF(prev_avg_progress,0) ELSE NULL END) AS avg_monthly_growth_rate FROM monthly_growth GROUP BY metric) SELECT metric, avg_monthly_growth_rate FROM growth_rate;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5625
      },
      "cosineSimilarity": 0.8331749809268815,
      "finalSql": "WITH MonthlyProgress AS ( SELECT krh.kr_id, krh.date, krh.progress, krh.target, kr.metric, kr.direction, LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY krh.kr_id ORDER BY krh.date) AS previous_progress FROM kr_history AS krh JOIN kr ON krh.kr_id = kr.id ), GrowthRates AS ( SELECT kr_id, metric, direction, CASE WHEN previous_progress = 0 AND progress = 0 THEN 0.0 WHEN previous_progress = 0 AND progress != 0 THEN 1.0 -- Consider infinite growth as 100% for practical purposes WHEN direction = 'up' THEN (progress - previous_progress) / previous_progress WHEN direction = 'down' THEN (previous_progress - progress) / previous_progress ELSE 0.0 END AS monthly_growth_rate FROM MonthlyProgress WHERE progress IS NOT NULL AND previous_progress IS NOT NULL ) SELECT metric, AVG(monthly_growth_rate) AS average_monthly_growth_rate FROM GrowthRates WHERE monthly_growth_rate IS NOT NULL GROUP BY metric;",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at end of input",
      "executionMatch": false
    },
    {
      "question": "Detectar iniciativas que apresentaram regressão média no progresso de seus KRs durante o último ciclo de atualização.",
      "status": "ERROR",
      "retries": [
        {
          "attempt": 1,
          "sql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kr_id,\\n MAX(date) AS latest_date\\n FROM kr_history\\n GROUP BY\\n kr_id\\n),\\nprevious_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS previous_date\\n FROM kr_history AS kh\\n JOIN latest_kr_updates AS lku\\n ON kh.kr_id = lku.kr_id\\n WHERE\\n kh.date < lku.latest_date\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_comparison AS (\\n SELECT\\n kh_latest.kr_id,\\n k.okr_id,\\n k.direction,\\n kh_latest.progress AS latest_progress,\\n kh_latest.target AS latest_target,\\n kh_previous.progress AS previous_progress,\\n kh_previous.target AS previous_target\\n FROM kr_history AS kh_latest\\n JOIN latest_kr_updates AS lku\\n ON kh_latest.kr_id = lku.kr_id\\n AND kh_latest.date = lku.latest_date\\n JOIN previous_kr_updates AS pku\\n ON kh_latest.kr_id = pku.kr_id\\n JOIN kr_history AS kh_previous\\n ON pku.kr_id = kh_previous.kr_id\\n AND pku.previous_date = kh_previous.date\\n JOIN kr AS k\\n ON kh_latest.kr_id = k.id\\n),\\nkr_regression AS (\\n SELECT\\n okr_id,\\n CASE\\n WHEN direction = 'up' AND (latest_progress / latest_target) < (previous_progress / previous_target) THEN 1\\n WHEN direction = 'down' AND (latest_progress / latest_target) > (previous_progress / previous_target) THEN 1\\n ELSE 0\\n END AS has_reg",
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 2,
          "sql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kr_id,\\n MAX(date) AS latest_date\\n FROM kr_history\\n GROUP BY\\n kr_id\\n),\\nprevious_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS previous_date\\n FROM kr_history AS kh\\n JOIN latest_kr_updates AS lku\\n ON kh.kr_id = lku.kr_id\\n WHERE\\n kh.date < lku.latest_date\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_comparison AS (\\n SELECT\\n kh_latest.kr_id,\\n k.okr_id,\\n k.direction,\\n kh_latest.progress AS latest_progress,\\n kh_latest.target AS latest_target,\\n kh_previous.progress AS previous_progress,\\n kh_previous.target AS previous_target\\n FROM kr_history AS kh_latest\\n JOIN latest_kr_updates AS lku\\n ON kh_latest.kr_id = lku.kr_id\\n AND kh_latest.date = lku.latest_date\\n JOIN previous_kr_updates AS pku\\n ON kh_latest.kr_id = pku.kr_id\\n JOIN kr_history AS kh_previous\\n ON pku.kr_id = kh_previous.kr_id\\n AND pku.previous_date = kh_previous.date\\n JOIN kr AS k\\n ON kh_latest.kr_id = k.id\\n),\\nkr_regression AS (\\n SELECT\\n okr_id,\\n CASE\\n WHEN direction = 'up' AND (latest_progress / latest_target) < (previous_progress / previous_target) THEN 1\\n WHEN direction = 'down' AND (latest_progress / latest_target) > (previous_progress / previous_target) THEN 1\\n ELSE 0\\n END AS has_regression",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        },
        {
          "attempt": 3,
          "sql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kr_id,\\n MAX(date) AS latest_date\\n FROM kr_history\\n GROUP BY\\n kr_id\\n),\\nprevious_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS previous_date\\n FROM kr_history AS kh\\n JOIN latest_kr_updates AS lku\\n ON kh.kr_id = lku.kr_id\\n WHERE\\n kh.date < lku.latest_date\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_comparison AS (\\n SELECT\\n kh_latest.kr_id,\\n k.okr_id,\\n k.direction,\\n kh_latest.progress AS latest_progress,\\n kh_latest.target AS latest_target,\\n kh_previous.progress AS previous_progress,\\n kh_previous.target AS previous_target\\n FROM kr_history AS kh_latest\\n JOIN latest_kr_updates AS lku\\n ON kh_latest.kr_id = lku.kr_id\\n AND kh_latest.date = lku.latest_date\\n JOIN previous_kr_updates AS pku\\n ON kh_latest.kr_id = pku.kr_id\\n JOIN kr_history AS kh_previous\\n ON pku.kr_id = kh_previous.kr_id\\n AND pku.previous_date = kh_previous.date\\n JOIN kr AS k\\n ON kh_latest.kr_id = k.id\\n),\\nkr_regression AS (\\n SELECT\\n okr_id,\\n CASE\\n WHEN direction = 'up' AND (latest_progress / latest_target) < (previous_progress / previous_target) THEN 1\\n WHEN direction = 'down' AND (latest_progress / latest_target) > (previous_progress / previous_target) THEN 1\\n ELSE 0\\n END AS has_regression",
          "fixed": true,
          "error": "syntax error at or near \"{\""
        }
      ],
      "predictedSql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kr_id,\\n MAX(date) AS latest_date\\n FROM kr_history\\n GROUP BY\\n kr_id\\n),\\nprevious_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS previous_date\\n FROM kr_history AS kh\\n JOIN latest_kr_updates AS lku\\n ON kh.kr_id = lku.kr_id\\n WHERE\\n kh.date < lku.latest_date\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_comparison AS (\\n SELECT\\n kh_latest.kr_id,\\n k.okr_id,\\n k.direction,\\n kh_latest.progress AS latest_progress,\\n kh_latest.target AS latest_target,\\n kh_previous.progress AS previous_progress,\\n kh_previous.target AS previous_target\\n FROM kr_history AS kh_latest\\n JOIN latest_kr_updates AS lku\\n ON kh_latest.kr_id = lku.kr_id\\n AND kh_latest.date = lku.latest_date\\n JOIN previous_kr_updates AS pku\\n ON kh_latest.kr_id = pku.kr_id\\n JOIN kr_history AS kh_previous\\n ON pku.kr_id = kh_previous.kr_id\\n AND pku.previous_date = kh_previous.date\\n JOIN kr AS k\\n ON kh_latest.kr_id = k.id\\n),\\nkr_regression AS (\\n SELECT\\n okr_id,\\n CASE\\n WHEN direction = 'up' AND (latest_progress / latest_target) < (previous_progress / previous_target) THEN 1\\n WHEN direction = 'down' AND (latest_progress / latest_target) > (previous_progress / previous_target) THEN 1\\n ELSE 0\\n END AS has_reg",
      "executionTimeMs": 4131,
      "goldSql": "WITH last_two_updates AS (SELECT kh.kr_id, i.id AS initiative_id, kh.date, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn, kh.progress / NULLIF(k.target, 0) AS relative_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id), progress_diff AS (SELECT a.initiative_id, AVG(a.relative_progress - b.relative_progress) AS avg_progress_change FROM last_two_updates a JOIN last_two_updates b ON a.kr_id = b.kr_id AND a.rn = 1 AND b.rn = 2 GROUP BY a.initiative_id) SELECT initiative_id FROM progress_diff WHERE avg_progress_change < 0;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.5
      },
      "cosineSimilarity": 0.6667329750790238,
      "finalSql": "{ \"sql\": \"WITH latest_kr_updates AS (\\n SELECT\\n kr_id,\\n MAX(date) AS latest_date\\n FROM kr_history\\n GROUP BY\\n kr_id\\n),\\nprevious_kr_updates AS (\\n SELECT\\n kh.kr_id,\\n MAX(kh.date) AS previous_date\\n FROM kr_history AS kh\\n JOIN latest_kr_updates AS lku\\n ON kh.kr_id = lku.kr_id\\n WHERE\\n kh.date < lku.latest_date\\n GROUP BY\\n kh.kr_id\\n),\\nkr_progress_comparison AS (\\n SELECT\\n kh_latest.kr_id,\\n k.okr_id,\\n k.direction,\\n kh_latest.progress AS latest_progress,\\n kh_latest.target AS latest_target,\\n kh_previous.progress AS previous_progress,\\n kh_previous.target AS previous_target\\n FROM kr_history AS kh_latest\\n JOIN latest_kr_updates AS lku\\n ON kh_latest.kr_id = lku.kr_id\\n AND kh_latest.date = lku.latest_date\\n JOIN previous_kr_updates AS pku\\n ON kh_latest.kr_id = pku.kr_id\\n JOIN kr_history AS kh_previous\\n ON pku.kr_id = kh_previous.kr_id\\n AND pku.previous_date = kh_previous.date\\n JOIN kr AS k\\n ON kh_latest.kr_id = k.id\\n),\\nkr_regression AS (\\n SELECT\\n okr_id,\\n CASE\\n WHEN direction = 'up' AND (latest_progress / latest_target) < (previous_progress / previous_target) THEN 1\\n WHEN direction = 'down' AND (latest_progress / latest_target) > (previous_progress / previous_target) THEN 1\\n ELSE 0\\n END AS has_regression",
      "error": "Erro de execução no banco após 3 tentativa(s): syntax error at or near \"{\"",
      "executionMatch": false
    },
    {
      "question": "Apontar iniciativas cujos OKRs estão vencidos, mas cujo progresso médio permanece abaixo de 80%.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE o.deadline < NOW() GROUP BY i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.8;",
          "error": "division by zero"
        },
        {
          "attempt": 2,
          "sql": "SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE o.deadline < NOW() AND k.target <> 0 GROUP BY i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.8;",
          "fixed": true,
          "error": "division by zero"
        },
        {
          "attempt": 3,
          "sql": "SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE o.deadline < NOW() AND k.target <> 0 AND k.progress <> 0 GROUP BY i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.8;",
          "fixed": true
        }
      ],
      "predictedSql": "SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE o.deadline < NOW() GROUP BY i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.8;",
      "executionTimeMs": 3030,
      "goldSql": "SELECT i.id AS initiative_id FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id WHERE o.deadline < NOW() GROUP BY i.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8;",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 1,
          "SELECT": 0,
          "DISTINCT": 1,
          "FROM": 0,
          "JOIN": 1,
          "WHERE": 1,
          "GROUP_BY": 0,
          "HAVING": 1,
          "ORDER_BY": 1,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 1,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.8125
      },
      "cosineSimilarity": 0.8430033662499167,
      "finalSql": "SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE o.deadline < NOW() AND k.target <> 0 AND k.progress <> 0 GROUP BY i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.8;",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.42150168312495834
    },
    {
      "question": "Identificar KRs com direção “NEGATIVA” que mantêm melhora contínua e atingem o target definido.",
      "status": "SUCCESS",
      "retries": [
        {
          "attempt": 1,
          "sql": "SELECT T1.title, T1.metric, T1.progress, T1.target, T1.direction FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE T1.direction = 'down' AND T1.progress <= T1.target GROUP BY T1.id, T1.title, T1.metric, T1.progress, T1.target, T1.direction HAVING COUNT(CASE WHEN T2.progress <= T2.target THEN 1 ELSE NULL END) = COUNT(T2.id);"
        }
      ],
      "predictedSql": "SELECT T1.title, T1.metric, T1.progress, T1.target, T1.direction FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE T1.direction = 'down' AND T1.progress <= T1.target GROUP BY T1.id, T1.title, T1.metric, T1.progress, T1.target, T1.direction HAVING COUNT(CASE WHEN T2.progress <= T2.target THEN 1 ELSE NULL END) = COUNT(T2.id);",
      "executionTimeMs": 2825,
      "goldSql": "WITH kr_direction AS (SELECT k.id AS kr_id, k.target, k.direction FROM kr k WHERE k.direction = 'down'), history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kd.target, 0)) AS relative_progress, LAG(kh.progress / NULLIF(kd.target, 0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_progress FROM kr_history kh JOIN kr_direction kd ON kd.kr_id = kh.kr_id), fully_improving AS (SELECT kr_id FROM history GROUP BY kr_id HAVING COUNT(*) FILTER (WHERE prev_progress IS NOT NULL AND relative_progress >= prev_progress) = COUNT(*) - 1), achieved AS (SELECT kr_id FROM (SELECT kh.kr_id, (kh.progress / NULLIF(k.target,0)) AS relative_progress, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn FROM kr_history kh JOIN kr k ON k.id = kh.kr_id WHERE k.direction = 'down') last_value WHERE rn = 1 AND relative_progress <= 1) SELECT DISTINCT kr_id FROM fully_improving JOIN achieved USING(kr_id);",
      "exactMatch": false,
      "componentMatch": {
        "componentMatches": {
          "WITH": 0,
          "SELECT": 0,
          "DISTINCT": 0,
          "FROM": 0,
          "JOIN": 0,
          "WHERE": 0,
          "GROUP_BY": 0,
          "HAVING": 0,
          "ORDER_BY": 0,
          "LIMIT": 1,
          "OFFSET": 1,
          "WINDOW": 0,
          "UNION": 1,
          "INTERSECT": 1,
          "EXCEPT": 1,
          "RETURNING": 1
        },
        "CM": 0.375
      },
      "cosineSimilarity": 0.8040278170395129,
      "finalSql": "SELECT T1.title, T1.metric, T1.progress, T1.target, T1.direction FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE T1.direction = 'down' AND T1.progress <= T1.target GROUP BY T1.id, T1.title, T1.metric, T1.progress, T1.target, T1.direction HAVING COUNT(CASE WHEN T2.progress <= T2.target THEN 1 ELSE NULL END) = COUNT(T2.id);",
      "executionMatch": false,
      "tableSimilarity": 0,
      "queryAffinityScore": 0.40201390851975644
    }
  ]
}