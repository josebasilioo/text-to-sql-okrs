================================================================================
üìä RELAT√ìRIO DE AVALIA√á√ÉO
================================================================================
Timestamp: 2025-11-28T00:59:34.319Z
Total de perguntas: 76
‚úÖ Sucessos: 70
‚ùå Erros: 6

--- Retries ---
Total de perguntas com retries: 26
Total de tentativas de corre√ß√£o: 35
M√©dia de retries por pergunta (com retries): 1.35
M√°ximo de retries em uma pergunta: 2
‚úÖ Sucessos ap√≥s retry: 20
‚ùå Falhas ap√≥s retry: 6

--- M√©tricas ---

Exact Match (EM):
  Total avaliado: 70
  Matches: 1
  Acur√°cia: 1.43%

Component Match (CM):
  Total avaliado: 70
  CM m√©dio: 0.7429

Execution Match (EX):
  Total avaliado: 70
  Matches: 6
  Acur√°cia: 8.57%

Cosine Similarity (CS - Semantic Similarity):
  Total avaliado: 70
  CS m√©dio: 0.8431

Table Similarity (TS):
  Total avaliado: 70
  TS m√©dio: 0.3072

Query Affinity Score (QAS):
  Total avaliado: 70
  QAS m√©dio: 0.5751

================================================================================

üìã Detalhes por pergunta:

1. Existe correla√ß√£o entre a prioridade da iniciativa e o progresso m√©dio de seus OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 6320ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.9028
   Table Similarity: 0.5000
   Query Affinity Score: 0.7014
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Corrigida (final):
   SELECT i.priority, AVG( CASE WHEN k.direction = 'up' THEN CASE WHEN k.target = 0 THEN NULL ELSE k.progress::numeric / k.target END WHEN k.direction = 'down' THEN CASE WHEN k.progress = 0 THEN NULL ELSE k.target::numeric / k.progress END ELSE NULL END ) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Esperada (Gold):
   SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;

2. Iniciativas com maior prioridade tendem a ter maior progresso m√©dio nos OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3115ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.9028
   Table Similarity: 0.5000
   Query Affinity Score: 0.7014
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Corrigida (final):
   SELECT i.priority, AVG( CASE WHEN k.direction = 'up' THEN CASE WHEN k.target = 0 THEN NULL ELSE k.progress::numeric / k.target END WHEN k.direction = 'down' THEN CASE WHEN k.progress = 0 THEN NULL ELSE k.target::numeric / k.progress END ELSE NULL END ) AS average_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Esperada (Gold):
   SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;

3. Qual √© a rela√ß√£o entre prioridade da iniciativa e o desempenho m√©dio dos seus OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3201ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.8985
   Table Similarity: 0.5000
   Query Affinity Score: 0.6993
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_okr_performance FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Corrigida (final):
   SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) AS average_okr_performance FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Esperada (Gold):
   SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;

4. Iniciativas de qual categoria t√™m maior taxa de conclus√£o de KRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2802ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8619
   Table Similarity: 0.1250
   Query Affinity Score: 0.4934

   SQL Gerada:
   SELECT i.category, AVG(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1.0 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1.0 ELSE 0.0 END) AS completion_rate FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC LIMIT 1;

   SQL Esperada (Gold):
   SELECT i.category, CAST(SUM(CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) AS FLOAT) / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;

5. Qual categoria de iniciativa apresenta menor frequ√™ncia de updates?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2543ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8226
   Table Similarity: 0.1250
   Query Affinity Score: 0.4738

   SQL Gerada:
   SELECT i.category FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY COUNT(iu.id) ASC LIMIT 1;

   SQL Esperada (Gold):
   SELECT i.category, CAST(COUNT(iu.id) AS FLOAT) / COUNT(DISTINCT i.id) AS avg_updates_per_initiative FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY avg_updates_per_initiative ASC;

6. Colaboradores com mais KRs favoritos t√™m desempenho melhor nos OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3124ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8963
   Table Similarity: 0.3467
   Query Affinity Score: 0.6215
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT c.name AS collaborator_name, COUNT(DISTINCT k.id) AS favorited_krs_count, AVG(CASE WHEN k.direction = 'up' THEN k.progress * 1.0 / k.target WHEN k.direction = 'down' THEN k.target * 1.0 / k.progress ELSE NULL END) AS avg_kr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY favorited_krs_count DESC;

   SQL Corrigida (final):
   SELECT c.name AS collaborator_name, COUNT(DISTINCT k.id) AS favorited_krs_count, AVG( CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress * 1.0 / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target * 1.0 / k.progress ELSE NULL END ) AS avg_kr_performance FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.name ORDER BY favorited_krs_count DESC;

   SQL Esperada (Gold):
   SELECT c.name, COUNT(k.id) AS total_bookmarked_krs, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress_of_bookmarked_krs FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ORDER BY total_bookmarked_krs DESC;

7. H√° diferen√ßa de progresso m√©dio entre KRs do tipo ‚ÄúYES_NO‚Äù e ‚ÄúNUMERIC‚Äù?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2938ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.8261
   Table Similarity: 0.5000
   Query Affinity Score: 0.6630
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT CASE WHEN T1.metric = 'YES_NO' THEN 'YES_NO' WHEN T1.metric = 'NUMERIC' THEN 'NUMERIC' ELSE 'Other' END AS metric_type, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target ELSE T1.target :: NUMERIC / T1.progress END) AS average_progress FROM kr AS T1 WHERE T1.metric IN ('YES_NO', 'NUMERIC') GROUP BY metric_type;

   SQL Corrigida (final):
   SELECT CASE WHEN T1.metric = 'YES_NO' THEN 'YES_NO' WHEN T1.metric = 'NUMERIC' THEN 'NUMERIC' ELSE 'Other' END AS metric_type, AVG( CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / NULLIF(T1.target, 0) ELSE T1.target :: NUMERIC / NULLIF(T1.progress, 0) END ) AS average_progress FROM kr AS T1 WHERE T1.metric IN ('YES_NO', 'NUMERIC') GROUP BY metric_type;

   SQL Esperada (Gold):
   SELECT k.metric, AVG(k.progress / NULLIF(k.target, 0)) AS average_progress FROM kr k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;

8. Quais iniciativas concentram mais KRs com m√©trica percentual?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2817ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.9687
   Table Similarity: 0.3372
   Query Affinity Score: 0.6529

   SQL Gerada:
   SELECT i.title AS initiative_title, COUNT(k.id) AS percentage_kr_count FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY percentage_kr_count DESC;

   SQL Esperada (Gold):
   SELECT i.title, COUNT(k.id) AS total_percentage_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.id, i.title ORDER BY total_percentage_krs DESC;

9. Qual a m√©dia de progresso dos OKRs de iniciativas de alta prioridade?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3054ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8994
   Table Similarity: 0.0000
   Query Affinity Score: 0.4497
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå invalid input syntax for type integer: "HIGH"
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT AVG(T2.progress * 100.0 / T2.target) FROM initiative AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id WHERE T1.priority = 'HIGH'

   SQL Corrigida (final):
   SELECT AVG(T2.progress * 100.0 / T2.target) FROM initiative AS T1 JOIN okr AS T3 ON T1.id = T3.initiative_id JOIN kr AS T2 ON T3.id = T2.okr_id WHERE T1.priority = 1

   SQL Esperada (Gold):
   SELECT AVG(k.progress / NULLIF(k.target, 0)) AS average_okr_progress_high_priority FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1;

10. Qual o impacto dos updates de iniciativa no progresso dos KRs associados?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3954ms
   Exact Match: ‚úó
   Component Match: 0.5000
   Execution Match: ‚úó
   Cosine Similarity: 0.8168
   Table Similarity: 0.0000
   Query Affinity Score: 0.4084
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT iu.id AS initiative_update_id, iu.year_month, iu.highlights, iu.brutal_facts, iu.next_steps, k.title AS kr_title, k.metric AS kr_metric, k.direction AS kr_direction, k.target AS kr_target, kh.progress AS kr_progress_at_update_time, CASE WHEN k.direction = 'up' THEN (kh.progress * 1.0 / k.target) WHEN k.direction = 'down' THEN (k.target * 1.0 / kh.progress) ELSE NULL END AS kr_progress_percentage FROM initiative_update AS iu JOIN initiative AS i ON iu.initiative_id = i.id JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE iu.created_date <= kh.date AND iu.created_date >= (kh.date - INTERVAL '1 month') ORDER BY iu.created_date DESC, k.title;

   SQL Corrigida (final):
   SELECT iu.id AS initiative_update_id, iu.year_month, iu.highlights, iu.brutal_facts, iu.next_steps, k.title AS kr_title, k.metric AS kr_metric, k.direction AS kr_direction, k.target AS kr_target, kh.progress AS kr_progress_at_update_time, CASE WHEN k.direction = 'up' AND k.target <> 0 THEN (kh.progress * 1.0 / k.target) WHEN k.direction = 'down' AND kh.progress <> 0 THEN (k.target * 1.0 / kh.progress) ELSE NULL END AS kr_progress_percentage FROM initiative_update AS iu JOIN initiative AS i ON iu.initiative_id = i.id JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE iu.created_date <= kh.date AND iu.created_date >= (kh.date - INTERVAL '1 month') ORDER BY iu.created_date DESC, k.title;

   SQL Esperada (Gold):
   WITH normalized_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(k.target,0)) AS rel_progress, LAG(kh.progress / NULLIF(k.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS rel_before FROM kr_history kh JOIN kr k ON k.id = kh.kr_id), updates AS (SELECT initiative_id, created_date FROM initiative_update), link AS (SELECT nh.kr_id, nh.rel_progress, nh.rel_before, nh.date AS progress_date, (SELECT iu.created_date FROM initiative_update iu JOIN kr k ON iu.initiative_id = k.okr_id JOIN okr o ON k.okr_id = o.id WHERE iu.initiative_id = o.initiative_id AND iu.created_date < nh.date ORDER BY iu.created_date DESC LIMIT 1) AS last_update FROM normalized_history nh JOIN kr k ON nh.kr_id = k.id JOIN okr o ON k.okr_id = o.id) SELECT AVG(rel_progress - rel_before) AS avg_progress_change_after_update FROM link WHERE rel_before IS NOT NULL AND last_update IS NOT NULL;

11. H√° aumento no ritmo de updates pr√≥ximo aos deadlines dos OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2977ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8992
   Table Similarity: 0.6231
   Query Affinity Score: 0.7612

   SQL Gerada:
   SELECT o.id AS okr_id, o.deadline AS okr_deadline, COUNT(iu.id) AS total_updates, SUM(CASE WHEN iu.created_date >= (o.deadline - INTERVAL '7 days') THEN 1 ELSE 0 END) AS updates_near_deadline FROM okr AS o LEFT JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline HAVING COUNT(iu.id) > 0;

   SQL Esperada (Gold):
   SELECT o.id AS okr_id, o.deadline, SUM(CASE WHEN iu.created_date BETWEEN o.deadline - INTERVAL '30 days' AND o.deadline THEN 1 ELSE 0 END) AS updates_last_30_days, SUM(CASE WHEN iu.created_date < o.deadline - INTERVAL '30 days' THEN 1 ELSE 0 END) AS updates_before_30_days FROM okr o LEFT JOIN initiative_update iu ON iu.initiative_id = o.initiative_id AND iu.created_date <= o.deadline GROUP BY o.id, o.deadline ORDER BY o.deadline;

12. Qual √© o alinhamento entre as datas de fim de iniciativa e deadlines de OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2566ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.6687
   Table Similarity: 0.0000
   Query Affinity Score: 0.3343

   SQL Gerada:
   SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id;

   SQL Esperada (Gold):
   SELECT CASE WHEN o.deadline < i.end_date THEN 'OKR ANTES da Iniciativa' WHEN o.deadline = i.end_date THEN 'OKR e Iniciativa na MESMA DATA' WHEN o.deadline > i.end_date THEN 'OKR DEPOIS da Iniciativa' ELSE 'Sem data de fim para Iniciativa' END AS alinhamento, COUNT(o.id) AS total_okrs FROM okr o JOIN initiative i ON o.initiative_id = i.id GROUP BY alinhamento;

13. Quantos OKRs est√£o diretamente vinculados a iniciativas priorit√°rias (por categoria) e quantos ainda n√£o possuem liga√ß√£o clara com uma iniciativa?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3174ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.8093
   Table Similarity: 0.0556
   Query Affinity Score: 0.4324

   SQL Gerada:
   SELECT CASE WHEN i.category IS NOT NULL THEN i.category ELSE 'Sem Iniciativa Vinculada' END AS categoria_iniciativa, COUNT(DISTINCT o.id) AS total_okrs FROM okr AS o LEFT JOIN kr AS k ON o.id = k.okr_id LEFT JOIN initiative AS i ON o.initiative_id = i.id GROUP BY categoria_iniciativa ORDER BY total_okrs DESC;

   SQL Esperada (Gold):
   SELECT COALESCE(i.category, 'SEM INICIATIVA') AS category, COALESCE(i.priority, -1) AS priority, COUNT(o.id) AS okrs_count FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id GROUP BY category, priority ORDER BY category, priority;

14. Quantas atualiza√ß√µes de iniciativas foram registradas neste trimestre e quais s√£o os principais temas dos ‚Äúhighlights‚Äù e ‚Äúbrutal facts‚Äù?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3349ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8977
   Table Similarity: 0.0000
   Query Affinity Score: 0.4488

   SQL Gerada:
   SELECT COUNT(iu.id) AS total_updates, SUBSTRING(iu.highlights FROM 1 FOR 50) AS highlight_snippet, SUBSTRING(iu.brutal_facts FROM 1 FOR 50) AS brutal_facts_snippet FROM initiative_update AS iu WHERE iu.created_date >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 month') AND iu.created_date < DATE_TRUNC('quarter', CURRENT_DATE) GROUP BY highlight_snippet, brutal_facts_snippet ORDER BY total_updates DESC;

   SQL Esperada (Gold):
   SELECT COUNT(iu.id) AS total_updates_trimestre, STRING_AGG(iu.highlights, ' | ') AS todos_highlights, STRING_AGG(iu.brutal_facts, ' | ') AS todos_brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', CURRENT_DATE) AND iu.created_date < date_trunc('quarter', CURRENT_DATE) + interval '3 month';

15. Apresentar os KRs com maior desvio padr√£o de progresso ao longo do hist√≥rico, indicando instabilidade.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3028ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.8038
   Table Similarity: 0.1908
   Query Affinity Score: 0.4973

   SQL Gerada:
   SELECT T1.title, STDDEV(CAST(T2.progress AS NUMERIC) / T2.target) AS progress_stddev FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id GROUP BY T1.title ORDER BY progress_stddev DESC;

   SQL Esperada (Gold):
   SELECT k.title, o.description AS okr_description, STDDEV(kh.progress / NULLIF(kh.target, 0)) AS desvio_padrao_progresso FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id GROUP BY kh.kr_id, k.title, o.description HAVING COUNT(kh.id) > 1 ORDER BY desvio_padrao_progresso DESC;

16. Comparar o progresso m√©dio dos KRs com o progresso m√©dio das iniciativas √†s quais est√£o vinculados, destacando as maiores varia√ß√µes.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 4262ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.6145
   Table Similarity: 0.2567
   Query Affinity Score: 0.4356
   Tentativas de corre√ß√£o: 3
     Tentativa 1: ‚ùå syntax error at or near "{"
     Tentativa 2: ‚ùå syntax error at or near "{"
     Tentativa 3: ‚úÖ Corrigido

   SQL Gerada (original):
   { "sql": "WITH kr_progress_calc AS (\n SELECT\n kr.okr_id,\n kr.id AS kr_id,\n CASE\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\n ELSE NULL\n END AS kr_progress\n FROM kr\n),\ninitiative_progress_calc AS (\n SELECT\n i.id AS initiative_id,\n AVG(CASE\n WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target\n WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target\n ELSE NULL\n END) AS initiative_avg_progress\n FROM initiative AS i\n JOIN okr AS o\n ON i.okr_id = o.id\n JOIN kr\n ON o.id = kr.okr_id\n GROUP BY\n i.id\n)\nSELECT\n krc.kr_id,\n krc.kr_progress,\n ipc.initiative_avg_progress,\n ABS(krc.kr_progress - ipc.initiative_avg_progress) AS progress_difference\nFROM kr_progress_calc AS krc\nJOIN kr\n ON krc.kr_id = kr.id\nJOIN okr\n ON kr.okr_id = okr.id\nJOIN initiative_progress_calc AS ipc\n ON okr.initiative_id = ipc.initiative_id\nORDER BY\n progress_difference DESC;", "complementaryText": "Esta query calcula o progresso individual de cada KR, considerando a dire√ß√£o ('up' ou 'down'), e o progresso m√©dio de cada iniciativa. Em seguida, compara o progresso de cada KR com o progresso m√©dio da iniciativa √† qual ele pertence, destacando as maiores varia√ß√µes. As colunas retornadas s√£o o ID do KR, o progresso do KR, o progresso m√©dio da

   SQL Corrigida (final):
   WITH kr_progress_calc AS ( SELECT k.okr_id, k.id AS kr_id, CASE WHEN k.direction = 'up' THEN k.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::NUMERIC / k.target ELSE NULL END AS kr_progress FROM kr AS k ), initiative_progress_calc AS ( SELECT i.id AS initiative_id, AVG(CASE WHEN k.direction = 'up' THEN k.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::NUMERIC / k.target ELSE NULL END) AS initiative_avg_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id ) SELECT krc.kr_id, krc.kr_progress, ipc.initiative_avg_progress, ABS(krc.kr_progress - ipc.initiative_avg_progress) AS progress_difference FROM kr_progress_calc AS krc JOIN kr AS k ON krc.kr_id = k.id JOIN okr AS o ON k.okr_id = o.id JOIN initiative_progress_calc AS ipc ON o.initiative_id = ipc.initiative_id ORDER BY progress_difference DESC;

   SQL Esperada (Gold):
   WITH InitiativeProgress AS (SELECT i.id AS initiative_id, AVG(k.progress / NULLIF(k.target, 0)) AS avg_initiative_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id), CalculatedVariance AS (SELECT k.title AS kr_title, (k.progress / NULLIF(k.target, 0)) AS kr_current_progress, ip.avg_initiative_progress, (k.progress / NULLIF(k.target, 0)) - ip.avg_initiative_progress AS progress_variance FROM kr k JOIN okr o ON k.okr_id = o.id JOIN InitiativeProgress ip ON o.initiative_id = ip.initiative_id) SELECT kr_title, kr_current_progress, avg_initiative_progress, progress_variance FROM CalculatedVariance ORDER BY ABS(progress_variance) DESC;

17. Construir o ranking das categorias de iniciativa com base no progresso m√©dio ponderado pelo n√∫mero de KRs associados.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3217ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8807
   Table Similarity: 0.3333
   Query Affinity Score: 0.6070
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT i.category, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END * (SELECT COUNT(*) FROM kr WHERE okr_id = o.id)) / SUM((SELECT COUNT(*) FROM kr WHERE okr_id = o.id)) AS weighted_average_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;

   SQL Corrigida (final):
   SELECT i.category, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric WHEN k.direction = 'down' THEN (k.target - k.progress)::numeric ELSE 0 END) / COUNT(k.id) AS average_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.category HAVING COUNT(k.id) > 0 ORDER BY average_progress DESC;

   SQL Esperada (Gold):
   SELECT i.category, AVG(k.progress / NULLIF(k.target, 0)) AS weighted_average_progress, COUNT(k.id) AS total_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;

18. Avaliar a correla√ß√£o entre o n√∫mero de updates registrados em cada iniciativa e o progresso m√©dio de seus KRs.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3349ms
   Exact Match: ‚úó
   Component Match: 0.6250
   Execution Match: ‚úó
   Cosine Similarity: 0.7788
   Table Similarity: 0.0000
   Query Affinity Score: 0.3894

   SQL Gerada:
   SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress::NUMERIC / kr.target WHEN kr.direction = 'down' THEN (kr.target - kr.progress)::NUMERIC / kr.target ELSE NULL END) AS avg_kr_progress FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id LEFT JOIN okr AS o ON i.id = o.initiative_id LEFT JOIN kr ON o.id = kr.okr_id GROUP BY i.id, i.title ORDER BY num_updates DESC;

   SQL Esperada (Gold):
   WITH InitiativeMetrics AS (SELECT i.id AS initiative_id, COUNT(iu.id) AS total_updates, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id) SELECT CORR(im.total_updates, im.average_kr_progress) AS correlation_updates_vs_progress FROM InitiativeMetrics im;

19. Detectar iniciativas que apresentaram regress√£o m√©dia no progresso de KRs durante o √∫ltimo ciclo.
   Status: ‚ùå ERROR
   Erro: Erro de execu√ß√£o no banco ap√≥s 3 tentativa(s): syntax error at or near "{"

   SQL Gerada (com erro):
   { "sql": "WITH MonthlyProgress AS (\n SELECT\n kr.okr_id,\n kr.id AS kr_id,\n kr.direction,\n kr.target,\n EXTRACT(YEAR FROM kr_history.date) AS year,\n EXTRACT(MONTH FROM kr_history.date) AS month,\n MAX(kr_history.progress) AS latest_progress\n FROM kr\n JOIN kr_history ON kr.id = kr_history.kr_id\n GROUP BY\n kr.okr_id,\n kr.id,\n kr.direction,\n kr.target,\n EXTRACT(YEAR FROM kr_history.date),\n EXTRACT(MONTH FROM kr_history.date)\n),\nCalculatedProgress AS (\n SELECT\n okr_id,\n kr_id,\n year,\n month,\n CASE\n WHEN direction = 'up' THEN latest_progress::NUMERIC / target\n WHEN direction = 'down' THEN target::NUMERIC / latest_progress\n ELSE NULL\n END AS calculated_progress\n FROM MonthlyProgress\n),\nLaggedProgress AS (\n SELECT\n okr_id,\n kr_id,\n year,\n month,\n calculated_progress,\n LAG(calculated_progress, 1, calculated_progress) OVER (PARTITION BY kr_id ORDER BY year, month) AS previous_month_progress\n FROM CalculatedProgress\n),\nInitiativeKRProgress AS (\n SELECT\n o.initiative_id,\n l.kr_id,\n l.year,\n l.month,\n l.calculated_progress,\n l.previous_month_progress,\n (l.calculated_progress - l.previous_month_progress) AS progress_change\n FROM LaggedProgress AS l\n JOIN okr AS o ON l.okr_id = o.id\n),\nAverageInitiativeProgressChange AS (\n SELECT\n initiative_id,\n year,\n month,\n AVG(progress_change) AS average_

   SQL Esperada (Gold):
   WITH hist AS (SELECT kh.kr_id, (kh.progress / NULLIF(kh.target,0)) AS rel, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev, o.initiative_id FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id), diffs AS (SELECT initiative_id, rel - prev AS diff FROM hist WHERE prev IS NOT NULL) SELECT i.title, AVG(diff) AS avg_regression_change FROM diffs d JOIN initiative i ON d.initiative_id = i.id GROUP BY i.id, i.title HAVING AVG(diff) < 0 ORDER BY avg_regression_change ASC;

20. Qual a distribui√ß√£o de iniciativas por categoria?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2368ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.7315
   Table Similarity: 0.6667
   Query Affinity Score: 0.6991

   SQL Gerada:
   SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY initiative_count DESC;

   SQL Esperada (Gold):
   SELECT category, COUNT(id) AS total_initiatives, CAST(COUNT(id) AS FLOAT) * 100 / (SELECT COUNT(*) FROM initiative) AS percentage FROM initiative GROUP BY category ORDER BY total_initiatives DESC;

21. Quais iniciativas t√™m mais OKRs associados?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2470ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.9581
   Table Similarity: 0.1739
   Query Affinity Score: 0.5660

   SQL Gerada:
   SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;

   SQL Esperada (Gold):
   SELECT i.title, COUNT(o.id) AS total_okrs FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY total_okrs DESC;

22. Quantas iniciativas est√£o em andamento neste trimestre?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2480ms
   Exact Match: ‚úó
   Component Match: 1.0000
   Execution Match: ‚úì
   Cosine Similarity: 0.7219
   Table Similarity: 1.0000
   Query Affinity Score: 0.8609

   SQL Gerada:
   SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();

   SQL Esperada (Gold):
   SELECT COUNT(id) FROM initiative WHERE start_date <= date_trunc('quarter', CURRENT_DATE) + INTERVAL '3 month' - INTERVAL '1 second' AND (end_date IS NULL OR end_date >= date_trunc('quarter', CURRENT_DATE));

23. Quais iniciativas est√£o sem updates h√° mais de 30 dias?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3171ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8541
   Table Similarity: 0.0270
   Query Affinity Score: 0.4405

   SQL Gerada:
   SELECT i.title AS initiative_title, i.description AS initiative_description, iu.last_modified_date AS last_update_date FROM initiative AS i LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id WHERE iu.last_modified_date IS NULL OR iu.last_modified_date < NOW() - INTERVAL '30 days';

   SQL Esperada (Gold):
   SELECT i.title, MAX(iu.created_date) AS last_update FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title HAVING MAX(iu.created_date) IS NULL OR MAX(iu.created_date) < NOW() - INTERVAL '30' DAY ORDER BY last_update ASC;

24. Quais iniciativas t√™m prioridade m√°xima, mas baixo progresso de OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3457ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8824
   Table Similarity: 0.3333
   Query Affinity Score: 0.6079
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT i.title AS initiative_title, i.description AS initiative_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.description HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.5 ORDER BY avg_okr_progress ASC;

   SQL Corrigida (final):
   SELECT i.title AS initiative_title, i.description AS initiative_description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) AS avg_okr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.description HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) ELSE k.target::numeric / NULLIF(k.progress, 0) END) < 0.5 ORDER BY avg_okr_progress ASC;

   SQL Esperada (Gold):
   SELECT i.title, i.priority, AVG(k.progress / NULLIF(k.target, 0)) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.5 ORDER BY avg_okr_progress ASC;

25. Quantas iniciativas est√£o planejadas para come√ßar no pr√≥ximo m√™s?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2441ms
   Exact Match: ‚úó
   Component Match: 1.0000
   Execution Match: ‚úì
   Cosine Similarity: 0.9311
   Table Similarity: 1.0000
   Query Affinity Score: 0.9656

   SQL Gerada:
   SELECT COUNT(id) FROM initiative WHERE start_date BETWEEN date_trunc('month', NOW() + INTERVAL '1 month') AND date_trunc('month', NOW() + INTERVAL '2 months') - INTERVAL '1 day'

   SQL Esperada (Gold):
   SELECT COUNT(id) FROM initiative WHERE start_date >= date_trunc('month', CURRENT_DATE) + INTERVAL '1 month' AND start_date < date_trunc('month', CURRENT_DATE) + INTERVAL '2 month';

26. Quais iniciativas t√™m fim previsto antes do t√©rmino de seus OKRs?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2506ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úì
   Cosine Similarity: 0.8725
   Table Similarity: 1.0000
   Query Affinity Score: 0.9362

   SQL Gerada:
   SELECT DISTINCT i.title AS initiative_title FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;

   SQL Esperada (Gold):
   SELECT i.title, i.end_date, MAX(o.deadline) AS latest_okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date IS NOT NULL GROUP BY i.id, i.title, i.end_date HAVING i.end_date < MAX(o.deadline);

27. Quais iniciativas t√™m mais de tr√™s pessoas no time?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2824ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úì
   Cosine Similarity: 0.8875
   Table Similarity: 1.0000
   Query Affinity Score: 0.9438

   SQL Gerada:
   SELECT T1.title FROM initiative AS T1 JOIN initiative_managers AS T2 ON T1.id = T2.initiative_id GROUP BY T1.id HAVING count(T2.managers_id) > 3

   SQL Esperada (Gold):
   SELECT i.id, i.title, COUNT(im.managers_id) AS team_size FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id HAVING COUNT(im.managers_id) > 3

28. Qual √© a m√©dia de dura√ß√£o (em dias) das iniciativas conclu√≠das?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2645ms
   Exact Match: ‚úì
   Component Match: 1.0000
   Execution Match: ‚úì
   Cosine Similarity: 1.0000
   Table Similarity: 1.0000
   Query Affinity Score: 1.0000

   SQL Gerada:
   SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;

   SQL Esperada (Gold):
   SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;

29. Qual percentual de iniciativas por categoria est√° conclu√≠do?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3191ms
   Exact Match: ‚úó
   Component Match: 0.5625
   Execution Match: ‚úó
   Cosine Similarity: 0.9113
   Table Similarity: 0.2500
   Query Affinity Score: 0.5807

   SQL Gerada:
   SELECT i.category, SUM(CASE WHEN k.progress >= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'up' GROUP BY i.category UNION ALL SELECT i.category, SUM(CASE WHEN k.progress <= k.target THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id WHERE k.direction = 'down' GROUP BY i.category;

   SQL Esperada (Gold):
   WITH InitiativeKRStatus AS (SELECT i.id AS initiative_id, i.category, CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END AS kr_is_concluded FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT category, CAST(SUM(kr_is_concluded) AS FLOAT) * 100 / COUNT(*) AS percent_krs_concluded FROM InitiativeKRStatus GROUP BY category ORDER BY percent_krs_concluded DESC;

30. Quais iniciativas est√£o com maior prioridade, mas apresentam baixo progresso ou atualiza√ß√µes atrasadas?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3704ms
   Exact Match: ‚úó
   Component Match: 0.6250
   Execution Match: ‚úó
   Cosine Similarity: 0.7951
   Table Similarity: 0.5000
   Query Affinity Score: 0.6475

   SQL Gerada:
   SELECT i.title AS initiative_title, i.priority, i.end_date, iu.year_month AS last_update_month FROM initiative AS i LEFT JOIN ( SELECT initiative_id, MAX(year_month) AS year_month FROM initiative_update GROUP BY initiative_id ) AS iu ON i.id = iu.initiative_id WHERE i.priority = 1 -- Assumindo que 1 √© a maior prioridade AND ( NOT EXISTS ( SELECT 1 FROM kr WHERE kr.okr_id = i.id -- Assumindo que initiative.id √© o okr_id para krs relacionados AND ( (kr.direction = 'up' AND kr.progress / kr.target >= 0.5) OR (kr.direction = 'down' AND kr.progress / kr.target <= 0.5) ) ) OR iu.year_month < TO_CHAR(NOW() - INTERVAL '1 month', 'YYYY-MM') -- Atualiza√ß√µes atrasadas (ex: mais de um m√™s) ) ORDER BY i.priority DESC, i.end_date ASC;

   SQL Esperada (Gold):
   WITH InitiativePerformance AS (SELECT i.id AS initiative_id, i.title, i.priority, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS avg_okr_progress, (SELECT MAX(created_date) FROM initiative_update iu WHERE iu.initiative_id = i.id) AS last_update_date FROM initiative i) SELECT title, priority, avg_okr_progress, last_update_date FROM InitiativePerformance WHERE priority = 1 AND (avg_okr_progress < 0.5 OR last_update_date < NOW() - INTERVAL '30 days' OR last_update_date IS NULL) ORDER BY avg_okr_progress ASC NULLS FIRST, last_update_date ASC NULLS FIRST;

31. Quais KRs est√£o com dire√ß√£o ‚ÄúNEGATIVA‚Äù (indicando desempenho decrescente) e est√£o abaixo de 50% do target?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2583ms
   Exact Match: ‚úó
   Component Match: 0.9375
   Execution Match: ‚úó
   Cosine Similarity: 0.9402
   Table Similarity: 0.6667
   Query Affinity Score: 0.8034

   SQL Gerada:
   SELECT id, title, metric, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / target) < 0.5;

   SQL Esperada (Gold):
   SELECT title, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / NULLIF(target,0)) < 0.5;

32. Quais iniciativas apresentaram maior varia√ß√£o positiva de progresso nos √∫ltimos ciclos de atualiza√ß√£o?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3275ms
   Exact Match: ‚úó
   Component Match: 0.5000
   Execution Match: ‚úó
   Cosine Similarity: 0.7431
   Table Similarity: 0.1000
   Query Affinity Score: 0.4215

   SQL Gerada:
   SELECT i.title AS initiative_title, MAX(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) - MIN(CASE WHEN kh.direction = 'up' THEN kh.progress::numeric / kh.target ELSE kh.target::numeric / kh.progress END) AS progress_variation FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date >= (NOW() - INTERVAL '3 months') GROUP BY i.title ORDER BY progress_variation DESC;

   SQL Esperada (Gold):
   WITH NormHist AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh), Changes AS (SELECT nh.kr_id, nh.date, nh.norm_prog, nh.norm_prog - LAG(nh.norm_prog) OVER (PARTITION BY nh.kr_id ORDER BY nh.date) AS delta FROM NormHist nh), PosChanges AS (SELECT o.initiative_id, CASE WHEN k.direction = 'up'   AND delta > 0 THEN delta WHEN k.direction = 'down' AND delta < 0 THEN -delta END AS norm_delta FROM Changes c JOIN kr k ON c.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE delta IS NOT NULL AND c.date >= NOW() - INTERVAL '6 month' AND ((k.direction='up' AND delta > 0) OR (k.direction='down' AND delta < 0))) SELECT i.title, AVG(pc.norm_delta) AS avg_positive_change FROM initiative i JOIN PosChanges pc ON i.id = pc.initiative_id GROUP BY i.id, i.title ORDER BY avg_positive_change DESC;

33. Quais colaboradores foram respons√°veis pelos KRs com melhor taxa de atingimento?
   Status: ‚ùå ERROR
   Erro: Erro de execu√ß√£o no banco ap√≥s 3 tentativa(s): syntax error at end of input

   SQL Gerada (com erro):
   SELECT c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_achievement_rate FROM collaborator AS c JOIN kr AS k ON c.id = k.created_by GROUP BY c.name ORDER BY average_achievement_rate DESC;

   SQL Esperada (Gold):
   SELECT c.name, AVG(k.progress / k.target) AS avg_achievement_rate FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name HAVING COUNT(DISTINCT k.id) > 1 ORDER BY avg_achievement_rate DESC;

34. Quais colaboradores t√™m progresso m√©dio de KRs acima da m√©dia geral dos colaboradores?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3478ms
   Exact Match: ‚úó
   Component Match: 0.6250
   Execution Match: ‚úó
   Cosine Similarity: 0.8147
   Table Similarity: 0.1304
   Query Affinity Score: 0.4725
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   WITH CollaboratorKRProgress AS ( SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target WHEN k.direction = 'down' THEN k.target::numeric / k.progress ELSE NULL END) AS avg_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ), OverallAverage AS ( SELECT AVG(avg_kr_progress) AS overall_avg_progress FROM CollaboratorKRProgress ) SELECT ckp.collaborator_name, ckp.avg_kr_progress FROM CollaboratorKRProgress AS ckp, OverallAverage AS oa WHERE ckp.avg_kr_progress > oa.overall_avg_progress ORDER BY ckp.avg_kr_progress DESC;

   SQL Corrigida (final):
   WITH CollaboratorKRProgress AS ( SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' AND k.target <> 0 THEN k.progress::numeric / k.target WHEN k.direction = 'down' AND k.progress <> 0 THEN k.target::numeric / k.progress ELSE NULL END) AS avg_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ), OverallAverage AS ( SELECT AVG(avg_kr_progress) AS overall_avg_progress FROM CollaboratorKRProgress ) SELECT ckp.collaborator_name, ckp.avg_kr_progress FROM CollaboratorKRProgress AS ckp, OverallAverage AS oa WHERE ckp.avg_kr_progress > oa.overall_avg_progress ORDER BY ckp.avg_kr_progress DESC;

   SQL Esperada (Gold):
   WITH CollaboratorAvg AS (SELECT kh.collaborator_id, AVG(kh.progress / NULLIF(kh.target,0)) AS collaborator_progress FROM kr_history kh GROUP BY kh.collaborator_id), GlobalAvg AS (SELECT AVG(progress / NULLIF(target,0)) AS global_progress FROM kr_history) SELECT c.name, ca.collaborator_progress FROM collaborator c JOIN CollaboratorAvg ca ON c.id = ca.collaborator_id CROSS JOIN GlobalAvg ga WHERE ca.collaborator_progress > ga.global_progress ORDER BY ca.collaborator_progress DESC;

35. Quais colaboradores possuem mais KRs ‚Äúbookmarked‚Äù do que a m√©dia geral de bookmarks por colaborador?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2683ms
   Exact Match: ‚úó
   Component Match: 0.5625
   Execution Match: ‚úó
   Cosine Similarity: 0.8927
   Table Similarity: 0.2941
   Query Affinity Score: 0.5934

   SQL Gerada:
   SELECT c.name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name HAVING COUNT(k.id) > (SELECT AVG(bookmarked_count) FROM (SELECT COUNT(id) AS bookmarked_count FROM kr WHERE bookmarked = TRUE GROUP BY bookmarked_by_id) AS avg_bookmarks);

   SQL Esperada (Gold):
   WITH BookmarkCount AS ( SELECT bookmarked_by_id, COUNT(id) AS total_bookmarks FROM kr WHERE bookmarked_by_id IS NOT NULL GROUP BY bookmarked_by_id ), AvgBookmarks AS ( SELECT AVG(total_bookmarks) AS global_avg FROM BookmarkCount ) SELECT c.name, bc.total_bookmarks FROM collaborator c JOIN BookmarkCount bc ON c.id = bc.bookmarked_by_id CROSS JOIN AvgBookmarks ab WHERE bc.total_bookmarks > ab.global_avg ORDER BY bc.total_bookmarks DESC;

36. Gerar o ranking de colaboradores com maior m√©dia de progresso em KRs dentro de cada categoria de iniciativa.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3267ms
   Exact Match: ‚úó
   Component Match: 0.6250
   Execution Match: ‚úó
   Cosine Similarity: 0.8644
   Table Similarity: 0.3009
   Query Affinity Score: 0.5826

   SQL Gerada:
   SELECT c.name AS collaborator_name, i.category AS initiative_category, AVG(CASE WHEN k.direction = 'up' THEN k.progress / k.target WHEN k.direction = 'down' THEN (k.target - k.progress) / k.target ELSE NULL END) AS average_kr_progress FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id JOIN okr AS o ON k.okr_id = o.id JOIN initiative AS i ON o.initiative_id = i.id GROUP BY c.name, i.category ORDER BY i.category, average_kr_progress DESC;

   SQL Esperada (Gold):
   SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;

37. Selecionar colaboradores que contribu√≠ram para KRs com progresso superior ao percentil 90 global.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 4340ms
   Exact Match: ‚úó
   Component Match: 0.6250
   Execution Match: ‚úó
   Cosine Similarity: 0.8282
   Table Similarity: 0.3542
   Query Affinity Score: 0.5912

   SQL Gerada:
   WITH KRProgress AS ( SELECT kh.collaborator_id, kh.kr_id, CASE WHEN k.direction = 'up' THEN kh.progress::NUMERIC / k.target WHEN k.direction = 'down' THEN k.target::NUMERIC / kh.progress ELSE NULL END AS calculated_progress FROM kr_history AS kh JOIN kr AS k ON kh.kr_id = k.id WHERE kh.progress IS NOT NULL AND k.target IS NOT NULL AND k.target <> 0 AND kh.progress <> 0 ), Percentile90 AS ( SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM KRProgress ) SELECT DISTINCT c.name AS collaborator_name, c.email FROM collaborator AS c JOIN KRProgress AS kp ON c.id = kp.collaborator_id WHERE kp.calculated_progress > ( SELECT p90_value FROM Percentile90 );

   SQL Esperada (Gold):
   WITH GlobalPercentile AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (progress / NULLIF(target,0))) AS p90_progress FROM kr_history) SELECT DISTINCT c.name FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id CROSS JOIN GlobalPercentile gp WHERE (kh.progress / NULLIF(kh.target,0)) > gp.p90_progress;

38. Como evoluiu o progresso m√©dio dos KRs nos √∫ltimos 6 meses?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3321ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8984
   Table Similarity: 0.0000
   Query Affinity Score: 0.4492
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT TO_CHAR(date_trunc('month', date), 'YYYY-MM') AS month, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target WHEN T1.direction = 'down' THEN T1.target :: NUMERIC / T1.progress ELSE NULL END) AS average_progress FROM kr_history AS T1 WHERE date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;

   SQL Corrigida (final):
   SELECT TO_CHAR(date_trunc('month', kh.date), 'YYYY-MM') AS month, AVG( CASE WHEN kh.direction = 'up' AND kh.target != 0 THEN kh.progress :: NUMERIC / kh.target WHEN kh.direction = 'down' AND kh.progress != 0 THEN kh.target :: NUMERIC / kh.progress ELSE NULL END ) AS average_progress FROM kr_history AS kh WHERE kh.date >= date_trunc('month', NOW() - INTERVAL '6 months') GROUP BY month ORDER BY month;

   SQL Esperada (Gold):
   SELECT DATE_TRUNC('month', date) AS month_start, AVG(progress / NULLIF(target,0)) AS avg_monthly_progress FROM kr_history WHERE date >= DATE_TRUNC('month', NOW() - INTERVAL '6 month') AND date <= NOW() GROUP BY month_start ORDER BY month_start;

39. Qual foi a varia√ß√£o de progresso por colaborador no √∫ltimo trimestre?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 4100ms
   Exact Match: ‚úó
   Component Match: 0.5000
   Execution Match: ‚úó
   Cosine Similarity: 0.8260
   Table Similarity: 0.0468
   Query Affinity Score: 0.4364

   SQL Gerada:
   SELECT c.name AS collaborator_name, kh.kr_id, kh.metric, kh.direction, (kh_end.progress - kh_start.progress) AS progress_variation FROM collaborator AS c JOIN kr_history AS kh ON c.id = kh.collaborator_id JOIN kr_history AS kh_start ON kh.kr_id = kh_start.kr_id AND kh.collaborator_id = kh_start.collaborator_id JOIN kr_history AS kh_end ON kh.kr_id = kh_end.kr_id AND kh.collaborator_id = kh_end.collaborator_id WHERE kh.date >= NOW() - INTERVAL '3 months' AND kh.date <= NOW() AND kh_start.date = ( SELECT MIN(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date >= NOW() - INTERVAL '3 months' ) AND kh_end.date = ( SELECT MAX(date) FROM kr_history WHERE kr_id = kh.kr_id AND collaborator_id = kh.collaborator_id AND date <= NOW() ) GROUP BY c.name, kh.kr_id, kh.metric, kh.direction, progress_variation ORDER BY c.name, kh.kr_id;

   SQL Esperada (Gold):
   WITH Hist AS (SELECT kh.collaborator_id, kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '3 month'), Ranked AS (SELECT collaborator_id, kr_id, norm_prog, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date ASC) AS rn_first, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date DESC) AS rn_last FROM Hist), FirstLast AS (SELECT collaborator_id, kr_id, MAX(CASE WHEN rn_first = 1 THEN norm_prog END) AS first_prog, MAX(CASE WHEN rn_last = 1 THEN norm_prog END) AS last_prog FROM Ranked GROUP BY collaborator_id, kr_id) SELECT c.name, AVG(last_prog - first_prog) AS progress_change_qtr FROM collaborator c JOIN FirstLast fl ON c.id = fl.collaborator_id GROUP BY c.id, c.name ORDER BY progress_change_qtr DESC;

40. Quantos registros de hist√≥rico de KR foram criados no √∫ltimo m√™s?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3033ms
   Exact Match: ‚úó
   Component Match: 0.9375
   Execution Match: ‚úó
   Cosine Similarity: 0.9247
   Table Similarity: 1.0000
   Query Affinity Score: 0.9623

   SQL Gerada:
   SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month'

   SQL Esperada (Gold):
   SELECT COUNT(id) AS history_count_last_month FROM kr_history WHERE date >= NOW() - INTERVAL '1' MONTH;

41. Quais KRs apresentaram regress√£o de progresso em algum momento?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2940ms
   Exact Match: ‚úó
   Component Match: 0.5000
   Execution Match: ‚úó
   Cosine Similarity: 0.6335
   Table Similarity: 0.9217
   Query Affinity Score: 0.7776

   SQL Gerada:
   SELECT DISTINCT T1.title FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress < (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1)) OR (T1.direction = 'down' AND T2.progress > (SELECT T3.progress FROM kr_history AS T3 WHERE T3.kr_id = T2.kr_id AND T3.date < T2.date ORDER BY T3.date DESC LIMIT 1));

   SQL Esperada (Gold):
   WITH Regressions AS (SELECT kr_id, (progress / NULLIF(target,0)) AS norm_progress, LAG(progress / NULLIF(target,0)) OVER (PARTITION BY kr_id ORDER BY date) AS prev_norm_progress FROM kr_history) SELECT DISTINCT k.title FROM kr k JOIN Regressions r ON k.id = r.kr_id WHERE r.norm_progress < r.prev_norm_progress;

42. Qual a m√©dia de varia√ß√£o percentual de progresso por m√©trica (PERC, NUMERIC, YES_NO)?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3390ms
   Exact Match: ‚úó
   Component Match: 0.5625
   Execution Match: ‚úó
   Cosine Similarity: 0.7547
   Table Similarity: 0.5000
   Query Affinity Score: 0.6274
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT kr.metric, AVG( CASE WHEN kr.direction = 'up' THEN kr.progress / kr.target WHEN kr.direction = 'down' THEN kr.target / kr.progress ELSE NULL END ) AS average_progress_percentage FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC', 'YES_NO') GROUP BY kr.metric;

   SQL Corrigida (final):
   SELECT kr.metric, AVG(CASE WHEN kr.direction = 'up' THEN kr.progress / NULLIF(kr.target, 0) WHEN kr.direction = 'down' THEN kr.target / NULLIF(kr.progress, 0) ELSE NULL END) AS average_progress_percentage FROM kr WHERE kr.metric IN ('PERC', 'NUMERIC', 'YES_NO') GROUP BY kr.metric;

   SQL Esperada (Gold):
   WITH ranked_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog, k.metric, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_norm_prog FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), progress_changes AS (SELECT metric, ABS(norm_prog - prev_norm_prog) / NULLIF(prev_norm_prog, 0) * 100 AS variation_percent FROM ranked_history WHERE prev_norm_prog IS NOT NULL) SELECT metric, AVG(variation_percent) AS avg_variation_percent FROM progress_changes GROUP BY metric;

43. Quantos KRs tiveram hist√≥rico de progresso acima de 90% antes do prazo final?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3171ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8033
   Table Similarity: 0.0000
   Query Affinity Score: 0.4016

   SQL Gerada:
   SELECT COUNT(DISTINCT T1.id) FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T1.direction = 'up' AND T2.progress * 1.0 / T1.target >= 0.9) OR (T1.direction = 'down' AND T2.progress * 1.0 / T1.target <= 0.1)

   SQL Esperada (Gold):
   SELECT COUNT(DISTINCT kh.kr_id) as krs_acima_90 FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE (kh.progress/k.target)*100 >= 90 AND kh.date < o.deadline;

44. Quais colaboradores atualizaram o maior n√∫mero de KRs no hist√≥rico?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2452ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8384
   Table Similarity: 0.0333
   Query Affinity Score: 0.4359

   SQL Gerada:
   SELECT T1.name, COUNT(T2.kr_id) AS num_updates FROM collaborator AS T1 JOIN kr_history AS T2 ON T1.id = T2.collaborator_id GROUP BY T1.name ORDER BY num_updates DESC LIMIT 1;

   SQL Esperada (Gold):
   SELECT c.id, c.name, COUNT(kh.id) as total_atualizacoes FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name ORDER BY total_atualizacoes DESC LIMIT 10;

45. Quantos updates de iniciativa foram registrados por m√™s neste ano?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2821ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.9118
   Table Similarity: 0.3333
   Query Affinity Score: 0.6226

   SQL Gerada:
   SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(id) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;

   SQL Esperada (Gold):
   SELECT EXTRACT(YEAR FROM created_date) as ano, EXTRACT(MONTH FROM created_date) as mes, COUNT(*) as total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY ano, mes ORDER BY ano, mes;

46. Quais iniciativas tiveram maior n√∫mero de updates em um √∫nico m√™s?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2649ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.9165
   Table Similarity: 0.0200
   Query Affinity Score: 0.4683

   SQL Gerada:
   SELECT i.title AS initiative_title, COUNT(iu.id) AS num_updates, TO_CHAR(iu.created_date, 'YYYY-MM') AS month FROM initiative AS i JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;

   SQL Esperada (Gold):
   SELECT i.id, i.title, EXTRACT(YEAR FROM iu.created_date) as ano, EXTRACT(MONTH FROM iu.created_date) as mes, COUNT(iu.id) as updates_mes FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title, ano, mes ORDER BY updates_mes DESC LIMIT 10;

47. Qual o tempo m√©dio entre updates consecutivos de uma mesma iniciativa?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2813ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8647
   Table Similarity: 0.0000
   Query Affinity Score: 0.4324

   SQL Gerada:
   SELECT AVG(diff_in_seconds) AS average_time_between_updates FROM ( SELECT initiative_id, created_date, LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date) AS previous_created_date, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) AS diff_in_seconds FROM initiative_update ) AS subquery WHERE previous_created_date IS NOT NULL;

   SQL Esperada (Gold):
   WITH update_gaps AS (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) / 86400 as dias_entre_updates FROM initiative_update) SELECT AVG(dias_entre_updates) as tempo_medio_dias FROM update_gaps WHERE dias_entre_updates IS NOT NULL;

48. Para cada iniciativa, qual √© o KR mais recente e seu progresso atual?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3807ms
   Exact Match: ‚úó
   Component Match: 0.5000
   Execution Match: ‚úó
   Cosine Similarity: 0.7709
   Table Similarity: 0.2645
   Query Affinity Score: 0.5177

   SQL Gerada:
   SELECT i.title AS initiative_title, kr.title AS kr_title, kr.progress AS kr_current_progress, kr.target AS kr_target, kr.direction AS kr_direction, CASE WHEN kr.direction = 'up' THEN kr.progress :: NUMERIC / kr.target WHEN kr.direction = 'down' THEN CASE WHEN kr.progress <= kr.target THEN 1.0 ELSE kr.target :: NUMERIC / kr.progress END ELSE NULL END AS kr_calculated_progress FROM initiative AS i JOIN kr ON i.id = kr.okr_id WHERE kr.id IN ( SELECT MAX(kr_inner.id) FROM kr AS kr_inner GROUP BY kr_inner.okr_id ) ORDER BY i.title;

   SQL Esperada (Gold):
   WITH ranked_krs AS (SELECT i.id as iniciativa_id, i.title as iniciativa, k.id as kr_id, k.title as kr, k.progress, k.last_modified_date, ROW_NUMBER() OVER (PARTITION BY i.id ORDER BY k.last_modified_date DESC) as rn FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT iniciativa_id, iniciativa, kr_id, kr, progress FROM ranked_krs WHERE rn = 1;

49. Analisar a tend√™ncia de redu√ß√£o na frequ√™ncia de updates conforme o deadline dos OKRs se aproxima.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3479ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.9384
   Table Similarity: 0.1940
   Query Affinity Score: 0.5662

   SQL Gerada:
   SELECT o.id AS okr_id, o.deadline, COUNT(iu.id) AS total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / (60 * 60 * 24)) AS avg_days_to_deadline_at_update FROM okr AS o JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline ORDER BY o.deadline;

   SQL Esperada (Gold):
   SELECT i.id, i.title, o.deadline, COUNT(iu.id) as total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / 86400) as dias_antes_prazo_medio FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.created_date <= o.deadline GROUP BY i.id, i.title, o.deadline ORDER BY dias_antes_prazo_medio;

50. Listar KRs com lacunas maiores que 30 dias entre atualiza√ß√µes de progresso
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3557ms
   Exact Match: ‚úó
   Component Match: 0.5625
   Execution Match: ‚úó
   Cosine Similarity: 0.7709
   Table Similarity: 0.2508
   Query Affinity Score: 0.5109
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå window functions are not allowed in WHERE
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT T1.title AS kr_title, T1.metric, T1.direction, T1.target, T1.progress, T2.date AS update_date, LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date) AS previous_update_date, (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) AS time_difference FROM kr AS T1 INNER JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) > INTERVAL '30 days' ORDER BY T1.title, T2.date;

   SQL Corrigida (final):
   WITH KrUpdateDifferences AS ( SELECT T1.title AS kr_title, T1.metric, T1.direction, T1.target, T1.progress, T2.date AS update_date, LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date) AS previous_update_date, (T2.date - LAG(T2.date) OVER (PARTITION BY T1.id ORDER BY T2.date)) AS time_difference FROM kr AS T1 INNER JOIN kr_history AS T2 ON T1.id = T2.kr_id ) SELECT kr_title, metric, direction, target, progress, update_date, previous_update_date, time_difference FROM KrUpdateDifferences WHERE time_difference > INTERVAL '30 days' ORDER BY kr_title, update_date;

   SQL Esperada (Gold):
   WITH kr_update_gaps AS (SELECT kh.kr_id, k.title as kr_title, kh.date as current_date, LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) as previous_date, EXTRACT(EPOCH FROM (kh.date - LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date))) / 86400 as dias_entre_atualizacoes FROM kr_history kh JOIN kr k ON kh.kr_id = k.id) SELECT kr_id, kr_title, previous_date, current_date, dias_entre_atualizacoes FROM kr_update_gaps WHERE dias_entre_atualizacoes > 30 ORDER BY dias_entre_atualizacoes DESC;

51. Quais OKRs est√£o com prazo pr√≥ximo do vencimento?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2520ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úì
   Cosine Similarity: 0.9131
   Table Similarity: 1.0000
   Query Affinity Score: 0.9566

   SQL Gerada:
   SELECT id, description, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days'

   SQL Esperada (Gold):
   SELECT id, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' ORDER BY deadline ASC;

52. Qual √© a m√©dia de progresso dos KRs em cada OKR?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3247ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.7673
   Table Similarity: 0.0224
   Query Affinity Score: 0.3949
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå column t1.title does not exist
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT T1.title AS okr_title, AVG(CASE WHEN T2.direction = 'up' THEN T2.progress / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) / T2.target ELSE 0 END) AS average_kr_progress FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title;

   SQL Corrigida (final):
   SELECT T1.description AS okr_description, AVG(CASE WHEN T2.direction = 'up' THEN T2.progress / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) / T2.target ELSE 0 END) AS average_kr_progress FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description;

   SQL Esperada (Gold):
   SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id;

53. Quais OKRs t√™m menor progresso m√©dio?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3151ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.7760
   Table Similarity: 0.1000
   Query Affinity Score: 0.4380
   Tentativas de corre√ß√£o: 3
     Tentativa 1: ‚ùå column t1.title does not exist
     Tentativa 2: ‚ùå division by zero
     Tentativa 3: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT T1.title AS okr_title, AVG( CASE WHEN T2.direction = 'up' THEN T2.progress :: NUMERIC / T2.target WHEN T2.direction = 'down' THEN T2.target :: NUMERIC / T2.progress ELSE NULL END ) AS average_progress FROM okr AS T1 INNER JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title ORDER BY average_progress LIMIT 1;

   SQL Corrigida (final):
   SELECT T1.description AS okr_description, AVG( CASE WHEN T2.direction = 'up' AND T2.target <> 0 THEN T2.progress :: NUMERIC / T2.target WHEN T2.direction = 'down' AND T2.progress <> 0 THEN T2.target :: NUMERIC / T2.progress ELSE NULL END ) AS average_progress FROM okr AS T1 INNER JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description ORDER BY average_progress LIMIT 1;

   SQL Esperada (Gold):
   SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id ORDER BY avg_progress ASC LIMIT 5;

54. Qual √© o percentual de KRs conclu√≠dos por iniciativa?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2893ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.9002
   Table Similarity: 0.1087
   Query Affinity Score: 0.5044

   SQL Gerada:
   SELECT i.title AS initiative_title, CAST(SUM(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(k.id) AS completed_kr_percentage FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id GROUP BY i.title ORDER BY i.title;

   SQL Esperada (Gold):
   SELECT i.id AS initiative_id, SUM(CASE WHEN (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id;

55. Qual o tempo m√©dio restante at√© o deadline dos OKRs ativos?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2896ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.7489
   Table Similarity: 0.0000
   Query Affinity Score: 0.3745
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå column t2.active does not exist
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT AVG(EXTRACT(EPOCH FROM (T1.deadline - NOW()))) AS media_tempo_restante_segundos FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T2.active = TRUE AND T1.deadline IS NOT NULL AND T1.deadline > NOW();

   SQL Corrigida (final):
   SELECT AVG(EXTRACT(EPOCH FROM (T1.deadline - NOW()))) AS media_tempo_restante_segundos FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T1.deadline IS NOT NULL AND T1.deadline > NOW();

   SQL Esperada (Gold):
   SELECT AVG(EXTRACT(EPOCH FROM (deadline - NOW())) / 86400) AS avg_days_remaining FROM okr WHERE deadline > NOW();

56. Quais OKRs est√£o vinculados a iniciativas que j√° encerraram?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2726ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8220
   Table Similarity: 0.0000
   Query Affinity Score: 0.4110
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå column t1.title does not exist
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT DISTINCT T1.title FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id JOIN initiative AS T3 ON T1.initiative_id = T3.id WHERE T3.end_date < NOW();

   SQL Corrigida (final):
   SELECT T1.description FROM okr AS T1 JOIN initiative AS T2 ON T1.initiative_id = T2.id WHERE T2.end_date < NOW();

   SQL Esperada (Gold):
   SELECT o.id AS okr_id, o.initiative_id, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL AND i.end_date < NOW();

57. Quantos KRs est√£o atrasados em rela√ß√£o √† meta planejada?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3414ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8430
   Table Similarity: 0.0000
   Query Affinity Score: 0.4215

   SQL Gerada:
   SELECT COUNT(T1.id) FROM kr AS T1 JOIN okr AS T2 ON T1.okr_id = T2.id WHERE (T1.direction = 'up' AND T1.progress < T1.target AND T2.deadline < NOW()) OR (T1.direction = 'down' AND T1.progress > T1.target AND T2.deadline < NOW())

   SQL Esperada (Gold):
   SELECT COUNT(*) AS delayed_kr_count FROM kr k JOIN kr_history kh ON kh.kr_id = k.id AND kh.date = (SELECT MAX(h.date) FROM kr_history h WHERE h.kr_id = k.id) WHERE (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) < 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > 1);

58. Qual o progresso m√©dio dos KRs de tipo ‚ÄúPERC‚Äù em compara√ß√£o aos de tipo ‚ÄúNUMERIC‚Äù?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2796ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.8053
   Table Similarity: 0.0000
   Query Affinity Score: 0.4026

   SQL Gerada:
   SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_perc, AVG(CASE WHEN T1.direction = 'up' THEN T1.progress / T1.target ELSE T1.target / T1.progress END) AS average_progress_numeric FROM kr AS T1 WHERE T1.metric = 'PERC' OR T1.metric = 'NUMERIC';

   SQL Esperada (Gold):
   SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric;

59. Quais OKRs t√™m maior n√∫mero de KRs associados?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2438ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.7309
   Table Similarity: 0.0385
   Query Affinity Score: 0.3847
   Tentativas de corre√ß√£o: 2
     Tentativa 1: ‚ùå column t1.title does not exist
     Tentativa 2: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT T1.title, COUNT(T2.id) AS num_krs FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.title ORDER BY num_krs DESC;

   SQL Corrigida (final):
   SELECT T1.description, COUNT(T2.id) AS num_krs FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id GROUP BY T1.description ORDER BY num_krs DESC;

   SQL Esperada (Gold):
   SELECT okr_id, COUNT(*) AS kr_count FROM kr GROUP BY okr_id ORDER BY kr_count DESC LIMIT 5;

60. Qual o percentual de KRs marcados como ‚Äúbookmarked‚Äù pelos colaboradores?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2629ms
   Exact Match: ‚úó
   Component Match: 0.8750
   Execution Match: ‚úó
   Cosine Similarity: 0.7513
   Table Similarity: 1.0000
   Query Affinity Score: 0.8756

   SQL Gerada:
   SELECT CAST(SUM(CASE WHEN T1.bookmarked = TRUE THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(T1.id) FROM kr AS T1

   SQL Esperada (Gold):
   SELECT COUNT(*) FILTER (WHERE bookmarked) * 100.0 / COUNT(*) AS percent_bookmarked FROM kr;

61. Qual √© o percentual m√©dio de progresso dos KRs (Key Results) em rela√ß√£o √†s metas estabelecidas nos √∫ltimos tr√™s meses?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3193ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8587
   Table Similarity: 0.0000
   Query Affinity Score: 0.4294

   SQL Gerada:
   SELECT AVG(CASE WHEN T1.direction = 'up' THEN T1.progress :: NUMERIC / T1.target WHEN T1.direction = 'down' THEN T1.target :: NUMERIC / T1.progress ELSE NULL END) AS average_progress_percentage FROM kr AS T1 WHERE T1.created_date >= NOW() - INTERVAL '3 months';

   SQL Esperada (Gold):
   SELECT AVG(kh.progress / NULLIF(k.target, 0)) * 100 AS avg_progress_percent FROM kr k JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 months';

62. Quais colaboradores t√™m mais KRs marcados como ‚Äúbookmarked‚Äù (favoritos) e demonstram maior engajamento com os objetivos da empresa?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2607ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.9517
   Table Similarity: 0.2319
   Query Affinity Score: 0.5918

   SQL Gerada:
   SELECT c.name AS collaborator_name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator AS c JOIN kr AS k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name ORDER BY bookmarked_kr_count DESC;

   SQL Esperada (Gold):
   SELECT c.id, c.name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator c JOIN kr k ON k.bookmarked_by_id = c.id AND k.bookmarked = true GROUP BY c.id, c.name ORDER BY bookmarked_kr_count DESC LIMIT 10;

63. Qual √© o tempo m√©dio entre a cria√ß√£o de um OKR e a primeira atualiza√ß√£o de progresso registrada?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2926ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8648
   Table Similarity: 0.0000
   Query Affinity Score: 0.4324

   SQL Gerada:
   SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS average_time_seconds FROM okr AS o JOIN kr AS k ON o.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE kh.date = (SELECT MIN(kh2.date) FROM kr_history AS kh2 WHERE kh2.kr_id = k.id);

   SQL Esperada (Gold):
   SELECT AVG(EXTRACT(EPOCH FROM (kh.first_update - o.created_date)) / 86400) AS avg_days_to_first_update FROM okr o JOIN (SELECT k.okr_id, MIN(kh.date) AS first_update FROM kr k JOIN kr_history kh ON kh.kr_id = k.id GROUP BY k.okr_id) kh ON kh.okr_id = o.id;

64. Quantos OKRs est√£o pr√≥ximos do prazo final (deadline) e ainda n√£o atingiram 80% de progresso?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3407ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.7983
   Table Similarity: 0.0000
   Query Affinity Score: 0.3992

   SQL Gerada:
   SELECT COUNT(DISTINCT T1.id) FROM okr AS T1 JOIN kr AS T2 ON T1.id = T2.okr_id WHERE T1.deadline IS NOT NULL AND T1.deadline <= NOW() + INTERVAL '7 days' AND (CASE WHEN T2.direction = 'up' THEN T2.progress * 1.0 / T2.target WHEN T2.direction = 'down' THEN (T2.target - T2.progress) * 1.0 / T2.target ELSE 0 END) < 0.8;

   SQL Esperada (Gold):
   SELECT COUNT(*) AS okrs_near_deadline_low_progress FROM ( SELECT o.id FROM okr o JOIN kr k ON k.okr_id = o.id WHERE o.deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' GROUP BY o.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8 ) sub;

65. Quais iniciativas possuem OKRs cujo progresso m√©dio supera o progresso m√©dio global de todas as iniciativas da mesma categoria?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3608ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.8991
   Table Similarity: 0.5417
   Query Affinity Score: 0.7204

   SQL Gerada:
   WITH InitiativeAvgProgress AS ( SELECT i.id AS initiative_id, i.category, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target WHEN k.direction = 'down' THEN (k.target - k.progress)::numeric / k.target ELSE 0 END) AS avg_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY i.id, i.category ), CategoryGlobalAvgProgress AS ( SELECT category, AVG(avg_kr_progress) AS global_avg_progress FROM InitiativeAvgProgress GROUP BY category ) SELECT iap.initiative_id, iap.category, iap.avg_kr_progress FROM InitiativeAvgProgress AS iap JOIN CategoryGlobalAvgProgress AS cgap ON iap.category = cgap.category WHERE iap.avg_kr_progress > cgap.global_avg_progress;

   SQL Esperada (Gold):
   WITH initiative_avg AS (SELECT i.id, i.category, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, i.category), category_avg AS (SELECT category, AVG(avg_progress) AS category_avg_progress FROM initiative_avg GROUP BY category) SELECT ia.id, ia.category, ia.avg_progress FROM initiative_avg ia JOIN category_avg ca ON ia.category = ca.category WHERE ia.avg_progress > ca.category_avg_progress;

66. Qual colaborador teve o maior aumento percentual de progresso m√©dio de KRs entre o √∫ltimo e o pen√∫ltimo m√™s?
   Status: ‚ùå ERROR
   Erro: Erro de execu√ß√£o no banco ap√≥s 3 tentativa(s): syntax error at or near "{"

   SQL Gerada (com erro):
   { "sql": "WITH MonthlyProgress AS (\n SELECT\n kh.collaborator_id,\n c.name AS collaborator_name,\n DATE_TRUNC('month', kh.date) AS month_start,\n AVG(CASE\n WHEN k.direction = 'up' THEN kh.progress::numeric / kh.target\n WHEN k.direction = 'down' THEN kh.target::numeric / kh.progress\n ELSE 0\n END) AS avg_kr_progress\n FROM kr_history AS kh\n JOIN kr AS k\n ON kh.kr_id = k.id\n JOIN collaborator AS c\n ON kh.collaborator_id = c.id\n GROUP BY\n kh.collaborator_id,\n c.name,\n DATE_TRUNC('month', kh.date)\n),\nRankedProgress AS (\n SELECT\n collaborator_id,\n collaborator_name,\n month_start,\n avg_kr_progress,\n RANK() OVER (PARTITION BY collaborator_id ORDER BY month_start DESC) AS rn\n FROM MonthlyProgress\n),\nLastTwoMonths AS (\n SELECT\n collaborator_id,\n collaborator_name,\n month_start,\n avg_kr_progress\n FROM RankedProgress\n WHERE\n rn <= 2\n)\nSELECT\n l2.collaborator_name,\n (\n (l2.avg_kr_progress - l1.avg_kr_progress) / l1.avg_kr_progress\n ) * 100 AS percentage_increase\nFROM LastTwoMonths AS l1\nJOIN LastTwoMonths AS l2\n ON l1.collaborator_id = l2.collaborator_id\nWHERE\n l1.rn = 2 AND l2.rn = 1 AND l1.avg_kr_progress IS NOT NULL AND l1.avg_kr_progress <> 0\nORDER BY\n percentage_increase DESC\nLIMIT 1;", "complementaryText": "Esta query identifica

   SQL Esperada (Gold):
   WITH monthly_progress AS (SELECT collaborator_id, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr_history GROUP BY collaborator_id, month), ranked_progress AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY collaborator_id ORDER BY month DESC) AS rn FROM monthly_progress), last_two_months AS (SELECT p1.collaborator_id, p1.avg_progress AS last_month_progress, p2.avg_progress AS prev_month_progress, CASE WHEN p2.avg_progress = 0 THEN NULL ELSE ((p1.avg_progress - p2.avg_progress) / p2.avg_progress) * 100 END AS pct_increase FROM ranked_progress p1 JOIN ranked_progress p2 ON p1.collaborator_id = p2.collaborator_id WHERE p1.rn = 1 AND p2.rn = 2) SELECT collaborator_id, pct_increase FROM last_two_months ORDER BY pct_increase DESC LIMIT 1;

67. Quais iniciativas tiveram pelo menos um KR com progresso superior a 100% em algum ponto do hist√≥rico?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3125ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8713
   Table Similarity: 0.1852
   Query Affinity Score: 0.5283

   SQL Gerada:
   SELECT DISTINCT i.title FROM initiative AS i JOIN kr AS k ON i.id = k.okr_id JOIN kr_history AS kh ON k.id = kh.kr_id WHERE (k.direction = 'up' AND kh.progress > kh.target) OR (k.direction = 'down' AND kh.progress < kh.target)

   SQL Esperada (Gold):
   SELECT DISTINCT i.id, i.title FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target, 0) > 1;

68. Qual √© o tempo m√©dio (em dias) entre atualiza√ß√µes consecutivas de um mesmo KR no hist√≥rico?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2735ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8722
   Table Similarity: 1.0000
   Query Affinity Score: 0.9361

   SQL Gerada:
   SELECT AVG(diff_days) FROM (SELECT kr_id, date, LAG(date) OVER (PARTITION BY kr_id ORDER BY date) AS prev_date, EXTRACT(EPOCH FROM (date - LAG(date) OVER (PARTITION BY kr_id ORDER BY date))) / 86400 AS diff_days FROM kr_history) AS subquery WHERE diff_days IS NOT NULL;

   SQL Esperada (Gold):
   WITH diffs AS (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date FROM kr_history) SELECT AVG(EXTRACT(EPOCH FROM (next_date - date)) / 86400) AS avg_days_between_updates FROM diffs WHERE next_date IS NOT NULL;

69. Quais iniciativas t√™m pelo menos dois OKRs com deadlines no mesmo m√™s?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2714ms
   Exact Match: ‚úó
   Component Match: 0.7500
   Execution Match: ‚úó
   Cosine Similarity: 0.8395
   Table Similarity: 0.0000
   Query Affinity Score: 0.4197

   SQL Gerada:
   SELECT i.title AS initiative_title FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title, EXTRACT(MONTH FROM o.deadline), EXTRACT(YEAR FROM o.deadline) HAVING COUNT(o.id) >= 2;

   SQL Esperada (Gold):
   SELECT initiative_id FROM okr GROUP BY initiative_id, DATE_TRUNC('month', deadline) HAVING COUNT(*) >= 2;

70. Qual √© a distribui√ß√£o percentual de KRs por tipo de m√©trica dentro de cada iniciativa?
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3122ms
   Exact Match: ‚úó
   Component Match: 0.6250
   Execution Match: ‚úó
   Cosine Similarity: 0.8576
   Table Similarity: 0.1810
   Query Affinity Score: 0.5193

   SQL Gerada:
   SELECT i.title AS initiative_title, kr.metric, COUNT(kr.id) AS kr_count, (COUNT(kr.id) * 100.0 / SUM(COUNT(kr.id)) OVER (PARTITION BY i.id)) AS percentage FROM initiative AS i JOIN kr ON i.id = kr.okr_id GROUP BY i.id, i.title, kr.metric ORDER BY i.title, kr.metric;

   SQL Esperada (Gold):
   WITH kr_counts AS (SELECT i.id AS initiative_id, k.metric, COUNT(*) AS count FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, k.metric), initiative_totals AS (SELECT initiative_id, SUM(count) AS total FROM kr_counts GROUP BY initiative_id) SELECT kc.initiative_id, kc.metric, (kc.count::float / it.total) * 100 AS percent FROM kr_counts kc JOIN initiative_totals it ON kc.initiative_id = it.initiative_id ORDER BY kc.initiative_id, percent DESC;

71. Listar os KRs cujo progresso atual est√° abaixo da m√©dia dos KRs do mesmo tipo e dire√ß√£o.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3692ms
   Exact Match: ‚úó
   Component Match: 0.6875
   Execution Match: ‚úó
   Cosine Similarity: 0.8710
   Table Similarity: 0.3377
   Query Affinity Score: 0.6043

   SQL Gerada:
   WITH KRProgress AS ( SELECT id, metric, direction, progress, target, CASE WHEN direction = 'up' THEN progress::NUMERIC / target WHEN direction = 'down' THEN (target - progress)::NUMERIC / target ELSE NULL END AS calculated_progress FROM kr ), AverageProgress AS ( SELECT metric, direction, AVG(calculated_progress) AS avg_progress FROM KRProgress GROUP BY metric, direction ) SELECT kp.id, kp.metric, kp.direction, kp.progress, kp.target, kp.calculated_progress FROM KRProgress AS kp JOIN AverageProgress AS ap ON kp.metric = ap.metric AND kp.direction = ap.direction WHERE kp.calculated_progress < ap.avg_progress;

   SQL Esperada (Gold):
   WITH avg_progress AS (SELECT metric, direction, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY metric, direction) SELECT k.* FROM kr k JOIN avg_progress ap ON k.metric = ap.metric AND k.direction = ap.direction WHERE (k.progress / NULLIF(k.target, 0)) < ap.avg_progress;

72. Identificar iniciativas que mant√™m registros de atualiza√ß√£o em meses consecutivos, sem interrup√ß√µes.
   Status: ‚ùå ERROR
   Erro: Erro de execu√ß√£o no banco ap√≥s 3 tentativa(s): syntax error at or near "{"

   SQL Gerada (com erro):
   SELECT DISTINCT i.title FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id WHERE EXISTS ( SELECT 1 FROM initiative_update iu2 WHERE iu2.initiative_id = i.id AND TO_CHAR(iu2.year_month, 'YYYY-MM') = TO_CHAR(iu.year_month + INTERVAL '1 month', 'YYYY-MM') ) ORDER BY i.title;

   SQL Esperada (Gold):
   WITH updates_months AS (SELECT initiative_id, DATE_TRUNC('month', created_date) AS month FROM initiative_update GROUP BY initiative_id, month), consecutive AS (SELECT initiative_id, month, LAG(month) OVER (PARTITION BY initiative_id ORDER BY month) AS prev_month FROM updates_months), gaps AS (SELECT initiative_id, COUNT(*) FILTER (WHERE prev_month IS NOT NULL AND month - INTERVAL '1 month' <> prev_month) AS gap_count, COUNT(month) AS total_months FROM consecutive GROUP BY initiative_id) SELECT initiative_id FROM gaps WHERE gap_count = 0 AND total_months > 1;

73. Calcular a taxa m√©dia de crescimento mensal do progresso dos KRs, segmentada por tipo de m√©trica.
   Status: ‚ùå ERROR
   Erro: Erro de execu√ß√£o no banco ap√≥s 3 tentativa(s): syntax error at end of input

   SQL Gerada (com erro):
   SELECT kr.metric, AVG(CASE WHEN kr.direction = 'up' THEN (krh.progress - LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date)) / LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date) WHEN kr.direction = 'down' THEN (LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.date) - krh.progress) / LAG(krh.progress, 1, krh.progress) OVER (PARTITION BY kr.id ORDER BY krh.progress) ELSE 0 END) AS average_monthly_growth_rate FROM kr_history AS krh JOIN kr ON krh.kr_id = kr.id GROUP BY kr.metric;

   SQL Esperada (Gold):
   WITH monthly_kr_progress AS (SELECT kr_id, metric, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr_history GROUP BY kr_id, metric, month), monthly_growth AS (SELECT kr_id, metric, month, avg_progress, LAG(avg_progress) OVER (PARTITION BY kr_id ORDER BY month) AS prev_avg_progress FROM monthly_kr_progress), growth_rate AS (SELECT metric, AVG(CASE WHEN prev_avg_progress IS NOT NULL THEN (avg_progress - prev_avg_progress) / NULLIF(prev_avg_progress,0) ELSE NULL END) AS avg_monthly_growth_rate FROM monthly_growth GROUP BY metric) SELECT metric, avg_monthly_growth_rate FROM growth_rate;

74. Detectar iniciativas que apresentaram regress√£o m√©dia no progresso de seus KRs durante o √∫ltimo ciclo de atualiza√ß√£o.
   Status: ‚ùå ERROR
   Erro: Erro de execu√ß√£o no banco ap√≥s 3 tentativa(s): syntax error at or near "{"

   SQL Gerada (com erro):
   { "sql": "WITH latest_kr_updates AS (\n SELECT\n kr_id,\n MAX(date) AS latest_date\n FROM kr_history\n GROUP BY\n kr_id\n),\nprevious_kr_updates AS (\n SELECT\n kh.kr_id,\n MAX(kh.date) AS previous_date\n FROM kr_history AS kh\n JOIN latest_kr_updates AS lku\n ON kh.kr_id = lku.kr_id\n WHERE\n kh.date < lku.latest_date\n GROUP BY\n kh.kr_id\n),\nkr_progress_comparison AS (\n SELECT\n kh_latest.kr_id,\n k.okr_id,\n k.direction,\n kh_latest.progress AS latest_progress,\n kh_latest.target AS latest_target,\n kh_previous.progress AS previous_progress,\n kh_previous.target AS previous_target\n FROM kr_history AS kh_latest\n JOIN latest_kr_updates AS lku\n ON kh_latest.kr_id = lku.kr_id\n AND kh_latest.date = lku.latest_date\n JOIN previous_kr_updates AS pku\n ON kh_latest.kr_id = pku.kr_id\n JOIN kr_history AS kh_previous\n ON pku.kr_id = kh_previous.kr_id\n AND pku.previous_date = kh_previous.date\n JOIN kr AS k\n ON kh_latest.kr_id = k.id\n),\nkr_regression AS (\n SELECT\n okr_id,\n CASE\n WHEN direction = 'up' AND (latest_progress / latest_target) < (previous_progress / previous_target) THEN 1\n WHEN direction = 'down' AND (latest_progress / latest_target) > (previous_progress / previous_target) THEN 1\n ELSE 0\n END AS has_reg

   SQL Esperada (Gold):
   WITH last_two_updates AS (SELECT kh.kr_id, i.id AS initiative_id, kh.date, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn, kh.progress / NULLIF(k.target, 0) AS relative_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id), progress_diff AS (SELECT a.initiative_id, AVG(a.relative_progress - b.relative_progress) AS avg_progress_change FROM last_two_updates a JOIN last_two_updates b ON a.kr_id = b.kr_id AND a.rn = 1 AND b.rn = 2 GROUP BY a.initiative_id) SELECT initiative_id FROM progress_diff WHERE avg_progress_change < 0;

75. Apontar iniciativas cujos OKRs est√£o vencidos, mas cujo progresso m√©dio permanece abaixo de 80%.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 3030ms
   Exact Match: ‚úó
   Component Match: 0.8125
   Execution Match: ‚úó
   Cosine Similarity: 0.8430
   Table Similarity: 0.0000
   Query Affinity Score: 0.4215
   Tentativas de corre√ß√£o: 3
     Tentativa 1: ‚ùå division by zero
     Tentativa 2: ‚ùå division by zero
     Tentativa 3: ‚úÖ Corrigido

   SQL Gerada (original):
   SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE o.deadline < NOW() GROUP BY i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.8;

   SQL Corrigida (final):
   SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) AS average_kr_progress FROM initiative AS i JOIN okr AS o ON i.id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id WHERE o.deadline < NOW() AND k.target <> 0 AND k.progress <> 0 GROUP BY i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / k.target ELSE k.target::numeric / k.progress END) < 0.8;

   SQL Esperada (Gold):
   SELECT i.id AS initiative_id FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id WHERE o.deadline < NOW() GROUP BY i.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8;

76. Identificar KRs com dire√ß√£o ‚ÄúNEGATIVA‚Äù que mant√™m melhora cont√≠nua e atingem o target definido.
   Status: ‚úÖ SUCCESS
   Tempo de execu√ß√£o: 2825ms
   Exact Match: ‚úó
   Component Match: 0.3750
   Execution Match: ‚úó
   Cosine Similarity: 0.8040
   Table Similarity: 0.0000
   Query Affinity Score: 0.4020

   SQL Gerada:
   SELECT T1.title, T1.metric, T1.progress, T1.target, T1.direction FROM kr AS T1 JOIN kr_history AS T2 ON T1.id = T2.kr_id WHERE T1.direction = 'down' AND T1.progress <= T1.target GROUP BY T1.id, T1.title, T1.metric, T1.progress, T1.target, T1.direction HAVING COUNT(CASE WHEN T2.progress <= T2.target THEN 1 ELSE NULL END) = COUNT(T2.id);

   SQL Esperada (Gold):
   WITH kr_direction AS (SELECT k.id AS kr_id, k.target, k.direction FROM kr k WHERE k.direction = 'down'), history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kd.target, 0)) AS relative_progress, LAG(kh.progress / NULLIF(kd.target, 0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_progress FROM kr_history kh JOIN kr_direction kd ON kd.kr_id = kh.kr_id), fully_improving AS (SELECT kr_id FROM history GROUP BY kr_id HAVING COUNT(*) FILTER (WHERE prev_progress IS NOT NULL AND relative_progress >= prev_progress) = COUNT(*) - 1), achieved AS (SELECT kr_id FROM (SELECT kh.kr_id, (kh.progress / NULLIF(k.target,0)) AS relative_progress, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn FROM kr_history kh JOIN kr k ON k.id = kh.kr_id WHERE k.direction = 'down') last_value WHERE rn = 1 AND relative_progress <= 1) SELECT DISTINCT kr_id FROM fully_improving JOIN achieved USING(kr_id);

