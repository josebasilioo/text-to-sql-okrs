================================================================================
ðŸ“Š RELATÃ“RIO DE AVALIAÃ‡ÃƒO
================================================================================
Timestamp: 2025-11-28T02:34:05.331Z
Total de perguntas: 76
âœ… Sucessos: 73
âŒ Erros: 3

--- Retries ---
Total de perguntas com retries: 9
Total de tentativas de correÃ§Ã£o: 14
MÃ©dia de retries por pergunta (com retries): 1.56
MÃ¡ximo de retries em uma pergunta: 2
âœ… Sucessos apÃ³s retry: 6
âŒ Falhas apÃ³s retry: 3

--- MÃ©tricas ---

Exact Match (EM):
  Total avaliado: 73
  Matches: 1
  AcurÃ¡cia: 1.37%

Component Match (CM):
  Total avaliado: 73
  CM mÃ©dio: 0.7688

Execution Match (EX):
  Total avaliado: 73
  Matches: 6
  AcurÃ¡cia: 8.22%

Cosine Similarity (CS - Semantic Similarity):
  Total avaliado: 73
  CS mÃ©dio: 0.87

Table Similarity (TS):
  Total avaliado: 73
  TS mÃ©dio: 0.3725

Query Affinity Score (QAS):
  Total avaliado: 73
  QAS mÃ©dio: 0.6213

================================================================================

ðŸ“‹ Detalhes por pergunta:

1. Existe correlaÃ§Ã£o entre a prioridade da iniciativa e o progresso mÃ©dio de seus OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3563ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.9228
   Table Similarity: 0.5000
   Query Affinity Score: 0.7114

   SQL Gerada:
   SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Esperada (Gold):
   SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;

2. Iniciativas com maior prioridade tendem a ter maior progresso mÃ©dio nos OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3526ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.9141
   Table Similarity: 0.5000
   Query Affinity Score: 0.7070

   SQL Gerada:
   SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority DESC;

   SQL Esperada (Gold):
   SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;

3. Qual Ã© a relaÃ§Ã£o entre prioridade da iniciativa e o desempenho mÃ©dio dos seus OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3703ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.8989
   Table Similarity: 0.5000
   Query Affinity Score: 0.6995

   SQL Gerada:
   SELECT i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_okr_performance FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.priority ORDER BY i.priority;

   SQL Esperada (Gold):
   SELECT i.priority, AVG(kr.progress / NULLIF(kr.target, 0)) AS avg_progress FROM initiative i JOIN okr ON okr.initiative_id = i.id JOIN kr ON kr.okr_id = okr.id GROUP BY i.priority ORDER BY i.priority;

4. Iniciativas de qual categoria tÃªm maior taxa de conclusÃ£o de KRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3262ms
   Exact Match: âœ—
   Component Match: 0.9375
   Execution Match: âœ—
   Cosine Similarity: 0.9483
   Table Similarity: 0.2500
   Query Affinity Score: 0.5991

   SQL Gerada:
   SELECT i.category, COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS completed_krs, COUNT(k.id) AS total_krs, (CAST(COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) AS DECIMAL) * 100 / COUNT(k.id)) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;

   SQL Esperada (Gold):
   SELECT i.category, CAST(SUM(CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) AS FLOAT) / COUNT(k.id) AS completion_rate FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY completion_rate DESC;

5. Qual categoria de iniciativa apresenta menor frequÃªncia de updates?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2953ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.8559
   Table Similarity: 0.1250
   Query Affinity Score: 0.4904

   SQL Gerada:
   SELECT i.category, COUNT(iu.id) AS update_frequency FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY update_frequency ASC LIMIT 1;

   SQL Esperada (Gold):
   SELECT i.category, CAST(COUNT(iu.id) AS FLOAT) / COUNT(DISTINCT i.id) AS avg_updates_per_initiative FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.category ORDER BY avg_updates_per_initiative ASC;

6. Colaboradores com mais KRs favoritos tÃªm desempenho melhor nos OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2925ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.8894
   Table Similarity: 0.2533
   Query Affinity Score: 0.5714

   SQL Gerada:
   SELECT c.name AS collaborator_name, COUNT(k.id) AS favorited_krs_count, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE NULL END) AS avg_okr_performance FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name ORDER BY favorited_krs_count DESC;

   SQL Esperada (Gold):
   SELECT c.name, COUNT(k.id) AS total_bookmarked_krs, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress_of_bookmarked_krs FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id GROUP BY c.id, c.name ORDER BY total_bookmarked_krs DESC;

7. HÃ¡ diferenÃ§a de progresso mÃ©dio entre KRs do tipo â€œYES_NOâ€ e â€œNUMERICâ€?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2736ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.9062
   Table Similarity: 0.5000
   Query Affinity Score: 0.7031

   SQL Gerada:
   SELECT metric, AVG(CASE WHEN direction = 'up' THEN progress / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress) / NULLIF(target, 0) ELSE NULL END) AS average_progress FROM kr WHERE metric IN ('YES_NO', 'NUMERIC') GROUP BY metric;

   SQL Esperada (Gold):
   SELECT k.metric, AVG(k.progress / NULLIF(k.target, 0)) AS average_progress FROM kr k WHERE k.metric IN ('YES_NO', 'NUMERIC') GROUP BY k.metric;

8. Quais iniciativas concentram mais KRs com mÃ©trica percentual?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2919ms
   Exact Match: âœ—
   Component Match: 0.9375
   Execution Match: âœ—
   Cosine Similarity: 0.9815
   Table Similarity: 0.2674
   Query Affinity Score: 0.6244

   SQL Gerada:
   SELECT i.title, COUNT(k.id) AS total_percentual_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.title ORDER BY total_percentual_krs DESC;

   SQL Esperada (Gold):
   SELECT i.title, COUNT(k.id) AS total_percentage_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE k.metric = 'PERC' GROUP BY i.id, i.title ORDER BY total_percentage_krs DESC;

9. Qual a mÃ©dia de progresso dos OKRs de iniciativas de alta prioridade?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3163ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.9171
   Table Similarity: 0.0000
   Query Affinity Score: 0.4585

   SQL Gerada:
   SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress FROM okr o JOIN kr k ON o.id = k.okr_id JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = 1;

   SQL Esperada (Gold):
   SELECT AVG(k.progress / NULLIF(k.target, 0)) AS average_okr_progress_high_priority FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1;

10. Qual o impacto dos updates de iniciativa no progresso dos KRs associados?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 4058ms
   Exact Match: âœ—
   Component Match: 0.5000
   Execution Match: âœ—
   Cosine Similarity: 0.7464
   Table Similarity: 0.0000
   Query Affinity Score: 0.3732
   Tentativas de correÃ§Ã£o: 3
     Tentativa 1: âŒ syntax error at end of input
     Tentativa 2: âŒ syntax error at end of input
     Tentativa 3: âœ… Corrigido

   SQL Gerada (original):
   SELECT iu.initiative_id, iu.year_month AS update_month, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) -- Ajuste para 'down' ELSE NULL END) AS avg_kr_progress_at_update_time FROM initiative_update AS iu JOIN kr AS k ON iu.initiative_id = k.okr_id GROUP BY iu.initiative_id, iu.year_month ORDER BY iu.initiative_id, iu.year_month;

   SQL Corrigida (final):
   SELECT iu.initiative_id, iu.year_month AS update_month, AVG( CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE NULL END ) AS avg_kr_progress_at_update_time FROM initiative_update AS iu JOIN okr AS o ON iu.initiative_id = o.initiative_id JOIN kr AS k ON o.id = k.okr_id GROUP BY iu.initiative_id, iu.year_month ORDER BY iu.initiative_id, iu.year_month;

   SQL Esperada (Gold):
   WITH normalized_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(k.target,0)) AS rel_progress, LAG(kh.progress / NULLIF(k.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS rel_before FROM kr_history kh JOIN kr k ON k.id = kh.kr_id), updates AS (SELECT initiative_id, created_date FROM initiative_update), link AS (SELECT nh.kr_id, nh.rel_progress, nh.rel_before, nh.date AS progress_date, (SELECT iu.created_date FROM initiative_update iu JOIN kr k ON iu.initiative_id = k.okr_id JOIN okr o ON k.okr_id = o.id WHERE iu.initiative_id = o.initiative_id AND iu.created_date < nh.date ORDER BY iu.created_date DESC LIMIT 1) AS last_update FROM normalized_history nh JOIN kr k ON nh.kr_id = k.id JOIN okr o ON k.okr_id = o.id) SELECT AVG(rel_progress - rel_before) AS avg_progress_change_after_update FROM link WHERE rel_before IS NOT NULL AND last_update IS NOT NULL;

11. HÃ¡ aumento no ritmo de updates prÃ³ximo aos deadlines dos OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3699ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.9121
   Table Similarity: 0.6231
   Query Affinity Score: 0.7676

   SQL Gerada:
   SELECT o.id AS okr_id, o.deadline AS okr_deadline, COUNT(iu.id) AS total_updates, SUM(CASE WHEN iu.created_date >= (o.deadline - INTERVAL '7 days') THEN 1 ELSE 0 END) AS updates_near_deadline FROM okr AS o LEFT JOIN initiative AS i ON o.initiative_id = i.id LEFT JOIN initiative_update AS iu ON i.id = iu.initiative_id GROUP BY o.id, o.deadline HAVING COUNT(iu.id) > 0 ORDER BY o.deadline DESC;

   SQL Esperada (Gold):
   SELECT o.id AS okr_id, o.deadline, SUM(CASE WHEN iu.created_date BETWEEN o.deadline - INTERVAL '30 days' AND o.deadline THEN 1 ELSE 0 END) AS updates_last_30_days, SUM(CASE WHEN iu.created_date < o.deadline - INTERVAL '30 days' THEN 1 ELSE 0 END) AS updates_before_30_days FROM okr o LEFT JOIN initiative_update iu ON iu.initiative_id = o.initiative_id AND iu.created_date <= o.deadline GROUP BY o.id, o.deadline ORDER BY o.deadline;

12. Qual Ã© o alinhamento entre as datas de fim de iniciativa e deadlines de OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3025ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.6612
   Table Similarity: 0.0000
   Query Affinity Score: 0.3306

   SQL Gerada:
   SELECT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date IS NOT NULL AND o.deadline IS NOT NULL ORDER BY i.end_date, o.deadline;

   SQL Esperada (Gold):
   SELECT CASE WHEN o.deadline < i.end_date THEN 'OKR ANTES da Iniciativa' WHEN o.deadline = i.end_date THEN 'OKR e Iniciativa na MESMA DATA' WHEN o.deadline > i.end_date THEN 'OKR DEPOIS da Iniciativa' ELSE 'Sem data de fim para Iniciativa' END AS alinhamento, COUNT(o.id) AS total_okrs FROM okr o JOIN initiative i ON o.initiative_id = i.id GROUP BY alinhamento;

13. Quantos OKRs estÃ£o diretamente vinculados a iniciativas prioritÃ¡rias (por categoria) e quantos ainda nÃ£o possuem ligaÃ§Ã£o clara com uma iniciativa?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3250ms
   Exact Match: âœ—
   Component Match: 0.5625
   Execution Match: âœ—
   Cosine Similarity: 0.8675
   Table Similarity: 0.1528
   Query Affinity Score: 0.5102
   Tentativas de correÃ§Ã£o: 2
     Tentativa 1: âŒ column kr.initiative_id does not exist
     Tentativa 2: âœ… Corrigido

   SQL Gerada (original):
   SELECT i.category AS initiative_category, COUNT(DISTINCT okr.id) AS num_okrs_linked_to_priority_initiative FROM okr JOIN kr ON okr.id = kr.okr_id JOIN initiative i ON kr.initiative_id = i.id WHERE i.priority = 1 GROUP BY i.category UNION ALL SELECT 'Sem Iniciativa Vinculada' AS initiative_category, COUNT(DISTINCT okr.id) AS num_okrs_not_linked_to_initiative FROM okr LEFT JOIN kr ON okr.id = kr.okr_id WHERE kr.initiative_id IS NULL;

   SQL Corrigida (final):
   SELECT i.category AS initiative_category, COUNT(DISTINCT o.id) AS num_okrs_linked_to_priority_initiative FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.priority = 1 GROUP BY i.category UNION ALL SELECT 'Sem Iniciativa Vinculada' AS initiative_category, COUNT(DISTINCT o.id) AS num_okrs_not_linked_to_initiative FROM okr o WHERE o.initiative_id IS NULL;

   SQL Esperada (Gold):
   SELECT COALESCE(i.category, 'SEM INICIATIVA') AS category, COALESCE(i.priority, -1) AS priority, COUNT(o.id) AS okrs_count FROM okr o LEFT JOIN initiative i ON o.initiative_id = i.id GROUP BY category, priority ORDER BY category, priority;

14. Quantas atualizaÃ§Ãµes de iniciativas foram registradas neste trimestre e quais sÃ£o os principais temas dos â€œhighlightsâ€ e â€œbrutal factsâ€?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3238ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.9027
   Table Similarity: 0.0000
   Query Affinity Score: 0.4513

   SQL Gerada:
   SELECT COUNT(iu.id) AS total_updates, SUBSTRING(iu.highlights FROM 1 FOR 50) AS highlight_snippet, SUBSTRING(iu.brutal_facts FROM 1 FOR 50) AS brutal_facts_snippet FROM initiative_update iu WHERE iu.created_date >= DATE_TRUNC('quarter', CURRENT_DATE) AND iu.created_date < DATE_TRUNC('quarter', CURRENT_DATE) + INTERVAL '3 months' GROUP BY highlight_snippet, brutal_facts_snippet ORDER BY total_updates DESC;

   SQL Esperada (Gold):
   SELECT COUNT(iu.id) AS total_updates_trimestre, STRING_AGG(iu.highlights, ' | ') AS todos_highlights, STRING_AGG(iu.brutal_facts, ' | ') AS todos_brutal_facts FROM initiative_update iu WHERE iu.created_date >= date_trunc('quarter', CURRENT_DATE) AND iu.created_date < date_trunc('quarter', CURRENT_DATE) + interval '3 month';

15. Apresentar os KRs com maior desvio padrÃ£o de progresso ao longo do histÃ³rico, indicando instabilidade.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2755ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.8834
   Table Similarity: 0.6504
   Query Affinity Score: 0.7669

   SQL Gerada:
   SELECT k.title, STDDEV(kh.progress / NULLIF(kh.target, 0)) AS progress_stddev FROM kr k JOIN kr_history kh ON k.id = kh.kr_id GROUP BY k.id, k.title ORDER BY progress_stddev DESC;

   SQL Esperada (Gold):
   SELECT k.title, o.description AS okr_description, STDDEV(kh.progress / NULLIF(kh.target, 0)) AS desvio_padrao_progresso FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id GROUP BY kh.kr_id, k.title, o.description HAVING COUNT(kh.id) > 1 ORDER BY desvio_padrao_progresso DESC;

16. Comparar o progresso mÃ©dio dos KRs com o progresso mÃ©dio das iniciativas Ã s quais estÃ£o vinculados, destacando as maiores variaÃ§Ãµes.
   Status: âŒ ERROR
   Erro: Erro de execuÃ§Ã£o no banco apÃ³s 3 tentativa(s): syntax error at or near "{"

   SQL Gerada (com erro):
   { "sql": "WITH kr_progress_calc AS (SELECT kr.okr_id, (kr.progress / NULLIF(kr.target, 0)) AS kr_progress FROM kr WHERE kr.direction = 'up' UNION ALL SELECT kr.okr_id, (kr.target / NULLIF(kr.progress, 0)) AS kr_progress FROM kr WHERE kr.direction = 'down'), initiative_progress_calc AS (SELECT i.id AS initiative_id, AVG(kpc.kr_progress) AS avg_kr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr_progress_calc kpc ON o.id = kpc.okr_id GROUP BY i.id) SELECT i.title AS initiative_title, ipc.avg_kr_progress, (SELECT AVG(k.progress / NULLIF(k.target, 0)) FROM kr k JOIN okr o2 ON k.okr_id = o2.id WHERE o2.initiative_id = i.id AND k.direction = 'up' UNION ALL SELECT AVG(k.target / NULLIF(k.progress, 0)) FROM kr k JOIN okr o2 ON k.okr_id = o2.id WHERE o2.initiative_id = i.id AND k.direction = 'down') AS initiative_kr_avg_progress, ABS(ipc.avg_kr_progress - (SELECT AVG(k.progress / NULLIF(k.target, 0)) FROM kr k JOIN okr o2 ON k.okr_id = o2.id WHERE o2.initiative_id = i.id AND k.direction = 'up' UNION ALL SELECT AVG(k.target / NULLIF(k.progress, 0)) FROM kr k JOIN okr o2 ON k.okr_id = o2.id WHERE o2.initiative_id = i.id AND k.direction = 'down')) AS progress_variation FROM initiative i JOIN initiative_progress_calc ipc ON i.id = ipc.initiative_id ORDER BY progress_variation DESC;", "complementaryText": "Esta query compara o progresso mÃ©dio dos Key Results (KRs) com o progresso mÃ©dio das iniciativas Ã s quais estÃ£o vinculados, destacando

   SQL Esperada (Gold):
   WITH InitiativeProgress AS (SELECT i.id AS initiative_id, AVG(k.progress / NULLIF(k.target, 0)) AS avg_initiative_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id), CalculatedVariance AS (SELECT k.title AS kr_title, (k.progress / NULLIF(k.target, 0)) AS kr_current_progress, ip.avg_initiative_progress, (k.progress / NULLIF(k.target, 0)) - ip.avg_initiative_progress AS progress_variance FROM kr k JOIN okr o ON k.okr_id = o.id JOIN InitiativeProgress ip ON o.initiative_id = ip.initiative_id) SELECT kr_title, kr_current_progress, avg_initiative_progress, progress_variance FROM CalculatedVariance ORDER BY ABS(progress_variance) DESC;

17. Construir o ranking das categorias de iniciativa com base no progresso mÃ©dio ponderado pelo nÃºmero de KRs associados.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3313ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.8535
   Table Similarity: 0.3333
   Query Affinity Score: 0.5934

   SQL Gerada:
   WITH CategoryProgress AS (SELECT i.category, SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS total_progress, COUNT(k.id) AS kr_count FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category) SELECT category, (total_progress / NULLIF(kr_count, 0)) AS weighted_average_progress, RANK() OVER (ORDER BY (total_progress / NULLIF(kr_count, 0)) DESC) AS ranking FROM CategoryProgress ORDER BY ranking;

   SQL Esperada (Gold):
   SELECT i.category, AVG(k.progress / NULLIF(k.target, 0)) AS weighted_average_progress, COUNT(k.id) AS total_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category ORDER BY weighted_average_progress DESC;

18. Avaliar a correlaÃ§Ã£o entre o nÃºmero de updates registrados em cada iniciativa e o progresso mÃ©dio de seus KRs.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3447ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.8049
   Table Similarity: 0.0000
   Query Affinity Score: 0.4025

   SQL Gerada:
   WITH InitiativeUpdates AS (SELECT initiative_id, COUNT(*) AS num_updates FROM initiative_update GROUP BY initiative_id), KRProgress AS (SELECT k.okr_id, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_kr_progress FROM kr k GROUP BY k.okr_id) SELECT iu.initiative_id, iu.num_updates, kp.avg_kr_progress FROM InitiativeUpdates iu JOIN okr o ON iu.initiative_id = o.initiative_id JOIN KRProgress kp ON o.id = kp.okr_id ORDER BY iu.initiative_id;

   SQL Esperada (Gold):
   WITH InitiativeMetrics AS (SELECT i.id AS initiative_id, COUNT(iu.id) AS total_updates, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS average_kr_progress FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id) SELECT CORR(im.total_updates, im.average_kr_progress) AS correlation_updates_vs_progress FROM InitiativeMetrics im;

19. Detectar iniciativas que apresentaram regressÃ£o mÃ©dia no progresso de KRs durante o Ãºltimo ciclo.
   Status: âŒ ERROR
   Erro: Erro de execuÃ§Ã£o no banco apÃ³s 3 tentativa(s): syntax error at or near "{"

   SQL Gerada (com erro):
   { "sql": "WITH kr_progress_history AS (SELECT kh.kr_id, kh.date, kh.progress, kh.target, k.direction, k.okr_id, (CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target - kh.progress)::numeric / NULLIF(kh.target, 0) ELSE 0 END) AS calculated_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE kh.date >= (SELECT MAX(date) - INTERVAL '1 month' FROM kr_history)), kr_latest_progress AS (SELECT kr_id, MAX(date) AS latest_date FROM kr_progress_history GROUP BY kr_id), kr_previous_progress AS (SELECT kr_id, MAX(date) AS previous_date FROM kr_progress_history WHERE date < (SELECT MAX(date) - INTERVAL '1 month' FROM kr_history) GROUP BY kr_id), latest_progress_values AS (SELECT kph.kr_id, kph.calculated_progress AS latest_progress FROM kr_progress_history kph JOIN kr_latest_progress klp ON kph.kr_id = klp.kr_id AND kph.date = klp.latest_date), previous_progress_values AS (SELECT kph.kr_id, kph.calculated_progress AS previous_progress FROM kr_progress_history kph JOIN kr_previous_progress kpp ON kph.kr_id = kpp.kr_id AND kph.date = kpp.previous_date) SELECT i.title AS initiative_title, AVG(lpv.latest_progress) AS avg_latest_progress, AVG(ppv.previous_progress) AS avg_previous_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN latest_progress_values lpv ON k.id = lpv.kr_id JOIN previous_progress_values ppv ON k.id = ppv.kr_id WHERE lpv.latest_progress < ppv.previous_progress GROUP BY

   SQL Esperada (Gold):
   WITH hist AS (SELECT kh.kr_id, (kh.progress / NULLIF(kh.target,0)) AS rel, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev, o.initiative_id FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id), diffs AS (SELECT initiative_id, rel - prev AS diff FROM hist WHERE prev IS NOT NULL) SELECT i.title, AVG(diff) AS avg_regression_change FROM diffs d JOIN initiative i ON d.initiative_id = i.id GROUP BY i.id, i.title HAVING AVG(diff) < 0 ORDER BY avg_regression_change ASC;

20. Qual a distribuiÃ§Ã£o de iniciativas por categoria?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2426ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.7186
   Table Similarity: 0.6667
   Query Affinity Score: 0.6926

   SQL Gerada:
   SELECT category, COUNT(*) AS initiative_count FROM initiative GROUP BY category ORDER BY category;

   SQL Esperada (Gold):
   SELECT category, COUNT(id) AS total_initiatives, CAST(COUNT(id) AS FLOAT) * 100 / (SELECT COUNT(*) FROM initiative) AS percentage FROM initiative GROUP BY category ORDER BY total_initiatives DESC;

21. Quais iniciativas tÃªm mais OKRs associados?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2841ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.9605
   Table Similarity: 0.1739
   Query Affinity Score: 0.5672

   SQL Gerada:
   SELECT i.title AS initiative_title, COUNT(o.id) AS okr_count FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.title ORDER BY okr_count DESC;

   SQL Esperada (Gold):
   SELECT i.title, COUNT(o.id) AS total_okrs FROM initiative i LEFT JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title ORDER BY total_okrs DESC;

22. Quantas iniciativas estÃ£o em andamento neste trimestre?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3005ms
   Exact Match: âœ—
   Component Match: 1.0000
   Execution Match: âœ“
   Cosine Similarity: 0.7219
   Table Similarity: 1.0000
   Query Affinity Score: 0.8609

   SQL Gerada:
   SELECT COUNT(id) FROM initiative WHERE start_date <= NOW() AND end_date >= NOW();

   SQL Esperada (Gold):
   SELECT COUNT(id) FROM initiative WHERE start_date <= date_trunc('quarter', CURRENT_DATE) + INTERVAL '3 month' - INTERVAL '1 second' AND (end_date IS NULL OR end_date >= date_trunc('quarter', CURRENT_DATE));

23. Quais iniciativas estÃ£o sem updates hÃ¡ mais de 30 dias?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2593ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.8947
   Table Similarity: 0.5000
   Query Affinity Score: 0.6973

   SQL Gerada:
   SELECT i.title AS initiative_title, i.description AS initiative_description FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title, i.description HAVING MAX(iu.created_date) < NOW() - INTERVAL '30 days' OR MAX(iu.created_date) IS NULL;

   SQL Esperada (Gold):
   SELECT i.title, MAX(iu.created_date) AS last_update FROM initiative i LEFT JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title HAVING MAX(iu.created_date) IS NULL OR MAX(iu.created_date) < NOW() - INTERVAL '30' DAY ORDER BY last_update ASC;

24. Quais iniciativas tÃªm prioridade mÃ¡xima, mas baixo progresso de OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3457ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.8766
   Table Similarity: 0.8333
   Query Affinity Score: 0.8550

   SQL Gerada:
   SELECT i.title AS initiative_title, i.priority, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target - (SELECT MIN(progress) FROM kr WHERE okr_id = o.id AND direction = 'down'), 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target - (SELECT MIN(progress) FROM kr WHERE okr_id = o.id AND direction = 'down'), 0) ELSE 0 END) < 0.5 ORDER BY avg_okr_progress ASC;

   SQL Esperada (Gold):
   SELECT i.title, i.priority, AVG(k.progress / NULLIF(k.target, 0)) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE i.priority = 1 GROUP BY i.id, i.title, i.priority HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.5 ORDER BY avg_okr_progress ASC;

25. Quantas iniciativas estÃ£o planejadas para comeÃ§ar no prÃ³ximo mÃªs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2616ms
   Exact Match: âœ—
   Component Match: 1.0000
   Execution Match: âœ“
   Cosine Similarity: 0.9812
   Table Similarity: 1.0000
   Query Affinity Score: 0.9906

   SQL Gerada:
   SELECT COUNT(id) FROM initiative WHERE start_date >= date_trunc('month', NOW() + INTERVAL '1 month') AND start_date < date_trunc('month', NOW() + INTERVAL '2 months');

   SQL Esperada (Gold):
   SELECT COUNT(id) FROM initiative WHERE start_date >= date_trunc('month', CURRENT_DATE) + INTERVAL '1 month' AND start_date < date_trunc('month', CURRENT_DATE) + INTERVAL '2 month';

26. Quais iniciativas tÃªm fim previsto antes do tÃ©rmino de seus OKRs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3249ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ“
   Cosine Similarity: 0.8751
   Table Similarity: 1.0000
   Query Affinity Score: 0.9375

   SQL Gerada:
   SELECT DISTINCT i.title AS initiative_title, i.end_date AS initiative_end_date, o.deadline AS okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date < o.deadline;

   SQL Esperada (Gold):
   SELECT i.title, i.end_date, MAX(o.deadline) AS latest_okr_deadline FROM initiative i JOIN okr o ON i.id = o.initiative_id WHERE i.end_date IS NOT NULL GROUP BY i.id, i.title, i.end_date HAVING i.end_date < MAX(o.deadline);

27. Quais iniciativas tÃªm mais de trÃªs pessoas no time?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2600ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.9279
   Table Similarity: 0.0000
   Query Affinity Score: 0.4640

   SQL Gerada:
   SELECT i.title, COUNT(im.managers_id) AS num_managers FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.title HAVING COUNT(im.managers_id) > 3;

   SQL Esperada (Gold):
   SELECT i.id, i.title, COUNT(im.managers_id) AS team_size FROM initiative i JOIN initiative_managers im ON i.id = im.initiative_id GROUP BY i.id HAVING COUNT(im.managers_id) > 3

28. Qual Ã© a mÃ©dia de duraÃ§Ã£o (em dias) das iniciativas concluÃ­das?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3085ms
   Exact Match: âœ—
   Component Match: 0.9375
   Execution Match: âœ“
   Cosine Similarity: 0.9676
   Table Similarity: 1.0000
   Query Affinity Score: 0.9838

   SQL Gerada:
   SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / (60 * 60 * 24)) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL AND end_date >= start_date;

   SQL Esperada (Gold):
   SELECT AVG(EXTRACT(EPOCH FROM (end_date - start_date)) / 86400) AS average_duration_days FROM initiative WHERE end_date IS NOT NULL AND start_date IS NOT NULL;

29. Qual percentual de iniciativas por categoria estÃ¡ concluÃ­do?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3022ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.8934
   Table Similarity: 0.5000
   Query Affinity Score: 0.6967

   SQL Gerada:
   SELECT i.category, CAST(COUNT(CASE WHEN k.progress >= k.target THEN 1 ELSE NULL END) AS DECIMAL) * 100 / COUNT(k.id) AS percentage_completed FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.category;

   SQL Esperada (Gold):
   WITH InitiativeKRStatus AS (SELECT i.id AS initiative_id, i.category, CASE WHEN (k.direction = 'up'   AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END AS kr_is_concluded FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT category, CAST(SUM(kr_is_concluded) AS FLOAT) * 100 / COUNT(*) AS percent_krs_concluded FROM InitiativeKRStatus GROUP BY category ORDER BY percent_krs_concluded DESC;

30. Quais iniciativas estÃ£o com maior prioridade, mas apresentam baixo progresso ou atualizaÃ§Ãµes atrasadas?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3170ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.7343
   Table Similarity: 0.0625
   Query Affinity Score: 0.3984

   SQL Gerada:
   SELECT i.title AS initiative_title, i.priority, i.end_date, iu.year_month AS last_update_month FROM initiative i LEFT JOIN ( SELECT initiative_id, MAX(year_month) AS year_month FROM initiative_update GROUP BY initiative_id ) iu ON i.id = iu.initiative_id WHERE i.priority = (SELECT MAX(priority) FROM initiative) AND (iu.year_month IS NULL OR iu.year_month < TO_CHAR(NOW() - INTERVAL '1 month', 'YYYY-MM')) ORDER BY i.end_date DESC;

   SQL Esperada (Gold):
   WITH InitiativePerformance AS (SELECT i.id AS initiative_id, i.title, i.priority, (SELECT AVG(k.progress / NULLIF(k.target,0)) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.initiative_id = i.id) AS avg_okr_progress, (SELECT MAX(created_date) FROM initiative_update iu WHERE iu.initiative_id = i.id) AS last_update_date FROM initiative i) SELECT title, priority, avg_okr_progress, last_update_date FROM InitiativePerformance WHERE priority = 1 AND (avg_okr_progress < 0.5 OR last_update_date < NOW() - INTERVAL '30 days' OR last_update_date IS NULL) ORDER BY avg_okr_progress ASC NULLS FIRST, last_update_date ASC NULLS FIRST;

31. Quais KRs estÃ£o com direÃ§Ã£o â€œNEGATIVAâ€ (indicando desempenho decrescente) e estÃ£o abaixo de 50% do target?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2551ms
   Exact Match: âœ—
   Component Match: 0.9375
   Execution Match: âœ—
   Cosine Similarity: 0.9460
   Table Similarity: 0.3077
   Query Affinity Score: 0.6269

   SQL Gerada:
   SELECT * FROM kr WHERE direction = 'down' AND (progress / NULLIF(target, 0)) < 0.5;

   SQL Esperada (Gold):
   SELECT title, progress, target, direction FROM kr WHERE direction = 'down' AND (progress / NULLIF(target,0)) < 0.5;

32. Quais iniciativas apresentaram maior variaÃ§Ã£o positiva de progresso nos Ãºltimos ciclos de atualizaÃ§Ã£o?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3377ms
   Exact Match: âœ—
   Component Match: 0.5000
   Execution Match: âœ—
   Cosine Similarity: 0.7948
   Table Similarity: 0.1449
   Query Affinity Score: 0.4698

   SQL Gerada:
   WITH initiative_progress AS (SELECT iu.initiative_id, iu.year_month, (SUM(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) / COUNT(k.id)) AS avg_kr_progress FROM initiative_update iu JOIN kr k ON iu.initiative_id = k.okr_id GROUP BY iu.initiative_id, iu.year_month), ranked_progress AS (SELECT initiative_id, year_month, avg_kr_progress, LAG(avg_kr_progress, 1, 0) OVER (PARTITION BY initiative_id ORDER BY year_month) AS previous_month_progress FROM initiative_progress) SELECT i.title, rp.year_month, (rp.avg_kr_progress - rp.previous_month_progress) AS progress_variation FROM ranked_progress rp JOIN initiative i ON rp.initiative_id = i.id WHERE rp.avg_kr_progress > rp.previous_month_progress ORDER BY progress_variation DESC;

   SQL Esperada (Gold):
   WITH NormHist AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh), Changes AS (SELECT nh.kr_id, nh.date, nh.norm_prog, nh.norm_prog - LAG(nh.norm_prog) OVER (PARTITION BY nh.kr_id ORDER BY nh.date) AS delta FROM NormHist nh), PosChanges AS (SELECT o.initiative_id, CASE WHEN k.direction = 'up'   AND delta > 0 THEN delta WHEN k.direction = 'down' AND delta < 0 THEN -delta END AS norm_delta FROM Changes c JOIN kr k ON c.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE delta IS NOT NULL AND c.date >= NOW() - INTERVAL '6 month' AND ((k.direction='up' AND delta > 0) OR (k.direction='down' AND delta < 0))) SELECT i.title, AVG(pc.norm_delta) AS avg_positive_change FROM initiative i JOIN PosChanges pc ON i.id = pc.initiative_id GROUP BY i.id, i.title ORDER BY avg_positive_change DESC;

33. Quais colaboradores foram responsÃ¡veis pelos KRs com melhor taxa de atingimento?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3157ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.8253
   Table Similarity: 0.2627
   Query Affinity Score: 0.5440

   SQL Gerada:
   SELECT c.name AS collaborator_name, SUM(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS total_achievement_rate FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.name ORDER BY total_achievement_rate DESC;

   SQL Esperada (Gold):
   SELECT c.name, AVG(k.progress / k.target) AS avg_achievement_rate FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name HAVING COUNT(DISTINCT k.id) > 1 ORDER BY avg_achievement_rate DESC;

34. Quais colaboradores tÃªm progresso mÃ©dio de KRs acima da mÃ©dia geral dos colaboradores?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3505ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.8258
   Table Similarity: 0.2708
   Query Affinity Score: 0.5483

   SQL Gerada:
   WITH CollaboratorAvgProgress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) AS avg_kr_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name), OverallAvgProgress AS (SELECT AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress::numeric / NULLIF(k.target, 0)) ELSE 0 END) AS overall_avg FROM kr_history kh JOIN kr k ON kh.kr_id = k.id) SELECT cap.collaborator_name, cap.avg_kr_progress FROM CollaboratorAvgProgress cap, OverallAvgProgress oap WHERE cap.avg_kr_progress > oap.overall_avg ORDER BY cap.avg_kr_progress DESC;

   SQL Esperada (Gold):
   WITH CollaboratorAvg AS (SELECT kh.collaborator_id, AVG(kh.progress / NULLIF(kh.target,0)) AS collaborator_progress FROM kr_history kh GROUP BY kh.collaborator_id), GlobalAvg AS (SELECT AVG(progress / NULLIF(target,0)) AS global_progress FROM kr_history) SELECT c.name, ca.collaborator_progress FROM collaborator c JOIN CollaboratorAvg ca ON c.id = ca.collaborator_id CROSS JOIN GlobalAvg ga WHERE ca.collaborator_progress > ga.global_progress ORDER BY ca.collaborator_progress DESC;

35. Quais colaboradores possuem mais KRs â€œbookmarkedâ€ do que a mÃ©dia geral de bookmarks por colaborador?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3141ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.8963
   Table Similarity: 0.3824
   Query Affinity Score: 0.6393

   SQL Gerada:
   WITH CollaboratorBookmarkCounts AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, COUNT(k.id) AS bookmark_count FROM collaborator c LEFT JOIN kr k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.id, c.name), AverageBookmarks AS (SELECT AVG(bookmark_count) AS avg_bookmarks_per_collaborator FROM CollaboratorBookmarkCounts) SELECT cbc.collaborator_name, cbc.bookmark_count FROM CollaboratorBookmarkCounts cbc, AverageBookmarks ab WHERE cbc.bookmark_count > ab.avg_bookmarks_per_collaborator ORDER BY cbc.bookmark_count DESC;

   SQL Esperada (Gold):
   WITH BookmarkCount AS ( SELECT bookmarked_by_id, COUNT(id) AS total_bookmarks FROM kr WHERE bookmarked_by_id IS NOT NULL GROUP BY bookmarked_by_id ), AvgBookmarks AS ( SELECT AVG(total_bookmarks) AS global_avg FROM BookmarkCount ) SELECT c.name, bc.total_bookmarks FROM collaborator c JOIN BookmarkCount bc ON c.id = bc.bookmarked_by_id CROSS JOIN AvgBookmarks ab WHERE bc.total_bookmarks > ab.global_avg ORDER BY bc.total_bookmarks DESC;

36. Gerar o ranking de colaboradores com maior mÃ©dia de progresso em KRs dentro de cada categoria de iniciativa.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3331ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.9435
   Table Similarity: 0.7765
   Query Affinity Score: 0.8600

   SQL Gerada:
   SELECT i.category, c.name, AVG(CASE WHEN k.direction = 'up' THEN kh.progress / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target - kh.progress) / NULLIF(kh.target, 0) ELSE NULL END) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(CASE WHEN k.direction = 'up' THEN kh.progress / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target - kh.progress) / NULLIF(kh.target, 0) ELSE NULL END) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;

   SQL Esperada (Gold):
   SELECT i.category, c.name, AVG(kh.progress / NULLIF(kh.target,0)) AS avg_progress_in_category, RANK() OVER (PARTITION BY i.category ORDER BY AVG(kh.progress / NULLIF(kh.target,0)) DESC) AS rank_in_category FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id GROUP BY i.category, c.id, c.name ORDER BY i.category, rank_in_category;

37. Selecionar colaboradores que contribuÃ­ram para KRs com progresso superior ao percentil 90 global.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3440ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.8603
   Table Similarity: 0.8214
   Query Affinity Score: 0.8409

   SQL Gerada:
   WITH kr_progress_data AS (SELECT id, CASE WHEN direction = 'up' THEN progress / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress) / NULLIF(target, 0) ELSE 0 END AS calculated_progress FROM kr), percentile_90_progress AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY calculated_progress) AS p90_value FROM kr_progress_data) SELECT DISTINCT c.name FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr_progress_data kpd ON kh.kr_id = kpd.id, percentile_90_progress p90 WHERE kpd.calculated_progress > p90.p90_value;

   SQL Esperada (Gold):
   WITH GlobalPercentile AS (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY (progress / NULLIF(target,0))) AS p90_progress FROM kr_history) SELECT DISTINCT c.name FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id CROSS JOIN GlobalPercentile gp WHERE (kh.progress / NULLIF(kh.target,0)) > gp.p90_progress;

38. Como evoluiu o progresso mÃ©dio dos KRs nos Ãºltimos 6 meses?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2876ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.9151
   Table Similarity: 0.3750
   Query Affinity Score: 0.6450

   SQL Gerada:
   SELECT DATE_TRUNC('month', date) AS month, AVG(CASE WHEN direction = 'up' THEN progress::numeric / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress)::numeric / NULLIF(target, 0) ELSE 0 END) AS average_progress FROM kr_history WHERE date >= NOW() - INTERVAL '6 months' GROUP BY month ORDER BY month;

   SQL Esperada (Gold):
   SELECT DATE_TRUNC('month', date) AS month_start, AVG(progress / NULLIF(target,0)) AS avg_monthly_progress FROM kr_history WHERE date >= DATE_TRUNC('month', NOW() - INTERVAL '6 month') AND date <= NOW() GROUP BY month_start ORDER BY month_start;

39. Qual foi a variaÃ§Ã£o de progresso por colaborador no Ãºltimo trimestre?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3519ms
   Exact Match: âœ—
   Component Match: 0.5625
   Execution Match: âœ—
   Cosine Similarity: 0.8822
   Table Similarity: 0.4792
   Query Affinity Score: 0.6807

   SQL Gerada:
   WITH latest_progress AS (SELECT kr_id, collaborator_id, progress, target, date, ROW_NUMBER() OVER (PARTITION BY kr_id, collaborator_id ORDER BY date DESC) as rn FROM kr_history WHERE date >= NOW() - INTERVAL '3 months'), earliest_progress AS (SELECT kr_id, collaborator_id, progress, target, date, ROW_NUMBER() OVER (PARTITION BY kr_id, collaborator_id ORDER BY date ASC) as rn FROM kr_history WHERE date >= NOW() - INTERVAL '3 months') SELECT c.name AS collaborator_name, SUM(lp.progress / NULLIF(lp.target, 0) - ep.progress / NULLIF(ep.target, 0)) AS progress_variation FROM collaborator c JOIN latest_progress lp ON c.id = lp.collaborator_id AND lp.rn = 1 JOIN earliest_progress ep ON c.id = ep.collaborator_id AND ep.kr_id = lp.kr_id AND ep.rn = 1 GROUP BY c.name ORDER BY progress_variation DESC;

   SQL Esperada (Gold):
   WITH Hist AS (SELECT kh.collaborator_id, kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog FROM kr_history kh WHERE kh.date >= NOW() - INTERVAL '3 month'), Ranked AS (SELECT collaborator_id, kr_id, norm_prog, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date ASC) AS rn_first, ROW_NUMBER() OVER (PARTITION BY collaborator_id, kr_id ORDER BY date DESC) AS rn_last FROM Hist), FirstLast AS (SELECT collaborator_id, kr_id, MAX(CASE WHEN rn_first = 1 THEN norm_prog END) AS first_prog, MAX(CASE WHEN rn_last = 1 THEN norm_prog END) AS last_prog FROM Ranked GROUP BY collaborator_id, kr_id) SELECT c.name, AVG(last_prog - first_prog) AS progress_change_qtr FROM collaborator c JOIN FirstLast fl ON c.id = fl.collaborator_id GROUP BY c.id, c.name ORDER BY progress_change_qtr DESC;

40. Quantos registros de histÃ³rico de KR foram criados no Ãºltimo mÃªs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2493ms
   Exact Match: âœ—
   Component Match: 0.9375
   Execution Match: âœ—
   Cosine Similarity: 0.8922
   Table Similarity: 1.0000
   Query Affinity Score: 0.9461
   Tentativas de correÃ§Ã£o: 2
     Tentativa 1: âŒ column "created_date" does not exist
     Tentativa 2: âœ… Corrigido

   SQL Gerada (original):
   SELECT COUNT(*) FROM kr_history WHERE created_date >= NOW() - INTERVAL '1 month';

   SQL Corrigida (final):
   SELECT COUNT(*) FROM kr_history WHERE date >= NOW() - INTERVAL '1 month'

   SQL Esperada (Gold):
   SELECT COUNT(id) AS history_count_last_month FROM kr_history WHERE date >= NOW() - INTERVAL '1' MONTH;

41. Quais KRs apresentaram regressÃ£o de progresso em algum momento?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3278ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.6476
   Table Similarity: 0.9217
   Query Affinity Score: 0.7847

   SQL Gerada:
   SELECT DISTINCT k.title FROM kr k JOIN kr_history kh1 ON k.id = kh1.kr_id JOIN kr_history kh2 ON k.id = kh2.kr_id WHERE kh1.date < kh2.date AND kh1.progress > kh2.progress AND k.direction = 'up' OR kh1.date < kh2.date AND kh1.progress < kh2.progress AND k.direction = 'down';

   SQL Esperada (Gold):
   WITH Regressions AS (SELECT kr_id, (progress / NULLIF(target,0)) AS norm_progress, LAG(progress / NULLIF(target,0)) OVER (PARTITION BY kr_id ORDER BY date) AS prev_norm_progress FROM kr_history) SELECT DISTINCT k.title FROM kr k JOIN Regressions r ON k.id = r.kr_id WHERE r.norm_progress < r.prev_norm_progress;

42. Qual a mÃ©dia de variaÃ§Ã£o percentual de progresso por mÃ©trica (PERC, NUMERIC, YES_NO)?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3295ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.8602
   Table Similarity: 0.6667
   Query Affinity Score: 0.7634
   Tentativas de correÃ§Ã£o: 3
     Tentativa 1: âŒ column reference "metric" is ambiguous
     Tentativa 2: âŒ aggregate function calls cannot contain window function calls
     Tentativa 3: âœ… Corrigido

   SQL Gerada (original):
   SELECT metric, AVG(CASE WHEN direction = 'up' THEN (progress - LAG(progress, 1, progress) OVER (PARTITION BY kr_id ORDER BY date)) / NULLIF(LAG(progress, 1, progress) OVER (PARTITION BY kr_id ORDER BY date), 0) WHEN direction = 'down' THEN (LAG(progress, 1, progress) OVER (PARTITION BY kr_id ORDER BY date) - progress) / NULLIF(LAG(progress, 1, progress) OVER (PARTITION BY kr_id ORDER BY date), 0) ELSE 0 END) AS avg_percentage_change FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE k.metric IN ('PERC', 'NUMERIC', 'YES_NO') GROUP BY metric;

   SQL Corrigida (final):
   WITH KrHistoryWithLag AS ( SELECT kh.kr_id, kh.progress, kh.date, k.metric, k.direction AS kr_direction, LAG(kh.progress, 1, kh.progress) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS previous_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id WHERE k.metric IN ('PERC', 'NUMERIC', 'YES_NO') ) SELECT khl.metric, AVG(CASE WHEN khl.kr_direction = 'up' THEN (khl.progress - khl.previous_progress) / NULLIF(khl.previous_progress, 0) WHEN khl.kr_direction = 'down' THEN (khl.previous_progress - khl.progress) / NULLIF(khl.previous_progress, 0) ELSE 0 END) AS avg_percentage_change FROM KrHistoryWithLag khl GROUP BY khl.metric;

   SQL Esperada (Gold):
   WITH ranked_history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kh.target,0)) AS norm_prog, k.metric, LAG(kh.progress / NULLIF(kh.target,0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_norm_prog FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), progress_changes AS (SELECT metric, ABS(norm_prog - prev_norm_prog) / NULLIF(prev_norm_prog, 0) * 100 AS variation_percent FROM ranked_history WHERE prev_norm_prog IS NOT NULL) SELECT metric, AVG(variation_percent) AS avg_variation_percent FROM progress_changes GROUP BY metric;

43. Quantos KRs tiveram histÃ³rico de progresso acima de 90% antes do prazo final?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2977ms
   Exact Match: âœ—
   Component Match: 1.0000
   Execution Match: âœ—
   Cosine Similarity: 0.8311
   Table Similarity: 0.0000
   Query Affinity Score: 0.4155

   SQL Gerada:
   SELECT COUNT(DISTINCT kh.kr_id) FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE (CASE WHEN k.direction = 'up' THEN kh.progress / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) > 0.9 AND kh.date < o.deadline;

   SQL Esperada (Gold):
   SELECT COUNT(DISTINCT kh.kr_id) as krs_acima_90 FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id WHERE (kh.progress/k.target)*100 >= 90 AND kh.date < o.deadline;

44. Quais colaboradores atualizaram o maior nÃºmero de KRs no histÃ³rico?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2797ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.8362
   Table Similarity: 0.1075
   Query Affinity Score: 0.4719

   SQL Gerada:
   SELECT c.name, COUNT(kh.id) AS total_updates FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.name ORDER BY total_updates DESC;

   SQL Esperada (Gold):
   SELECT c.id, c.name, COUNT(kh.id) as total_atualizacoes FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id GROUP BY c.id, c.name ORDER BY total_atualizacoes DESC LIMIT 10;

45. Quantos updates de iniciativa foram registrados por mÃªs neste ano?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2618ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.9200
   Table Similarity: 0.3333
   Query Affinity Score: 0.6267

   SQL Gerada:
   SELECT TO_CHAR(created_date, 'YYYY-MM') AS month, COUNT(*) AS total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY month ORDER BY month;

   SQL Esperada (Gold):
   SELECT EXTRACT(YEAR FROM created_date) as ano, EXTRACT(MONTH FROM created_date) as mes, COUNT(*) as total_updates FROM initiative_update WHERE EXTRACT(YEAR FROM created_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY ano, mes ORDER BY ano, mes;

46. Quais iniciativas tiveram maior nÃºmero de updates em um Ãºnico mÃªs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3036ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.9255
   Table Similarity: 0.0200
   Query Affinity Score: 0.4728

   SQL Gerada:
   SELECT i.title AS initiative_title, TO_CHAR(iu.created_date, 'YYYY-MM') AS month, COUNT(iu.id) AS num_updates FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.title, TO_CHAR(iu.created_date, 'YYYY-MM') ORDER BY num_updates DESC LIMIT 1;

   SQL Esperada (Gold):
   SELECT i.id, i.title, EXTRACT(YEAR FROM iu.created_date) as ano, EXTRACT(MONTH FROM iu.created_date) as mes, COUNT(iu.id) as updates_mes FROM initiative i JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY i.id, i.title, ano, mes ORDER BY updates_mes DESC LIMIT 10;

47. Qual o tempo mÃ©dio entre updates consecutivos de uma mesma iniciativa?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2792ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.8530
   Table Similarity: 1.0000
   Query Affinity Score: 0.9265

   SQL Gerada:
   WITH initiative_updates_ranked AS (SELECT initiative_id, created_date, LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date) AS previous_created_date FROM initiative_update) SELECT AVG(EXTRACT(EPOCH FROM (created_date - previous_created_date))) / (60 * 60 * 24) AS average_time_between_updates_days FROM initiative_updates_ranked WHERE previous_created_date IS NOT NULL;

   SQL Esperada (Gold):
   WITH update_gaps AS (SELECT initiative_id, EXTRACT(EPOCH FROM (created_date - LAG(created_date) OVER (PARTITION BY initiative_id ORDER BY created_date))) / 86400 as dias_entre_updates FROM initiative_update) SELECT AVG(dias_entre_updates) as tempo_medio_dias FROM update_gaps WHERE dias_entre_updates IS NOT NULL;

48. Para cada iniciativa, qual Ã© o KR mais recente e seu progresso atual?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3722ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.8332
   Table Similarity: 0.2478
   Query Affinity Score: 0.5405

   SQL Gerada:
   WITH LatestKR AS (SELECT kr.id AS kr_id, kr.okr_id, kr.title AS kr_title, kr.progress, kr.target, kr.direction, kr.created_date, ROW_NUMBER() OVER (PARTITION BY okr.initiative_id ORDER BY kr.created_date DESC) AS rn FROM kr JOIN okr ON kr.okr_id = okr.id) SELECT i.title AS initiative_title, lk.kr_title, CASE WHEN lk.direction = 'up' THEN lk.progress / NULLIF(lk.target, 0) WHEN lk.direction = 'down' THEN (lk.target - lk.progress) / NULLIF(lk.target, 0) ELSE NULL END AS current_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN LatestKR lk ON o.id = lk.okr_id WHERE lk.rn = 1;

   SQL Esperada (Gold):
   WITH ranked_krs AS (SELECT i.id as iniciativa_id, i.title as iniciativa, k.id as kr_id, k.title as kr, k.progress, k.last_modified_date, ROW_NUMBER() OVER (PARTITION BY i.id ORDER BY k.last_modified_date DESC) as rn FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id) SELECT iniciativa_id, iniciativa, kr_id, kr, progress FROM ranked_krs WHERE rn = 1;

49. Analisar a tendÃªncia de reduÃ§Ã£o na frequÃªncia de updates conforme o deadline dos OKRs se aproxima.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3138ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.9248
   Table Similarity: 0.1698
   Query Affinity Score: 0.5473

   SQL Gerada:
   SELECT o.deadline AS okr_deadline, COUNT(iu.id) AS total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / (60 * 60 * 24)) AS avg_days_to_deadline_at_update FROM okr o JOIN initiative i ON o.initiative_id = i.id JOIN initiative_update iu ON i.id = iu.initiative_id GROUP BY o.deadline ORDER BY o.deadline;

   SQL Esperada (Gold):
   SELECT i.id, i.title, o.deadline, COUNT(iu.id) as total_updates, AVG(EXTRACT(EPOCH FROM (o.deadline - iu.created_date)) / 86400) as dias_antes_prazo_medio FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN initiative_update iu ON i.id = iu.initiative_id WHERE iu.created_date <= o.deadline GROUP BY i.id, i.title, o.deadline ORDER BY dias_antes_prazo_medio;

50. Listar KRs com lacunas maiores que 30 dias entre atualizaÃ§Ãµes de progresso
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2887ms
   Exact Match: âœ—
   Component Match: 0.5000
   Execution Match: âœ—
   Cosine Similarity: 0.7345
   Table Similarity: 0.1255
   Query Affinity Score: 0.4300

   SQL Gerada:
   WITH kr_updates AS (SELECT kr_id, date, LAG(date) OVER (PARTITION BY kr_id ORDER BY date) AS previous_date FROM kr_history) SELECT DISTINCT kr_id FROM kr_updates WHERE previous_date IS NOT NULL AND (date - previous_date) > INTERVAL '30 days';

   SQL Esperada (Gold):
   WITH kr_update_gaps AS (SELECT kh.kr_id, k.title as kr_title, kh.date as current_date, LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) as previous_date, EXTRACT(EPOCH FROM (kh.date - LAG(kh.date) OVER (PARTITION BY kh.kr_id ORDER BY kh.date))) / 86400 as dias_entre_atualizacoes FROM kr_history kh JOIN kr k ON kh.kr_id = k.id) SELECT kr_id, kr_title, previous_date, current_date, dias_entre_atualizacoes FROM kr_update_gaps WHERE dias_entre_atualizacoes > 30 ORDER BY dias_entre_atualizacoes DESC;

51. Quais OKRs estÃ£o com prazo prÃ³ximo do vencimento?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2820ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ“
   Cosine Similarity: 0.9141
   Table Similarity: 1.0000
   Query Affinity Score: 0.9571

   SQL Gerada:
   SELECT * FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days';

   SQL Esperada (Gold):
   SELECT id, deadline FROM okr WHERE deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' ORDER BY deadline ASC;

52. Qual Ã© a mÃ©dia de progresso dos KRs em cada OKR?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3195ms
   Exact Match: âœ—
   Component Match: 0.9375
   Execution Match: âœ—
   Cosine Similarity: 0.8859
   Table Similarity: 0.7724
   Query Affinity Score: 0.8292

   SQL Gerada:
   SELECT okr_id, AVG(CASE WHEN direction = 'up' THEN progress / NULLIF(target, 0) WHEN direction = 'down' THEN (target - progress) / NULLIF(target, 0) ELSE 0 END) AS average_progress FROM kr GROUP BY okr_id;

   SQL Esperada (Gold):
   SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id;

53. Quais OKRs tÃªm menor progresso mÃ©dio?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3257ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.8104
   Table Similarity: 0.0096
   Query Affinity Score: 0.4100
   Tentativas de correÃ§Ã£o: 2
     Tentativa 1: âŒ column o.title does not exist
     Tentativa 2: âœ… Corrigido

   SQL Gerada (original):
   SELECT o.title, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.title ORDER BY average_progress ASC;

   SQL Corrigida (final):
   SELECT o.description, AVG(CASE WHEN k.direction = 'up' THEN k.progress::numeric / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target::numeric - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS average_progress FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.description ORDER BY average_progress ASC;

   SQL Esperada (Gold):
   SELECT okr_id, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY okr_id ORDER BY avg_progress ASC LIMIT 5;

54. Qual Ã© o percentual de KRs concluÃ­dos por iniciativa?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3094ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.9312
   Table Similarity: 0.0652
   Query Affinity Score: 0.4982

   SQL Gerada:
   SELECT i.title AS initiative_title, COUNT(CASE WHEN k.direction = 'up' AND k.progress >= k.target THEN 1 WHEN k.direction = 'down' AND k.progress <= k.target THEN 1 ELSE NULL END) * 100.0 / COUNT(k.id) AS percentage_completed_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.title ORDER BY i.title;

   SQL Esperada (Gold):
   SELECT i.id AS initiative_id, SUM(CASE WHEN (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) >= 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) <= 1) THEN 1 ELSE 0 END) * 100.0 / COUNT(k.id) AS percent_completed FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id;

55. Qual o tempo mÃ©dio restante atÃ© o deadline dos OKRs ativos?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2582ms
   Exact Match: âœ—
   Component Match: 0.9375
   Execution Match: âœ—
   Cosine Similarity: 0.8867
   Table Similarity: 0.0000
   Query Affinity Score: 0.4433
   Tentativas de correÃ§Ã£o: 2
     Tentativa 1: âŒ column o.active does not exist
     Tentativa 2: âœ… Corrigido

   SQL Gerada (original):
   SELECT AVG(EXTRACT(EPOCH FROM (o.deadline - NOW()))) AS average_time_remaining_seconds FROM okr o WHERE o.active = TRUE;

   SQL Corrigida (final):
   SELECT AVG(EXTRACT(EPOCH FROM (o.deadline - NOW()))) AS average_time_remaining_seconds FROM okr o WHERE o.deadline > NOW();

   SQL Esperada (Gold):
   SELECT AVG(EXTRACT(EPOCH FROM (deadline - NOW())) / 86400) AS avg_days_remaining FROM okr WHERE deadline > NOW();

56. Quais OKRs estÃ£o vinculados a iniciativas que jÃ¡ encerraram?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2585ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.8820
   Table Similarity: 0.2500
   Query Affinity Score: 0.5660

   SQL Gerada:
   SELECT DISTINCT o.* FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date < NOW();

   SQL Esperada (Gold):
   SELECT o.id AS okr_id, o.initiative_id, i.end_date FROM okr o JOIN initiative i ON o.initiative_id = i.id WHERE i.end_date IS NOT NULL AND i.end_date < NOW();

57. Quantos KRs estÃ£o atrasados em relaÃ§Ã£o Ã  meta planejada?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2756ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.7644
   Table Similarity: 0.0000
   Query Affinity Score: 0.3822

   SQL Gerada:
   SELECT COUNT(*) FROM kr WHERE (CASE WHEN direction = 'up' THEN progress < target WHEN direction = 'down' THEN progress > target ELSE FALSE END);

   SQL Esperada (Gold):
   SELECT COUNT(*) AS delayed_kr_count FROM kr k JOIN kr_history kh ON kh.kr_id = k.id AND kh.date = (SELECT MAX(h.date) FROM kr_history h WHERE h.kr_id = k.id) WHERE (k.direction = 'up'  AND k.progress / NULLIF(k.target,0) < 1) OR (k.direction = 'down' AND k.progress / NULLIF(k.target,0) > 1);

58. Qual o progresso mÃ©dio dos KRs de tipo â€œPERCâ€ em comparaÃ§Ã£o aos de tipo â€œNUMERICâ€?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2602ms
   Exact Match: âœ—
   Component Match: 1.0000
   Execution Match: âœ—
   Cosine Similarity: 0.9769
   Table Similarity: 1.0000
   Query Affinity Score: 0.9885

   SQL Gerada:
   SELECT metric, AVG(progress / NULLIF(target, 0)) AS average_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric;

   SQL Esperada (Gold):
   SELECT metric, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr WHERE metric IN ('PERC', 'NUMERIC') GROUP BY metric;

59. Quais OKRs tÃªm maior nÃºmero de KRs associados?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2713ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.7890
   Table Similarity: 0.0249
   Query Affinity Score: 0.4069

   SQL Gerada:
   SELECT o.id AS okr_id, o.description AS okr_description, COUNT(k.id) AS num_krs FROM okr o JOIN kr k ON o.id = k.okr_id GROUP BY o.id, o.description ORDER BY num_krs DESC;

   SQL Esperada (Gold):
   SELECT okr_id, COUNT(*) AS kr_count FROM kr GROUP BY okr_id ORDER BY kr_count DESC LIMIT 5;

60. Qual o percentual de KRs marcados como â€œbookmarkedâ€ pelos colaboradores?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2675ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.8350
   Table Similarity: 1.0000
   Query Affinity Score: 0.9175

   SQL Gerada:
   SELECT CAST(SUM(CASE WHEN bookmarked = TRUE THEN 1 ELSE 0 END) AS DECIMAL) * 100 / COUNT(*) AS percentage_bookmarked FROM kr;

   SQL Esperada (Gold):
   SELECT COUNT(*) FILTER (WHERE bookmarked) * 100.0 / COUNT(*) AS percent_bookmarked FROM kr;

61. Qual Ã© o percentual mÃ©dio de progresso dos KRs (Key Results) em relaÃ§Ã£o Ã s metas estabelecidas nos Ãºltimos trÃªs meses?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2817ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.8740
   Table Similarity: 0.0000
   Query Affinity Score: 0.4370

   SQL Gerada:
   SELECT AVG(CASE WHEN direction = 'up' THEN kr.progress / NULLIF(kr.target, 0) WHEN direction = 'down' THEN (kr.target - kr.progress) / NULLIF(kr.target, 0) ELSE 0 END) AS average_progress_percentage FROM kr WHERE created_date >= NOW() - INTERVAL '3 months';

   SQL Esperada (Gold):
   SELECT AVG(kh.progress / NULLIF(k.target, 0)) * 100 AS avg_progress_percent FROM kr k JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.date >= NOW() - INTERVAL '3 months';

62. Quais colaboradores tÃªm mais KRs marcados como â€œbookmarkedâ€ (favoritos) e demonstram maior engajamento com os objetivos da empresa?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2658ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.9556
   Table Similarity: 0.2319
   Query Affinity Score: 0.5938

   SQL Gerada:
   SELECT c.name, COUNT(k.id) AS bookmarked_krs_count FROM collaborator c JOIN kr k ON c.id = k.bookmarked_by_id WHERE k.bookmarked = TRUE GROUP BY c.name ORDER BY bookmarked_krs_count DESC;

   SQL Esperada (Gold):
   SELECT c.id, c.name, COUNT(k.id) AS bookmarked_kr_count FROM collaborator c JOIN kr k ON k.bookmarked_by_id = c.id AND k.bookmarked = true GROUP BY c.id, c.name ORDER BY bookmarked_kr_count DESC LIMIT 10;

63. Qual Ã© o tempo mÃ©dio entre a criaÃ§Ã£o de um OKR e a primeira atualizaÃ§Ã£o de progresso registrada?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3120ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.9406
   Table Similarity: 0.0000
   Query Affinity Score: 0.4703

   SQL Gerada:
   SELECT AVG(EXTRACT(EPOCH FROM (kh.date - o.created_date))) AS avg_time_to_first_update_seconds FROM okr o JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE kh.date = (SELECT MIN(kh2.date) FROM kr_history kh2 WHERE kh2.kr_id = k.id);

   SQL Esperada (Gold):
   SELECT AVG(EXTRACT(EPOCH FROM (kh.first_update - o.created_date)) / 86400) AS avg_days_to_first_update FROM okr o JOIN (SELECT k.okr_id, MIN(kh.date) AS first_update FROM kr k JOIN kr_history kh ON kh.kr_id = k.id GROUP BY k.okr_id) kh ON kh.okr_id = o.id;

64. Quantos OKRs estÃ£o prÃ³ximos do prazo final (deadline) e ainda nÃ£o atingiram 80% de progresso?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2669ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.8535
   Table Similarity: 0.0000
   Query Affinity Score: 0.4267

   SQL Gerada:
   SELECT COUNT(DISTINCT o.id) FROM okr o JOIN kr k ON o.id = k.okr_id WHERE o.deadline IS NOT NULL AND o.deadline <= NOW() + INTERVAL '7 days' AND (k.progress / NULLIF(k.target, 0)) < 0.8;

   SQL Esperada (Gold):
   SELECT COUNT(*) AS okrs_near_deadline_low_progress FROM ( SELECT o.id FROM okr o JOIN kr k ON k.okr_id = o.id WHERE o.deadline BETWEEN NOW() AND NOW() + INTERVAL '7 days' GROUP BY o.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8 ) sub;

65. Quais iniciativas possuem OKRs cujo progresso mÃ©dio supera o progresso mÃ©dio global de todas as iniciativas da mesma categoria?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3270ms
   Exact Match: âœ—
   Component Match: 0.6875
   Execution Match: âœ—
   Cosine Similarity: 0.9200
   Table Similarity: 0.5417
   Query Affinity Score: 0.7308

   SQL Gerada:
   WITH InitiativeAvgProgress AS (SELECT i.id AS initiative_id, i.category, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN (k.target - k.progress) / NULLIF(k.target, 0) ELSE 0 END) AS avg_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id, i.category), CategoryAvgProgress AS (SELECT category, AVG(avg_okr_progress) AS global_avg_progress FROM InitiativeAvgProgress GROUP BY category) SELECT iap.initiative_id, iap.category, iap.avg_okr_progress FROM InitiativeAvgProgress iap JOIN CategoryAvgProgress cap ON iap.category = cap.category WHERE iap.avg_okr_progress > cap.global_avg_progress;

   SQL Esperada (Gold):
   WITH initiative_avg AS (SELECT i.id, i.category, AVG(k.progress / NULLIF(k.target, 0)) AS avg_progress FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, i.category), category_avg AS (SELECT category, AVG(avg_progress) AS category_avg_progress FROM initiative_avg GROUP BY category) SELECT ia.id, ia.category, ia.avg_progress FROM initiative_avg ia JOIN category_avg ca ON ia.category = ca.category WHERE ia.avg_progress > ca.category_avg_progress;

66. Qual colaborador teve o maior aumento percentual de progresso mÃ©dio de KRs entre o Ãºltimo e o penÃºltimo mÃªs?
   Status: âŒ ERROR
   Erro: Erro de execuÃ§Ã£o no banco apÃ³s 3 tentativa(s): syntax error at or near "{"

   SQL Gerada (com erro):
   { "sql": "WITH monthly_progress AS (SELECT c.id AS collaborator_id, c.name AS collaborator_name, DATE_TRUNC('month', kh.date) AS month, AVG(CASE WHEN k.direction = 'up' THEN kh.progress::numeric / NULLIF(kh.target, 0) WHEN k.direction = 'down' THEN (kh.target::numeric - kh.progress) / NULLIF(kh.target, 0) ELSE 0 END) AS avg_kr_progress FROM collaborator c JOIN kr_history kh ON c.id = kh.collaborator_id JOIN kr k ON kh.kr_id = k.id GROUP BY c.id, c.name, DATE_TRUNC('month', kh.date) ORDER BY c.id, month DESC), ranked_progress AS (SELECT collaborator_id, collaborator_name, month, avg_kr_progress, RANK() OVER (PARTITION BY collaborator_id ORDER BY month DESC) AS rn FROM monthly_progress), last_two_months AS (SELECT collaborator_id, collaborator_name, month, avg_kr_progress, rn FROM ranked_progress WHERE rn <= 2), pivot_months AS (SELECT collaborator_id, collaborator_name, MAX(CASE WHEN rn = 1 THEN avg_kr_progress END) AS last_month_progress, MAX(CASE WHEN rn = 2 THEN avg_kr_progress END) AS second_last_month_progress FROM last_two_months GROUP BY collaborator_id, collaborator_name HAVING COUNT(DISTINCT rn) = 2) SELECT collaborator_name, (last_month_progress - second_last_month_progress) / NULLIF(second_last_month_progress, 0) * 100 AS percentage_increase FROM pivot_months ORDER BY percentage_increase DESC LIMIT 1;", "complementaryText": "Esta query identifica o colaborador com o maior aumento percentual no progresso mÃ©dio de KRs entre o Ãºltimo e o penÃºltimo mÃªs. Ela calcula o progresso mÃ©dio mensal de cada colaborador, filtra os dois Ãºltimos meses, pivota os dados para comparar o progresso entre esses meses e, finalmente, calcula o aumento percentual para encontrar o colaborador com o maior crescimento. As colunas utilizadas sÃ£o `collaborator.id`, `collaborator

   SQL Esperada (Gold):
   WITH monthly_progress AS (SELECT collaborator_id, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr_history GROUP BY collaborator_id, month), ranked_progress AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY collaborator_id ORDER BY month DESC) AS rn FROM monthly_progress), last_two_months AS (SELECT p1.collaborator_id, p1.avg_progress AS last_month_progress, p2.avg_progress AS prev_month_progress, CASE WHEN p2.avg_progress = 0 THEN NULL ELSE ((p1.avg_progress - p2.avg_progress) / p2.avg_progress) * 100 END AS pct_increase FROM ranked_progress p1 JOIN ranked_progress p2 ON p1.collaborator_id = p2.collaborator_id WHERE p1.rn = 1 AND p2.rn = 2) SELECT collaborator_id, pct_increase FROM last_two_months ORDER BY pct_increase DESC LIMIT 1;

67. Quais iniciativas tiveram pelo menos um KR com progresso superior a 100% em algum ponto do histÃ³rico?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2693ms
   Exact Match: âœ—
   Component Match: 0.8750
   Execution Match: âœ—
   Cosine Similarity: 0.9197
   Table Similarity: 0.2407
   Query Affinity Score: 0.5802

   SQL Gerada:
   SELECT DISTINCT i.title FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN kr_history kh ON k.id = kh.kr_id WHERE (kh.direction = 'up' AND kh.progress / NULLIF(kh.target, 0) > 1.0) OR (kh.direction = 'down' AND kh.progress / NULLIF(kh.target, 0) < 1.0);

   SQL Esperada (Gold):
   SELECT DISTINCT i.id, i.title FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id JOIN kr_history kh ON kh.kr_id = k.id WHERE kh.progress / NULLIF(kh.target, 0) > 1;

68. Qual Ã© o tempo mÃ©dio (em dias) entre atualizaÃ§Ãµes consecutivas de um mesmo KR no histÃ³rico?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2826ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.9172
   Table Similarity: 0.0000
   Query Affinity Score: 0.4586

   SQL Gerada:
   SELECT AVG(EXTRACT(EPOCH FROM (next_date - date))) / (60 * 60 * 24) AS average_time_between_updates_days FROM (SELECT kr_id, date, LEAD(date, 1) OVER (PARTITION BY kr_id ORDER BY date) AS next_date FROM kr_history) AS subquery WHERE next_date IS NOT NULL;

   SQL Esperada (Gold):
   WITH diffs AS (SELECT kr_id, date, LEAD(date) OVER (PARTITION BY kr_id ORDER BY date) AS next_date FROM kr_history) SELECT AVG(EXTRACT(EPOCH FROM (next_date - date)) / 86400) AS avg_days_between_updates FROM diffs WHERE next_date IS NOT NULL;

69. Quais iniciativas tÃªm pelo menos dois OKRs com deadlines no mesmo mÃªs?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2754ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.8357
   Table Similarity: 0.0000
   Query Affinity Score: 0.4179

   SQL Gerada:
   SELECT i.title AS initiative_title FROM initiative i JOIN okr o ON i.id = o.initiative_id GROUP BY i.id, i.title, EXTRACT(YEAR FROM o.deadline), EXTRACT(MONTH FROM o.deadline) HAVING COUNT(o.id) >= 2;

   SQL Esperada (Gold):
   SELECT initiative_id FROM okr GROUP BY initiative_id, DATE_TRUNC('month', deadline) HAVING COUNT(*) >= 2;

70. Qual Ã© a distribuiÃ§Ã£o percentual de KRs por tipo de mÃ©trica dentro de cada iniciativa?
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2944ms
   Exact Match: âœ—
   Component Match: 0.6250
   Execution Match: âœ—
   Cosine Similarity: 0.8283
   Table Similarity: 0.3333
   Query Affinity Score: 0.5808

   SQL Gerada:
   SELECT i.title AS initiative_title, k.metric, CAST(COUNT(k.id) AS DECIMAL) * 100 / SUM(COUNT(k.id)) OVER (PARTITION BY i.id) AS percentage_of_krs FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id GROUP BY i.id, i.title, k.metric ORDER BY i.title, k.metric;

   SQL Esperada (Gold):
   WITH kr_counts AS (SELECT i.id AS initiative_id, k.metric, COUNT(*) AS count FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id GROUP BY i.id, k.metric), initiative_totals AS (SELECT initiative_id, SUM(count) AS total FROM kr_counts GROUP BY initiative_id) SELECT kc.initiative_id, kc.metric, (kc.count::float / it.total) * 100 AS percent FROM kr_counts kc JOIN initiative_totals it ON kc.initiative_id = it.initiative_id ORDER BY kc.initiative_id, percent DESC;

71. Listar os KRs cujo progresso atual estÃ¡ abaixo da mÃ©dia dos KRs do mesmo tipo e direÃ§Ã£o.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3150ms
   Exact Match: âœ“
   Component Match: 1.0000
   Execution Match: âœ“
   Cosine Similarity: 1.0000
   Table Similarity: 1.0000
   Query Affinity Score: 1.0000

   SQL Gerada:
   WITH avg_progress AS (SELECT metric, direction, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY metric, direction) SELECT k.* FROM kr k JOIN avg_progress ap ON k.metric = ap.metric AND k.direction = ap.direction WHERE (k.progress / NULLIF(k.target, 0)) < ap.avg_progress;

   SQL Esperada (Gold):
   WITH avg_progress AS (SELECT metric, direction, AVG(progress / NULLIF(target, 0)) AS avg_progress FROM kr GROUP BY metric, direction) SELECT k.* FROM kr k JOIN avg_progress ap ON k.metric = ap.metric AND k.direction = ap.direction WHERE (k.progress / NULLIF(k.target, 0)) < ap.avg_progress;

72. Identificar iniciativas que mantÃªm registros de atualizaÃ§Ã£o em meses consecutivos, sem interrupÃ§Ãµes.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2856ms
   Exact Match: âœ—
   Component Match: 0.5625
   Execution Match: âœ—
   Cosine Similarity: 0.8641
   Table Similarity: 0.0000
   Query Affinity Score: 0.4321

   SQL Gerada:
   WITH InitiativeMonths AS (SELECT DISTINCT initiative_id, DATE_TRUNC('month', created_date) AS month FROM initiative_update), ConsecutiveMonths AS (SELECT initiative_id, month, LAG(month, 1) OVER (PARTITION BY initiative_id ORDER BY month) AS prev_month FROM InitiativeMonths) SELECT DISTINCT i.title FROM ConsecutiveMonths cm JOIN initiative i ON cm.initiative_id = i.id WHERE cm.prev_month IS NOT NULL AND cm.month = (cm.prev_month + INTERVAL '1 month');

   SQL Esperada (Gold):
   WITH updates_months AS (SELECT initiative_id, DATE_TRUNC('month', created_date) AS month FROM initiative_update GROUP BY initiative_id, month), consecutive AS (SELECT initiative_id, month, LAG(month) OVER (PARTITION BY initiative_id ORDER BY month) AS prev_month FROM updates_months), gaps AS (SELECT initiative_id, COUNT(*) FILTER (WHERE prev_month IS NOT NULL AND month - INTERVAL '1 month' <> prev_month) AS gap_count, COUNT(month) AS total_months FROM consecutive GROUP BY initiative_id) SELECT initiative_id FROM gaps WHERE gap_count = 0 AND total_months > 1;

73. Calcular a taxa mÃ©dia de crescimento mensal do progresso dos KRs, segmentada por tipo de mÃ©trica.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3418ms
   Exact Match: âœ—
   Component Match: 0.7500
   Execution Match: âœ—
   Cosine Similarity: 0.9509
   Table Similarity: 0.6667
   Query Affinity Score: 0.8088

   SQL Gerada:
   WITH monthly_progress AS (SELECT kr_id, metric, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target, 0)) AS avg_monthly_progress FROM kr_history GROUP BY kr_id, metric, DATE_TRUNC('month', date)), monthly_growth AS (SELECT kr_id, metric, month, avg_monthly_progress, LAG(avg_monthly_progress, 1, avg_monthly_progress) OVER (PARTITION BY kr_id ORDER BY month) AS previous_month_progress FROM monthly_progress) SELECT metric, AVG((avg_monthly_progress - previous_month_progress) / NULLIF(previous_month_progress, 0)) AS avg_monthly_growth_rate FROM monthly_growth WHERE previous_month_progress IS NOT NULL GROUP BY metric ORDER BY metric;

   SQL Esperada (Gold):
   WITH monthly_kr_progress AS (SELECT kr_id, metric, DATE_TRUNC('month', date) AS month, AVG(progress / NULLIF(target,0)) AS avg_progress FROM kr_history GROUP BY kr_id, metric, month), monthly_growth AS (SELECT kr_id, metric, month, avg_progress, LAG(avg_progress) OVER (PARTITION BY kr_id ORDER BY month) AS prev_avg_progress FROM monthly_kr_progress), growth_rate AS (SELECT metric, AVG(CASE WHEN prev_avg_progress IS NOT NULL THEN (avg_progress - prev_avg_progress) / NULLIF(prev_avg_progress,0) ELSE NULL END) AS avg_monthly_growth_rate FROM monthly_growth GROUP BY metric) SELECT metric, avg_monthly_growth_rate FROM growth_rate;

74. Detectar iniciativas que apresentaram regressÃ£o mÃ©dia no progresso de seus KRs durante o Ãºltimo ciclo de atualizaÃ§Ã£o.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 4205ms
   Exact Match: âœ—
   Component Match: 0.5000
   Execution Match: âœ—
   Cosine Similarity: 0.8386
   Table Similarity: 0.1591
   Query Affinity Score: 0.4988

   SQL Gerada:
   WITH kr_progress_history AS (SELECT kh.kr_id, kh.date, kh.progress, kh.target, k.direction, (CASE WHEN k.direction = 'up' THEN kh.progress / NULLIF(kh.target, 0) ELSE kh.target / NULLIF(kh.progress, 0) END) AS calculated_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id), latest_two_cycles AS (SELECT kr_id, date, calculated_progress, RANK() OVER (PARTITION BY kr_id ORDER BY date DESC) AS rn FROM kr_progress_history), latest_progress AS (SELECT kr_id, calculated_progress AS latest_val FROM latest_two_cycles WHERE rn = 1), previous_progress AS (SELECT kr_id, calculated_progress AS previous_val FROM latest_two_cycles WHERE rn = 2) SELECT i.title AS initiative_title, i.id AS initiative_id, AVG(lp.latest_val) AS avg_latest_progress, AVG(pp.previous_val) AS avg_previous_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id JOIN latest_progress lp ON k.id = lp.kr_id JOIN previous_progress pp ON k.id = pp.kr_id WHERE lp.latest_val < pp.previous_val GROUP BY i.title, i.id HAVING AVG(lp.latest_val) < AVG(pp.previous_val);

   SQL Esperada (Gold):
   WITH last_two_updates AS (SELECT kh.kr_id, i.id AS initiative_id, kh.date, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn, kh.progress / NULLIF(k.target, 0) AS relative_progress FROM kr_history kh JOIN kr k ON kh.kr_id = k.id JOIN okr o ON k.okr_id = o.id JOIN initiative i ON o.initiative_id = i.id), progress_diff AS (SELECT a.initiative_id, AVG(a.relative_progress - b.relative_progress) AS avg_progress_change FROM last_two_updates a JOIN last_two_updates b ON a.kr_id = b.kr_id AND a.rn = 1 AND b.rn = 2 GROUP BY a.initiative_id) SELECT initiative_id FROM progress_diff WHERE avg_progress_change < 0;

75. Apontar iniciativas cujos OKRs estÃ£o vencidos, mas cujo progresso mÃ©dio permanece abaixo de 80%.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 3343ms
   Exact Match: âœ—
   Component Match: 0.8125
   Execution Match: âœ—
   Cosine Similarity: 0.8392
   Table Similarity: 0.0000
   Query Affinity Score: 0.4196

   SQL Gerada:
   SELECT i.title AS initiative_title, AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress / NULLIF(k.target, 0)) ELSE 0 END) AS average_okr_progress FROM initiative i JOIN okr o ON i.id = o.initiative_id JOIN kr k ON o.id = k.okr_id WHERE o.deadline < NOW() GROUP BY i.id, i.title HAVING AVG(CASE WHEN k.direction = 'up' THEN k.progress / NULLIF(k.target, 0) WHEN k.direction = 'down' THEN 1 - (k.progress / NULLIF(k.target, 0)) ELSE 0 END) < 0.8;

   SQL Esperada (Gold):
   SELECT i.id AS initiative_id FROM initiative i JOIN okr o ON o.initiative_id = i.id JOIN kr k ON k.okr_id = o.id WHERE o.deadline < NOW() GROUP BY i.id HAVING AVG(k.progress / NULLIF(k.target, 0)) < 0.8;

76. Identificar KRs com direÃ§Ã£o â€œNEGATIVAâ€ que mantÃªm melhora contÃ­nua e atingem o target definido.
   Status: âœ… SUCCESS
   Tempo de execuÃ§Ã£o: 2568ms
   Exact Match: âœ—
   Component Match: 0.4375
   Execution Match: âœ—
   Cosine Similarity: 0.7318
   Table Similarity: 0.0946
   Query Affinity Score: 0.4132

   SQL Gerada:
   SELECT k.id, k.title, k.metric, k.direction, k.progress, k.target FROM kr k WHERE k.direction = 'down' AND k.progress <= k.target;

   SQL Esperada (Gold):
   WITH kr_direction AS (SELECT k.id AS kr_id, k.target, k.direction FROM kr k WHERE k.direction = 'down'), history AS (SELECT kh.kr_id, kh.date, (kh.progress / NULLIF(kd.target, 0)) AS relative_progress, LAG(kh.progress / NULLIF(kd.target, 0)) OVER (PARTITION BY kh.kr_id ORDER BY kh.date) AS prev_progress FROM kr_history kh JOIN kr_direction kd ON kd.kr_id = kh.kr_id), fully_improving AS (SELECT kr_id FROM history GROUP BY kr_id HAVING COUNT(*) FILTER (WHERE prev_progress IS NOT NULL AND relative_progress >= prev_progress) = COUNT(*) - 1), achieved AS (SELECT kr_id FROM (SELECT kh.kr_id, (kh.progress / NULLIF(k.target,0)) AS relative_progress, ROW_NUMBER() OVER (PARTITION BY kh.kr_id ORDER BY kh.date DESC) AS rn FROM kr_history kh JOIN kr k ON k.id = kh.kr_id WHERE k.direction = 'down') last_value WHERE rn = 1 AND relative_progress <= 1) SELECT DISTINCT kr_id FROM fully_improving JOIN achieved USING(kr_id);

